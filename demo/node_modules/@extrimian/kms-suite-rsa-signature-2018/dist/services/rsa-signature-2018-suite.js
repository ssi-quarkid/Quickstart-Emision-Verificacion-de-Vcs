"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RSASignature2018Suite = void 0;
const kms_core_1 = require("@extrimian/kms-core");
const kms_suite_jsonld_1 = require("@extrimian/kms-suite-jsonld");
// import cryptold from "crypto-ld";
const jsigs = require('jsonld-signatures');
const rsa = require('js-crypto-rsa'); // for npm
var jwkToPem = require('jwk-to-pem');
const { RsaSignature2018 } = jsigs.suites;
let RSASignature2018Suite = class RSASignature2018Suite extends kms_suite_jsonld_1.JsonLDSuite {
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, rej) => {
                rsa.generateKey(2048).then((key) => {
                    // now you get the JWK public and private keys
                    const publicKey = key.publicKey;
                    const privateKey = key.privateKey;
                    resolve({
                        publicKeyJWK: publicKey,
                        privateKeyJWK: privateKey,
                        privateKey: null,
                        publicKey: null,
                    });
                });
            });
        });
    }
    getSuite(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.secret && params) {
                const key = new jsigs.RSAKeyPair({
                    id: params.verificationMethodId,
                    controller: params.controllerDid,
                    privateKeyPem: jwkToPem(this.secret.privateKeyJWK, { private: true }),
                    publicKeyPem: jwkToPem(this.secret.publicKeyJWK),
                });
                return new RsaSignature2018({ key });
            }
            else {
                return new RsaSignature2018();
            }
        });
    }
};
RSASignature2018Suite = __decorate([
    (0, kms_core_1.suiteDecorator)(kms_core_1.Suite.RsaSignature2018)
], RSASignature2018Suite);
exports.RSASignature2018Suite = RSASignature2018Suite;
//# sourceMappingURL=rsa-signature-2018-suite.js.map
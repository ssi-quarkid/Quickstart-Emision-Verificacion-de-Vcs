"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDCommSuite = void 0;
var bytes_1 = require("@ethersproject/bytes");
var kms_core_1 = require("@extrimian/kms-core");
// import { crypto_sign_keypair, sodium.from_hex } from 'wrappers';
var _sodium = require("libsodium-wrappers");
var did_jwt_1 = require("did-jwt");
var u8a = require("uint8arrays");
var ed25519_1 = require("@stablelib/ed25519");
var x25519_1 = require("@stablelib/x25519");
var PCT_ENCODED = '(?:%[0-9a-fA-F]{2})';
var ID_CHAR = "(?:[a-zA-Z0-9._-]|".concat(PCT_ENCODED, ")");
var METHOD = '([a-z0-9]+)';
var METHOD_ID = "((?:".concat(ID_CHAR, "*:)*(").concat(ID_CHAR, "+))");
var PARAM_CHAR = '[a-zA-Z0-9_.:%-]';
var PARAM = ";".concat(PARAM_CHAR, "+=").concat(PARAM_CHAR, "*");
var PARAMS = "((".concat(PARAM, ")*)");
var PATH = "(/[^#?]*)?";
var QUERY = "([?][^#]*)?";
var FRAGMENT = "(#.*)?";
var DID_MATCHER = new RegExp("^did:".concat(METHOD, ":").concat(METHOD_ID).concat(PARAMS).concat(PATH).concat(QUERY).concat(FRAGMENT, "$"));
var DIDCommSuite = /** @class */ (function () {
    function DIDCommSuite(didResolver) {
        this.didResolver = didResolver;
    }
    DIDCommSuite.prototype.load = function (keyPair) {
        this.keyPair = keyPair;
        if (keyPair) {
            if (keyPair.publicKey.indexOf("0x") == 0) {
                this.keyPair = {
                    privateKey: this.keyPair.privateKey,
                    publicKey: this.keyPair.publicKey.substring(2),
                    keyType: this.keyPair.keyType
                };
            }
            if (keyPair.privateKey.indexOf("0x") == 0) {
                this.keyPair = {
                    privateKey: this.keyPair.privateKey.substring(2),
                    publicKey: this.keyPair.publicKey,
                    keyType: this.keyPair.keyType
                };
            }
        }
    };
    DIDCommSuite.prototype.create = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyPairEd25519, publicKey;
            return __generator(this, function (_a) {
                keyPairEd25519 = (0, ed25519_1.generateKeyPair)();
                u8a.toString(keyPairEd25519.publicKey);
                publicKey = (0, ed25519_1.extractPublicKeyFromSecretKey)(keyPairEd25519.secretKey);
                return [2 /*return*/, {
                        privateKey: "0x".concat(u8a.toString(keyPairEd25519.secretKey, "base16")),
                        publicKey: "0x".concat(u8a.toString(keyPairEd25519.publicKey, "base16")),
                        keyType: "Ed25519",
                    }];
            });
        });
    };
    DIDCommSuite.prototype.pack = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var message;
            return __generator(this, function (_a) {
                params.toKeys.forEach(function (toKey) {
                    toKey.publicKeyHex = toKey.publicKeyHex.replace("0x", "");
                });
                switch (params.packing) {
                    case 'authcrypt': // intentionally omitting break
                    case 'anoncrypt':
                        return [2 /*return*/, this.packJWE(params)];
                    case 'none':
                        message = __assign(__assign({}, params.message), { typ: kms_core_1.DIDCommMessageMediaType.PLAIN });
                        return [2 /*return*/, { message: JSON.stringify(message) }];
                    case 'jws':
                        return [2 /*return*/, this.packJWS(params)];
                    default:
                        throw new Error("not_implemented: packing messages as ".concat(params.packing, " is not supported yet"));
                }
                return [2 /*return*/];
            });
        });
    };
    DIDCommSuite.prototype.packJWS = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var alg, headerObj, header, payload, signingInput, signature, packedMessage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.keyPair.keyType === 'Ed25519') {
                            alg = 'EdDSA';
                        }
                        else if (this.keyPair.keyType === 'Secp256k1') {
                            alg = 'ES256K';
                        }
                        else {
                            throw new Error("not_supported: key of type ".concat(this.keyPair.keyType, " is not supported for JWS didcomm message"));
                        }
                        headerObj = { alg: alg, kid: params.senderVerificationMethodId, typ: kms_core_1.DIDCommMessageMediaType.SIGNED };
                        header = this.encodeJoseBlob(headerObj);
                        payload = this.encodeJoseBlob(params.message);
                        signingInput = header + '.' + payload;
                        return [4 /*yield*/, this.keyManagerSign({
                                data: signingInput,
                                encoding: 'utf-8',
                                keyRef: params.senderVerificationMethodId,
                                algorithm: alg,
                            })];
                    case 1:
                        signature = _a.sent();
                        packedMessage = {
                            protected: header,
                            payload: payload,
                            signature: signature,
                        };
                        // serialize flattened JWS JSON and return
                        return [2 /*return*/, { message: JSON.stringify(packedMessage) }];
                }
            });
        });
    };
    DIDCommSuite.prototype.packJWE = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            function computeRecipients(receiptKeys) {
                return __awaiter(this, void 0, void 0, function () {
                    var tempRecipients;
                    return __generator(this, function (_a) {
                        tempRecipients = receiptKeys.map(function (pbk) { return ({
                            kid: pbk.verificationMethodId,
                            publicKeyBytes: u8a.fromString(pbk.toPublicKeyHex, "base16")
                        }); });
                        if (tempRecipients.length === 0) {
                            throw new Error("not_supported: no compatible key agreement keys found for recipient");
                        }
                        return [2 /*return*/, tempRecipients];
                    });
                });
            }
            var senderECDH, protectedHeader, recipients, _a, _b, _c, encrypters, messageBytes, jwe, message;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        senderECDH = null;
                        protectedHeader = {
                            typ: kms_core_1.DIDCommMessageMediaType.ENCRYPTED,
                        };
                        protectedHeader = __assign(__assign({}, protectedHeader), { skid: params.senderVerificationMethodId });
                        if (params.packing === 'authcrypt') {
                            senderECDH = this.createEcdhWrapper({
                                myKey: { privateKeyHex: this.keyPair.privateKey, type: this.keyPair.keyType },
                            });
                            protectedHeader = __assign(__assign({}, protectedHeader), { skid: params.senderVerificationMethodId });
                        }
                        recipients = [];
                        _b = 
                        // add primary recipient
                        (_a = recipients.push).apply;
                        _c = [
                            // add primary recipient
                            recipients];
                        return [4 /*yield*/, computeRecipients(params.toKeys.map(function (x) {
                                return ({
                                    toPublicKeyHex: x.publicKeyHex,
                                    verificationMethodId: x.verificationMethodId
                                });
                            }))];
                    case 1:
                        // add primary recipient
                        _b.apply(_a, _c.concat([(_d.sent())]));
                        encrypters = recipients
                            .map(function (recipient) {
                            if (params.packing === 'authcrypt') {
                                var signerpk = (0, bytes_1.arrayify)(_this.keyPair.privateKey, { allowMissingPrefix: true });
                                return (0, did_jwt_1.createAuthEncrypter)((0, ed25519_1.convertPublicKeyToX25519)(recipient.publicKeyBytes), (0, ed25519_1.convertSecretKeyToX25519)(signerpk), { kid: recipient.kid });
                            }
                            else {
                                return (0, did_jwt_1.createAnonEncrypter)((0, ed25519_1.convertPublicKeyToX25519)(recipient.publicKeyBytes), { kid: recipient.kid });
                            }
                        });
                        if (encrypters.length === 0) {
                            throw new Error("not_supported: could not create suitable encryption for recipients");
                        }
                        messageBytes = u8a.fromString(JSON.stringify(params.message), 'utf-8');
                        return [4 /*yield*/, (0, did_jwt_1.createJWE)(messageBytes, encrypters, protectedHeader)];
                    case 2:
                        jwe = _d.sent();
                        message = JSON.stringify(jwe);
                        return [2 /*return*/, { message: message }];
                }
            });
        });
    };
    DIDCommSuite.prototype.unpack = function (jwe) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, msgObj, mediaType;
            return __generator(this, function (_b) {
                _a = this.decodeMessageAndMediaType(jwe.message), msgObj = _a.msgObj, mediaType = _a.mediaType;
                if (mediaType === kms_core_1.DIDCommMessageMediaType.SIGNED) {
                    return [2 /*return*/, this.unpackJWS(msgObj)];
                }
                else if (mediaType === kms_core_1.DIDCommMessageMediaType.PLAIN) {
                    return [2 /*return*/, { message: msgObj, metaData: { packing: 'none' } }];
                }
                else if (mediaType === kms_core_1.DIDCommMessageMediaType.ENCRYPTED) {
                    return [2 /*return*/, this.unpackJWE(msgObj)];
                }
                else {
                    throw Error('not_supported: ' + mediaType);
                }
                return [2 /*return*/];
            });
        });
    };
    DIDCommSuite.prototype.unpackJWE = function (jwe) {
        return __awaiter(this, void 0, void 0, function () {
            var packing, decrypter, senderPbk, privateKeyBytes, senderKeyBytes, privateKeyBytes, decryptedBytes, decryptedMsg, message;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        packing = "";
                        return [4 /*yield*/, this.extractSenderEncryptionKey(jwe)];
                    case 1:
                        senderPbk = _a.sent();
                        if (senderPbk && jwe.recipients[0].header.alg.includes('ECDH-1PU')) {
                            privateKeyBytes = (0, bytes_1.arrayify)(this.keyPair.privateKey, { allowMissingPrefix: true });
                            senderKeyBytes = u8a.fromString(senderPbk.publicKeyHex.replace("0x", ""), "base16");
                            decrypter = (0, did_jwt_1.createAuthDecrypter)((0, ed25519_1.convertSecretKeyToX25519)(privateKeyBytes), (0, ed25519_1.convertPublicKeyToX25519)(senderKeyBytes));
                            packing = 'authcrypt';
                        }
                        else {
                            privateKeyBytes = (0, bytes_1.arrayify)(this.keyPair.privateKey, { allowMissingPrefix: true });
                            decrypter = (0, did_jwt_1.createAnonDecrypter)((0, ed25519_1.convertSecretKeyToX25519)(privateKeyBytes));
                            packing = 'anoncrypt';
                        }
                        return [4 /*yield*/, (0, did_jwt_1.decryptJWE)(jwe, decrypter)];
                    case 2:
                        decryptedBytes = _a.sent();
                        decryptedMsg = u8a.toString(decryptedBytes, 'utf-8');
                        message = JSON.parse(decryptedMsg);
                        return [2 /*return*/, { message: message, metaData: { packing: packing } }];
                }
            });
        });
    };
    DIDCommSuite.prototype.unpackJWS = function (jws) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var signatureEncoded, headerEncoded, message, header, sender, senderPbk, verifiedSenderKey;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        signatureEncoded = this.isDefined(jws.signature)
                            ? jws.signature
                            : (_a = jws.signatures[0]) === null || _a === void 0 ? void 0 : _a.signature;
                        headerEncoded = this.isDefined(jws.protected)
                            ? jws.protected
                            : (_b = jws.signatures[0]) === null || _b === void 0 ? void 0 : _b.protected;
                        if (!this.isDefined(headerEncoded) || !this.isDefined(signatureEncoded)) {
                            throw new Error('invalid_argument: could not interpret message as JWS');
                        }
                        message = this.decodeJoseBlob(jws.payload);
                        header = this.decodeJoseBlob(headerEncoded);
                        sender = this.parseDidUrl(header.kid);
                        return [4 /*yield*/, this.getPublicKeyByVerificationMethod(header.kid)];
                    case 1:
                        senderPbk = _c.sent();
                        verifiedSenderKey = (0, did_jwt_1.verifyJWS)("".concat(headerEncoded, ".").concat(jws.payload, ".").concat(signatureEncoded), {
                            controller: sender === null || sender === void 0 ? void 0 : sender.did,
                            id: header.kid,
                            type: senderPbk.publicKeyType,
                            publicKeyHex: senderPbk.publicKeyHex
                        });
                        if (this.isDefined(verifiedSenderKey)) {
                            return [2 /*return*/, { message: message, metaData: { packing: 'jws' } }];
                        }
                        else {
                            throw new Error('invalid_jws: sender `kid` could not be validated as the signer of the message');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    DIDCommSuite.prototype.encodeJoseBlob = function (payload) {
        return u8a.toString(u8a.fromString(JSON.stringify(payload), 'utf-8'), 'base64url');
    };
    DIDCommSuite.prototype.keyManagerSign = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, keyRef, data, algorithm, encoding, extras, dataBytes, preData, signer, signer;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = __assign({ encoding: 'utf-8' }, args), keyRef = _a.keyRef, data = _a.data, algorithm = _a.algorithm, encoding = _a.encoding, extras = __rest(_a, ["keyRef", "data", "algorithm", "encoding"]);
                        if (typeof data === 'string') {
                            if (encoding === 'base16' || encoding === 'hex') {
                                preData = data.startsWith('0x') ? data.substring(2) : data;
                                dataBytes = u8a.fromString(preData, 'base16');
                            }
                            else {
                                dataBytes = u8a.fromString(data, encoding);
                            }
                        }
                        else {
                            dataBytes = data;
                        }
                        if (!(this.keyPair.keyType === 'Ed25519' &&
                            (typeof algorithm === 'undefined' || ['Ed25519', 'EdDSA'].includes(algorithm)))) return [3 /*break*/, 2];
                        signer = (0, did_jwt_1.EdDSASigner)((0, bytes_1.arrayify)(this.keyPair.privateKey, { allowMissingPrefix: true }));
                        return [4 /*yield*/, signer(data)];
                    case 1: return [2 /*return*/, _b.sent()];
                    case 2:
                        if (!(this.keyPair.keyType === 'Secp256k1')) return [3 /*break*/, 4];
                        if (!(typeof algorithm === 'undefined' || ['ES256K', 'ES256K-R'].includes(algorithm))) return [3 /*break*/, 4];
                        signer = (0, did_jwt_1.ES256KSigner)((0, bytes_1.arrayify)(this.keyPair.privateKey, { allowMissingPrefix: true }), algorithm === 'ES256K-R');
                        return [4 /*yield*/, signer(data)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    DIDCommSuite.prototype.createEcdhWrapper = function (args) {
        var _this = this;
        return function (theirPublicKey) { return __awaiter(_this, void 0, void 0, function () {
            var publicKey, shared;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (theirPublicKey.length !== 32) {
                            throw new Error('invalid_argument: incorrect publicKey key length for X25519');
                        }
                        publicKey = { type: 'X25519', publicKeyHex: u8a.toString(theirPublicKey, 'base16') };
                        return [4 /*yield*/, this.sharedSecret({ myKey: args.myKey, theirKey: publicKey })];
                    case 1:
                        shared = _a.sent();
                        debugger;
                        return [2 /*return*/, u8a.fromString(shared, 'base16')];
                }
            });
        }); };
    };
    DIDCommSuite.prototype.sharedSecret = function (args) {
        var myKeyBytes = (0, bytes_1.arrayify)('0x' + args.myKey.privateKeyHex);
        if (args.myKey.type === 'Ed25519') {
            myKeyBytes = (0, ed25519_1.convertSecretKeyToX25519)(myKeyBytes);
        }
        else if (args.myKey.type !== 'X25519') {
            throw new Error("not_supported: can't compute shared secret for type=".concat(args.myKey.type));
        }
        var theirKeyBytes = (0, bytes_1.arrayify)('0x' + args.theirKey.publicKeyHex.replace("0x", ""));
        if (args.theirKey.type === 'Ed25519') {
            theirKeyBytes = (0, ed25519_1.convertPublicKeyToX25519)(theirKeyBytes);
        }
        else if (args.theirKey.type !== 'X25519') {
            throw new Error("not_supported: can't compute shared secret for type=".concat(args.theirKey.type));
        }
        var shared = (0, x25519_1.sharedKey)(myKeyBytes, theirKeyBytes);
        return (0, bytes_1.hexlify)(shared).substring(2);
    };
    DIDCommSuite.prototype.parseDidUrl = function (didUrl) {
        if (didUrl === '' || !didUrl)
            return null;
        var sections = didUrl.match(DID_MATCHER);
        if (sections) {
            var parts = {
                did: "did:".concat(sections[1], ":").concat(sections[2]),
                method: sections[1],
                id: sections[2],
                didUrl: didUrl,
            };
            if (sections[4]) {
                var params = sections[4].slice(1).split(';');
                parts.params = {};
                for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                    var p = params_1[_i];
                    var kv = p.split('=');
                    parts.params[kv[0]] = kv[1];
                }
            }
            if (sections[6])
                parts.path = sections[6];
            if (sections[7])
                parts.query = sections[7].slice(1);
            if (sections[8])
                parts.fragment = sections[8].slice(1);
            return parts;
        }
        return null;
    };
    DIDCommSuite.prototype.decodeJoseBlob = function (blob) {
        return JSON.parse(u8a.toString(u8a.fromString(blob, 'base64url'), 'utf-8'));
    };
    DIDCommSuite.prototype.isDefined = function (arg) {
        return arg !== null && typeof arg !== 'undefined';
    };
    DIDCommSuite.prototype.decodeMessageAndMediaType = function (message) {
        var msgObj;
        if (typeof message === 'string') {
            try {
                msgObj = JSON.parse(message);
            }
            catch (e) {
                throw new Error('invalid_argument: unable to parse message as JSON');
                // TODO: try to interpret as compact serialized JWS / JWM?
            }
        }
        else {
            msgObj = message;
        }
        var mediaType = null;
        if (msgObj.typ === kms_core_1.DIDCommMessageMediaType.PLAIN) {
            mediaType = kms_core_1.DIDCommMessageMediaType.PLAIN;
        }
        else if (msgObj.protected) {
            var protectedHeader = this.decodeJoseBlob(msgObj.protected);
            if (protectedHeader.typ === kms_core_1.DIDCommMessageMediaType.SIGNED) {
                mediaType = kms_core_1.DIDCommMessageMediaType.SIGNED;
            }
            else if (protectedHeader.typ === kms_core_1.DIDCommMessageMediaType.ENCRYPTED) {
                mediaType = kms_core_1.DIDCommMessageMediaType.ENCRYPTED;
            }
            else {
                throw new Error('invalid_argument: unable to determine message type');
            }
        }
        else if (msgObj.signatures) {
            mediaType = kms_core_1.DIDCommMessageMediaType.SIGNED;
        }
        else {
            throw new Error('invalid_argument: unable to determine message type');
        }
        return { msgObj: msgObj, mediaType: mediaType };
    };
    DIDCommSuite.prototype.getPublicKeyByVerificationMethod = function (vmId) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedDid, didDocument, vm;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parsedDid = this.parseDidUrl(vmId);
                        return [4 /*yield*/, this.didResolver(parsedDid.did)];
                    case 1:
                        didDocument = _a.sent();
                        vm = didDocument.verificationMethod.find(function (x) { return x.id.replace(parsedDid.did, "") == vmId.replace(parsedDid.did, ""); });
                        if (vm.publicKeyJwk) {
                            return [2 /*return*/, {
                                    publicKeyHex: kms_core_1.BaseConverter.convert(vm.publicKeyJwk, kms_core_1.Base.JWK, kms_core_1.Base.Hex),
                                    publicKeyType: vm.publicKeyJwk.crv
                                }];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    DIDCommSuite.prototype.extractSenderEncryptionKey = function (jwe) {
        return __awaiter(this, void 0, void 0, function () {
            var protectedHeader, senderDoc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        protectedHeader = this.decodeJoseBlob(jwe.protected);
                        if (!(typeof protectedHeader.skid === 'string')) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getPublicKeyByVerificationMethod(protectedHeader.skid)];
                    case 1:
                        senderDoc = _a.sent();
                        // const sKey = (await context.agent.getDIDComponentById({
                        //     didDocument: senderDoc,
                        //     didUrl: protectedHeader.skid,
                        //     section: 'keyAgreement',
                        // })) as _ExtendedVerificationMethod
                        // if (!['Ed25519VerificationKey2018', 'X25519KeyAgreementKey2019'].includes(sKey.type)) {
                        //     throw new Error(`not_supported: sender key of type ${sKey.type} is not supported`)
                        // }
                        // let publicKeyHex = this.et(sKey, true)
                        // senderKey = u8a.fromString(senderDoc.publicKeyHex, 'base16');
                        return [2 /*return*/, senderDoc];
                    case 2: return [2 /*return*/, null];
                }
            });
        });
    };
    DIDCommSuite = __decorate([
        (0, kms_core_1.suiteDecorator)(kms_core_1.Suite.DIDCommV2),
        __metadata("design:paramtypes", [Function])
    ], DIDCommSuite);
    return DIDCommSuite;
}());
exports.DIDCommSuite = DIDCommSuite;
//# sourceMappingURL=did-comm-suite.js.map
import { arrayify, hexlify } from "@ethersproject/bytes";
import { IDidCommKeyPair, IDIDCommV2Suite, Suite, suiteDecorator, DIDCommMessageMediaType, DIDCommMessagePacking, IPackedDIDCommMessage, _DIDCommPlainMessage, _DIDCommEncryptedMessage, BaseConverter, Base, } from "@extrimian/kms-core";
// import { crypto_sign_keypair, sodium.from_hex } from 'wrappers';
const _sodium = require("libsodium-wrappers");
import {
    JWE,
    Decrypter,
    createJWE,
    createJWS,
    EdDSASigner,
    ES256KSigner,
    ECDH,
    Encrypter,
    createAuthEncrypter,
    createAnonEncrypter,
    createAuthDecrypter,
    createAnonDecrypter,
    decryptJWE,
    verifyJWS
} from "did-jwt";
import * as u8a from 'uint8arrays'
import { IKeyManagerSignArgs } from "../models/key-manager-sign-args";
import {
    generateKeyPair as generateSigningKeyPair,
    convertPublicKeyToX25519,
    convertSecretKeyToX25519,
    extractPublicKeyFromSecretKey,
} from '@stablelib/ed25519'

import {
    generateKeyPair as generateEncryptionKeypair,
    generateKeyPairFromSeed as generateEncryptionKeyPairFromSeed,
    sharedKey,
} from '@stablelib/x25519';
import { ParsedDID } from "../models/parsed-did";
import { IDIDCommMessage, IUnpackedDIDCommMessage } from "../models/didcomm-message-media-type";
import { _DIDCommSignedMessage, _FlattenedJWS, _GenericJWS } from "../models/didcomm-signed-message";
import { DIDDocument, VerificationMethodJwk } from "@extrimian/did-core";

const PCT_ENCODED = '(?:%[0-9a-fA-F]{2})'
const ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`
const METHOD = '([a-z0-9]+)'
const METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`
const PARAM_CHAR = '[a-zA-Z0-9_.:%-]'
const PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`
const PARAMS = `((${PARAM})*)`
const PATH = `(/[^#?]*)?`
const QUERY = `([?][^#]*)?`
const FRAGMENT = `(#.*)?`
const DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`)

@suiteDecorator(Suite.DIDCommV2)
export class DIDCommSuite implements IDIDCommV2Suite {
    keyPair: IDidCommKeyPair;

    constructor(private didResolver?: (did: string) => Promise<DIDDocument>) {

    }

    load(keyPair?: IDidCommKeyPair) {
        this.keyPair = keyPair;
        if (keyPair) {
            if (keyPair.publicKey.indexOf("0x") == 0) {
                this.keyPair = {
                    privateKey: this.keyPair.privateKey,
                    publicKey: this.keyPair.publicKey.substring(2),
                    keyType: this.keyPair.keyType
                }
            }
            if (keyPair.privateKey.indexOf("0x") == 0) {
                this.keyPair = {
                    privateKey: this.keyPair.privateKey.substring(2),
                    publicKey: this.keyPair.publicKey,
                    keyType: this.keyPair.keyType
                }
            }
        }
    }

    async create(): Promise<IDidCommKeyPair> {
        const keyPairEd25519 = generateSigningKeyPair()
        u8a.toString(keyPairEd25519.publicKey);

        const publicKey = extractPublicKeyFromSecretKey(keyPairEd25519.secretKey);

        return {
            privateKey: `0x${u8a.toString(keyPairEd25519.secretKey, "base16")}`,
            publicKey: `0x${u8a.toString(keyPairEd25519.publicKey, "base16")}`,
            keyType: "Ed25519",
        };
    }

    async pack(params: {
        senderVerificationMethodId: string,
        toKeys: {
            verificationMethodId: string;
            publicKeyHex: string;
        }[],
        message: IDIDCommMessage;
        packing: DIDCommMessagePacking;
    }): Promise<IPackedDIDCommMessage> {
        params.toKeys.forEach(toKey => {
            toKey.publicKeyHex = toKey.publicKeyHex.replace("0x", "");
        });

        switch (params.packing) {
            case 'authcrypt': // intentionally omitting break
            case 'anoncrypt':
                return this.packJWE(params);
            case 'none':
                const message = {
                    ...params.message,
                    typ: DIDCommMessageMediaType.PLAIN,
                }
                return { message: JSON.stringify(message) }
            case 'jws':
                return this.packJWS(params)
            default:
                throw new Error(`not_implemented: packing messages as ${params.packing} is not supported yet`)
        }
    }

    async packJWS(params: {
        senderVerificationMethodId: string,
        toKeys: {
            verificationMethodId: string;
            publicKeyHex: string;
        }[],
        message: IDIDCommMessage;
        packing: DIDCommMessagePacking;
    }): Promise<IPackedDIDCommMessage> {

        let alg: string;

        if (this.keyPair.keyType === 'Ed25519') {
            alg = 'EdDSA'
        } else if (this.keyPair.keyType === 'Secp256k1') {
            alg = 'ES256K'
        } else {
            throw new Error(
                `not_supported: key of type ${this.keyPair.keyType} is not supported for JWS didcomm message`,
            )
        }

        // construct the protected header with alg, typ and kid
        const headerObj = { alg, kid: params.senderVerificationMethodId, typ: DIDCommMessageMediaType.SIGNED };
        const header = this.encodeJoseBlob(headerObj);
        const payload = this.encodeJoseBlob(params.message);

        const signingInput = header + '.' + payload

        const signature: string = await this.keyManagerSign({
            data: signingInput,
            encoding: 'utf-8',
            keyRef: params.senderVerificationMethodId,
            algorithm: alg,
        });

        // create flattened JWS
        const packedMessage = {
            protected: header,
            payload,
            signature,
        }
        // serialize flattened JWS JSON and return
        return { message: JSON.stringify(packedMessage) }
    }

    private async packJWE(params: {
        senderVerificationMethodId: string,
        toKeys: {
            verificationMethodId: string;
            publicKeyHex: string;
        }[],
        message: IDIDCommMessage;
        packing: DIDCommMessagePacking;
    }): Promise<IPackedDIDCommMessage> {
        let senderECDH: ECDH | null = null
        let protectedHeader: {
            skid?: string
            typ: string
        } = {
            typ: DIDCommMessageMediaType.ENCRYPTED,
        }

        protectedHeader = { ...protectedHeader, skid: params.senderVerificationMethodId }

        if (params.packing === 'authcrypt') {
            senderECDH = this.createEcdhWrapper({
                myKey: { privateKeyHex: this.keyPair.privateKey, type: this.keyPair.keyType },
            });
            protectedHeader = { ...protectedHeader, skid: params.senderVerificationMethodId }
        }

        // 2: compute recipients
        interface IRecipient {
            kid: string
            publicKeyBytes: Uint8Array
        }

        let recipients: IRecipient[] = []

        async function computeRecipients(receiptKeys: {
            verificationMethodId: string,
            toPublicKeyHex: string
        }[]): Promise<IRecipient[]> {
            const tempRecipients = receiptKeys.map((pbk) => ({
                kid: pbk.verificationMethodId,
                publicKeyBytes: u8a.fromString(pbk.toPublicKeyHex, "base16")
            }));

            if (tempRecipients.length === 0) {
                throw new Error(`not_supported: no compatible key agreement keys found for recipient`)
            }

            return tempRecipients
        }

        // add primary recipient
        recipients.push(...(await computeRecipients(params.toKeys.map(x =>
        ({
            toPublicKeyHex: x.publicKeyHex,
            verificationMethodId: x.verificationMethodId
        })))));

        // add bcc recipients (optional)
        // for (const to of args.options?.bcc || []) {
        //     recipients.push(...(await computeRecipients(to)))
        // }


        // 3. create Encrypter for each recipient
        const encrypters: Encrypter[] = recipients
            .map((recipient) => {
                if (params.packing === 'authcrypt') {
                    const signerpk = arrayify(this.keyPair.privateKey, { allowMissingPrefix: true });
                    return createAuthEncrypter(convertPublicKeyToX25519(recipient.publicKeyBytes), convertSecretKeyToX25519(signerpk), { kid: recipient.kid })
                } else {
                    return createAnonEncrypter(convertPublicKeyToX25519(recipient.publicKeyBytes), { kid: recipient.kid })
                }
            });

        if (encrypters.length === 0) {
            throw new Error(
                `not_supported: could not create suitable encryption for recipients`,
            )
        }

        // 4. createJWE
        const messageBytes = u8a.fromString(JSON.stringify(params.message), 'utf-8')
        const jwe = await createJWE(messageBytes, encrypters, protectedHeader)
        const message = JSON.stringify(jwe)

        return { message }
    }

    async unpack(
        jwe: any
    ) {
        const { msgObj, mediaType } = this.decodeMessageAndMediaType(jwe.message)
        if (mediaType === DIDCommMessageMediaType.SIGNED) {
            return this.unpackJWS(msgObj as _DIDCommSignedMessage)
        } else if (mediaType === DIDCommMessageMediaType.PLAIN) {
            return { message: <IDIDCommMessage>msgObj, metaData: { packing: 'none' } }
        } else if (mediaType === DIDCommMessageMediaType.ENCRYPTED) {
            return this.unpackJWE(msgObj as _DIDCommSignedMessage)
        } else {
            throw Error('not_supported: ' + mediaType)
        }
    }

    private async unpackJWE(
        jwe: any
    ): Promise<any> {
        let packing = "";

        let decrypter: Decrypter;

        const senderPbk = await this.extractSenderEncryptionKey(jwe);

        if (senderPbk && jwe.recipients[0].header.alg.includes('ECDH-1PU')) {
            const privateKeyBytes = arrayify(this.keyPair.privateKey, { allowMissingPrefix: true });
            const senderKeyBytes = u8a.fromString(senderPbk.publicKeyHex.replace("0x", ""), "base16");
            decrypter = createAuthDecrypter(convertSecretKeyToX25519(privateKeyBytes), convertPublicKeyToX25519(senderKeyBytes))
            packing = 'authcrypt'
        } else {
            const privateKeyBytes = arrayify(this.keyPair.privateKey, { allowMissingPrefix: true });
            decrypter = createAnonDecrypter(convertSecretKeyToX25519(privateKeyBytes));
            packing = 'anoncrypt';
        }

        const decryptedBytes = await decryptJWE(jwe, decrypter)
        const decryptedMsg = u8a.toString(decryptedBytes, 'utf-8')
        const message = JSON.parse(decryptedMsg)
        return { message, metaData: { packing } } as any;
    }

    private async unpackJWS(
        jws: _DIDCommSignedMessage,
    ): Promise<IUnpackedDIDCommMessage> {
        // TODO: currently only supporting one signature
        const signatureEncoded: string = this.isDefined((<_FlattenedJWS>jws).signature)
            ? (<_FlattenedJWS>jws).signature
            : (<_GenericJWS>jws).signatures[0]?.signature
        const headerEncoded = this.isDefined((<_FlattenedJWS>jws).protected)
            ? (<_FlattenedJWS>jws).protected
            : (<_GenericJWS>jws).signatures[0]?.protected
        if (!this.isDefined(headerEncoded) || !this.isDefined(signatureEncoded)) {
            throw new Error('invalid_argument: could not interpret message as JWS')
        }
        const message = <IDIDCommMessage>this.decodeJoseBlob(jws.payload)
        const header = this.decodeJoseBlob(headerEncoded)
        const sender = this.parseDidUrl(header.kid);
        // if (!this.isDefined(sender) || sender?.id !== message.from) {
        //     throw new Error('invalid_jws: sender is not a DID or does not match the `kid`')
        // }

        const senderPbk = await this.getPublicKeyByVerificationMethod(header.kid);

        const verifiedSenderKey = verifyJWS(`${headerEncoded}.${jws.payload}.${signatureEncoded}`, {
            controller: sender?.did,
            id: header.kid,
            type: senderPbk.publicKeyType,
            publicKeyHex: senderPbk.publicKeyHex
        });

        if (this.isDefined(verifiedSenderKey)) {
            return { message, metaData: { packing: 'jws' } }
        } else {
            throw new Error('invalid_jws: sender `kid` could not be validated as the signer of the message')
        }
    }

    private encodeJoseBlob(payload: {}) {
        return u8a.toString(u8a.fromString(JSON.stringify(payload), 'utf-8'), 'base64url')
    }

    async keyManagerSign(args: IKeyManagerSignArgs): Promise<string> {
        const { keyRef, data, algorithm, encoding, ...extras } = { encoding: 'utf-8', ...args }


        let dataBytes
        if (typeof data === 'string') {
            if (encoding === 'base16' || encoding === 'hex') {
                const preData = data.startsWith('0x') ? data.substring(2) : data
                dataBytes = u8a.fromString(preData, 'base16')
            } else {
                dataBytes = u8a.fromString(data, <'utf-8'>encoding)
            }
        } else {
            dataBytes = data
        }

        if (
            this.keyPair.keyType === 'Ed25519' &&
            (typeof algorithm === 'undefined' || ['Ed25519', 'EdDSA'].includes(algorithm))
        ) {
            const signer = EdDSASigner(arrayify(this.keyPair.privateKey, { allowMissingPrefix: true }));
            return await signer(data) as string;
        } else if (this.keyPair.keyType === 'Secp256k1') {
            if (typeof algorithm === 'undefined' || ['ES256K', 'ES256K-R'].includes(algorithm)) {
                const signer = ES256KSigner(arrayify(this.keyPair.privateKey, { allowMissingPrefix: true }), algorithm === 'ES256K-R')
                return await signer(data) as string;
            }
        }
    }

    private createEcdhWrapper(args: {
        myKey: {
            privateKeyHex: string,
            type: string,
        }
    }): ECDH {
        return async (theirPublicKey: Uint8Array): Promise<Uint8Array> => {
            if (theirPublicKey.length !== 32) {
                throw new Error('invalid_argument: incorrect publicKey key length for X25519')
            }
            const publicKey = { type: 'X25519', publicKeyHex: u8a.toString(theirPublicKey, 'base16') }
            const shared = await this.sharedSecret({ myKey: args.myKey, theirKey: publicKey });
            debugger;
            return u8a.fromString(shared, 'base16')
        }
    }

    private sharedSecret(args: {
        myKey: {
            privateKeyHex: string,
            type: string,
        },
        theirKey: {
            publicKeyHex: string,
            type: string,
        }
    }) {
        let myKeyBytes = arrayify('0x' + args.myKey.privateKeyHex)
        if (args.myKey.type === 'Ed25519') {
            myKeyBytes = convertSecretKeyToX25519(myKeyBytes)
        } else if (args.myKey.type !== 'X25519') {
            throw new Error(`not_supported: can't compute shared secret for type=${args.myKey.type}`)
        }
        let theirKeyBytes = arrayify('0x' + args.theirKey.publicKeyHex.replace("0x", ""))
        if (args.theirKey.type === 'Ed25519') {
            theirKeyBytes = convertPublicKeyToX25519(theirKeyBytes)
        } else if (args.theirKey.type !== 'X25519') {
            throw new Error(`not_supported: can't compute shared secret for type=${args.theirKey.type}`)
        }
        const shared = sharedKey(myKeyBytes, theirKeyBytes)
        return hexlify(shared).substring(2)
    }


    parseDidUrl(didUrl: string): ParsedDID | null {
        if (didUrl === '' || !didUrl) return null
        const sections = didUrl.match(DID_MATCHER)
        if (sections) {
            const parts: ParsedDID = {
                did: `did:${sections[1]}:${sections[2]}`,
                method: sections[1],
                id: sections[2],
                didUrl,
            }
            if (sections[4]) {
                const params = sections[4].slice(1).split(';')
                parts.params = {}
                for (const p of params) {
                    const kv = p.split('=')
                    parts.params[kv[0]] = kv[1]
                }
            }
            if (sections[6]) parts.path = sections[6]
            if (sections[7]) parts.query = sections[7].slice(1)
            if (sections[8]) parts.fragment = sections[8].slice(1)
            return parts
        }
        return null
    }

    decodeJoseBlob(blob: string) {
        return JSON.parse(u8a.toString(u8a.fromString(blob, 'base64url'), 'utf-8'))
    }

    isDefined<T>(arg: T): arg is Exclude<T, null | undefined> {
        return arg !== null && typeof arg !== 'undefined'
    }

    private decodeMessageAndMediaType(message: string): {
        msgObj: _DIDCommPlainMessage | _DIDCommSignedMessage | _DIDCommEncryptedMessage
        mediaType: DIDCommMessageMediaType
    } {
        let msgObj
        if (typeof message === 'string') {
            try {
                msgObj = JSON.parse(message)
            } catch (e) {
                throw new Error('invalid_argument: unable to parse message as JSON')
                // TODO: try to interpret as compact serialized JWS / JWM?
            }
        } else {
            msgObj = message
        }
        let mediaType: DIDCommMessageMediaType | null = null
        if ((<_DIDCommPlainMessage>msgObj).typ === DIDCommMessageMediaType.PLAIN) {
            mediaType = DIDCommMessageMediaType.PLAIN
        } else if ((<_FlattenedJWS | _DIDCommEncryptedMessage>msgObj).protected) {
            const protectedHeader = this.decodeJoseBlob(msgObj.protected)
            if (protectedHeader.typ === DIDCommMessageMediaType.SIGNED) {
                mediaType = DIDCommMessageMediaType.SIGNED
            } else if (protectedHeader.typ === DIDCommMessageMediaType.ENCRYPTED) {
                mediaType = DIDCommMessageMediaType.ENCRYPTED
            } else {
                throw new Error('invalid_argument: unable to determine message type')
            }
        } else if ((<_GenericJWS>msgObj).signatures) {
            mediaType = DIDCommMessageMediaType.SIGNED
        } else {
            throw new Error('invalid_argument: unable to determine message type')
        }
        return { msgObj, mediaType }
    }

    private async getPublicKeyByVerificationMethod(vmId: string): Promise<{
        publicKeyHex: string,
        publicKeyType: string,
    }> {
        const parsedDid = this.parseDidUrl(vmId);
        const didDocument = await this.didResolver(parsedDid.did);

        const vm = didDocument.verificationMethod.find(x => x.id.replace(parsedDid.did, "") == vmId.replace(parsedDid.did, ""));

        if ((<VerificationMethodJwk>vm).publicKeyJwk) {
            return {
                publicKeyHex: BaseConverter.convert((<VerificationMethodJwk>vm).publicKeyJwk, Base.JWK, Base.Hex),
                publicKeyType: (<VerificationMethodJwk>vm).publicKeyJwk.crv
            }
        }
    }

    async extractSenderEncryptionKey(
        jwe: JWE,
        // context: IAgentContext<IResolver>,
    ): Promise<{ publicKeyHex: string, publicKeyType: string }> {
        // let senderKey: Uint8Array | null = null
        const protectedHeader = this.decodeJoseBlob(jwe.protected)
        if (typeof protectedHeader.skid === 'string') {
            const senderDoc = await this.getPublicKeyByVerificationMethod(protectedHeader.skid);
            // const sKey = (await context.agent.getDIDComponentById({
            //     didDocument: senderDoc,
            //     didUrl: protectedHeader.skid,
            //     section: 'keyAgreement',
            // })) as _ExtendedVerificationMethod

            // if (!['Ed25519VerificationKey2018', 'X25519KeyAgreementKey2019'].includes(sKey.type)) {
            //     throw new Error(`not_supported: sender key of type ${sKey.type} is not supported`)
            // }
            // let publicKeyHex = this.et(sKey, true)
            // senderKey = u8a.fromString(senderDoc.publicKeyHex, 'base16');
            return senderDoc;
        }
        return null;
    }
}
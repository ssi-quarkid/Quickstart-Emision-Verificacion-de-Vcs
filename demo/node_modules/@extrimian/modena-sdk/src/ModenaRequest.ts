import * as URI from 'uri-js';
import ErrorCode from './ErrorCode';
import ISigner from './interfaces/ISigner';
import InputValidator from './InputValidator';
import ModenaError from './ModenaError';
import ModenaSdkConfig from './ModenaSdkConfig';
import JsonCanonicalizer from './JsonCanonicalizer';
import JwkEs256k from './models/JwkEs256k';
import Multihash from './Multihash';
import OperationKeyType from './enums/OperationKeyType';
import OperationType from './enums/OperationType';
import PatchAction from './enums/PatchAction';
import ModenaCreateRequestModel from './models/ModenaCreateRequestModel';
import ModenaDocumentModel from './models/ModenaDocumentModel';
import ModenaRecoverRequestModel from './models/ModenaRecoverRequestModel';
import ModenaUpdateRequestModel from './models/ModenaUpdateRequestModel';
import ModenaServiceModel from './models/ModenaServiceModel';
import ModenaPublicKeyModel from './models/ModenaPublicKeyModel';
import ModenaDeactivateRequestModel from './models/ModenaDeactivateRequestModel';
import { IJWK } from '@extrimian/kms-core';
import { DIDDocumentMetadata } from './models/DidDocumentMetadata';
import { UpdateCommitmentUtils } from './utils/UpdateCommitmentUtils';

/**
 * Class containing operations related to Modena requests.
 */
export default class ModenaRequest {
  /**
   * Creates an Modena DID create request.
   * @param input.document The initial state to be associate with the Modena DID to be created using a `replace` document patch action.
   */
  public static createCreateRequest(input: {
    recoveryKeys: IJWK[];
    updateKeys: IJWK[];
    document: ModenaDocumentModel;
  }): ModenaCreateRequestModel {
    const recoveryKeys = input.recoveryKeys;
    const updateKeys = input.updateKeys;
    const didDocumentKeys = input.document.publicKeys;
    const services = input.document.services;

    // Validate recovery and update public keys.
    recoveryKeys.forEach(recoveryKey => {
      InputValidator.validateEs256kOperationKey(recoveryKey, OperationKeyType.Public);
    });

    updateKeys.forEach(updateKey => {
      InputValidator.validateEs256kOperationKey(updateKey, OperationKeyType.Public);
    });

    // Validate all given DID Document keys.
    ModenaRequest.validateDidDocumentKeys(didDocumentKeys);

    // Validate all given service.
    ModenaRequest.validateServices(services);

    const hashAlgorithmInMultihashCode = ModenaSdkConfig.hashAlgorithmInMultihashCode;

    const patches = [{
      action: PatchAction.Replace,
      document: input.document
    }];

    const delta = {
      updateCommitment: updateKeys.map(x => Multihash.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode)),
      patches
    };

    ModenaRequest.validateDeltaSize(delta);

    const deltaHash = Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);

    const suffixData = {
      deltaHash,
      recoveryCommitment: recoveryKeys.map(recoveryKey => Multihash.canonicalizeThenDoubleHashThenEncode(recoveryKey, hashAlgorithmInMultihashCode))
    };

    const operationRequest = {
      type: OperationType.Create,
      suffixData: suffixData,
      delta: delta
    };

    return operationRequest;
  }

  public static async createDeactivateRequest(input: {
    didSuffix: string,
    recoveryPublicKey: JwkEs256k,
    signer: ISigner
  }): Promise<ModenaDeactivateRequestModel> {
    // Validate DID suffix
    ModenaRequest.validateDidSuffix(input.didSuffix);

    // Validates recovery public key
    InputValidator.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType.Public);

    const hashAlgorithmInMultihashCode = ModenaSdkConfig.hashAlgorithmInMultihashCode;
    const revealValue = Multihash.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);

    const dataToBeSigned = {
      didSuffix: input.didSuffix,
      recoveryKey: input.recoveryPublicKey
    };

    const compactJws = await input.signer.sign({ alg: 'ES256K' }, dataToBeSigned);

    return {
      type: OperationType.Deactivate,
      didSuffix: input.didSuffix,
      revealValue: revealValue,
      signedData: compactJws
    };
  }

  public static async createRecoverRequest(input: {
    didSuffix: string,
    recoveryPublicKey: JwkEs256k,
    nextRecoveryPublicKeys: JwkEs256k[],
    nextUpdatePublicKeys: JwkEs256k[],
    document: ModenaDocumentModel,
    signer: ISigner
  }): Promise<ModenaRecoverRequestModel> {
    // Validate DID suffix
    ModenaRequest.validateDidSuffix(input.didSuffix);

    // Validate recovery public key
    InputValidator.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType.Public);

    // Validate next recovery public key
    input.nextRecoveryPublicKeys.forEach(nextRecoveryPublicKey => InputValidator.validateEs256kOperationKey(nextRecoveryPublicKey, OperationKeyType.Public));

    // Validate next update public key
    input.nextUpdatePublicKeys.forEach(nextUpdatePublicKey => InputValidator.validateEs256kOperationKey(nextUpdatePublicKey, OperationKeyType.Public));

    // Validate all given DID Document keys.
    ModenaRequest.validateDidDocumentKeys(input.document.publicKeys);

    // Validate all given service.
    ModenaRequest.validateServices(input.document.services);

    const hashAlgorithmInMultihashCode = ModenaSdkConfig.hashAlgorithmInMultihashCode;
    const revealValue = Multihash.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);

    const patches = [{
      action: PatchAction.Replace,
      document: input.document
    }];

    const nextUpdateCommitmentHash = input.nextUpdatePublicKeys.map(x => Multihash.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode));

    const delta = {
      patches,
      updateCommitment: nextUpdateCommitmentHash
    };

    const deltaHash = Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
    const nextRecoveryCommitmentHash = input.nextRecoveryPublicKeys.map(x => Multihash.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode));

    const dataToBeSigned = {
      recoveryCommitment: nextRecoveryCommitmentHash,
      recoveryKey: input.recoveryPublicKey,
      deltaHash: deltaHash
    };

    const compactJws = await input.signer.sign({ alg: 'ES256K' }, dataToBeSigned);

    return {
      type: OperationType.Recover,
      didSuffix: input.didSuffix,
      revealValue: revealValue,
      delta: delta,
      signedData: compactJws
    };
  }


  public static async createUpdateRequest(input: {
    didSuffix: string;
    updatePublicKey: JwkEs256k;
    documentMetadata: DIDDocumentMetadata,
    nextUpdatePublicKeys: IJWK[],
    updateKeysToRemove?: {
      publicKeys?: IJWK[],
      updateCommitment?: string[]
    };
    signer: ISigner;
    servicesToAdd?: ModenaServiceModel[];
    idsOfServicesToRemove?: string[];
    publicKeysToAdd?: ModenaPublicKeyModel[];
    idsOfPublicKeysToRemove?: string[];
  }): Promise<ModenaUpdateRequestModel> {
    // Validate DID suffix
    ModenaRequest.validateDidSuffix(input.didSuffix);

    // Validate update public key
    InputValidator.validateEs256kOperationKey(input.updatePublicKey, OperationKeyType.Public);

    // Validate next update public key
    input.nextUpdatePublicKeys.forEach(x => InputValidator.validateEs256kOperationKey(x, OperationKeyType.Public));

    // Validate all given service.
    ModenaRequest.validateServices(input.servicesToAdd);

    // Validate all given DID Document keys.
    ModenaRequest.validateDidDocumentKeys(input.publicKeysToAdd);

    // Validate all given service id to remove.
    if (input.idsOfServicesToRemove !== undefined) {
      for (const id of input.idsOfServicesToRemove) {
        InputValidator.validateId(id);
      }
    }

    // Validate all given public key id to remove.
    if (input.idsOfPublicKeysToRemove !== undefined) {
      for (const id of input.idsOfPublicKeysToRemove) {
        InputValidator.validateId(id);
      }
    }

    const patches = [];
    // Create patches for add services
    const servicesToAdd = input.servicesToAdd;
    if (servicesToAdd !== undefined && servicesToAdd.length > 0) {
      const patch = {
        action: PatchAction.AddServices,
        services: servicesToAdd
      };

      patches.push(patch);
    }

    // Create patches for remove services
    const idsOfServicesToRemove = input.idsOfServicesToRemove;
    if (idsOfServicesToRemove !== undefined && idsOfServicesToRemove.length > 0) {
      const patch = {
        action: PatchAction.RemoveServices,
        ids: idsOfServicesToRemove
      };

      patches.push(patch);
    }

    // Create patches for adding public keys
    const publicKeysToAdd = input.publicKeysToAdd;
    if (publicKeysToAdd !== undefined && publicKeysToAdd.length > 0) {
      const patch = {
        action: PatchAction.AddPublicKeys,
        publicKeys: publicKeysToAdd
      };

      patches.push(patch);
    }

    // Create patch for removing public keys
    const idsOfPublicKeysToRemove = input.idsOfPublicKeysToRemove;
    if (idsOfPublicKeysToRemove !== undefined && idsOfPublicKeysToRemove.length > 0) {
      const patch = {
        action: PatchAction.RemovePublicKeys,
        ids: idsOfPublicKeysToRemove
      };

      patches.push(patch);
    }

    const hashAlgorithmInMultihashCode = ModenaSdkConfig.hashAlgorithmInMultihashCode;
    const revealValue = Multihash.canonicalizeThenHashThenEncode(input.updatePublicKey, hashAlgorithmInMultihashCode);

    const ucIndex = input.documentMetadata.method.updateCommitment.findIndex(x => x == UpdateCommitmentUtils.getUpdateCommitmentHash(input.updatePublicKey));
    input.documentMetadata.method.updateCommitment.splice(ucIndex, 1);

    if (input.updateKeysToRemove?.publicKeys) {
      for (let key of input.updateKeysToRemove?.publicKeys) {
        const ucIndex = input.documentMetadata.method.updateCommitment.findIndex(x => x == UpdateCommitmentUtils.getUpdateCommitmentHash(key));
        input.documentMetadata.method.updateCommitment.splice(ucIndex, 1);
      }
    }

    if (input.updateKeysToRemove?.updateCommitment) {
      for (let key of input.updateKeysToRemove?.updateCommitment) {
        const ucIndex = input.documentMetadata.method.updateCommitment.findIndex(x => x == key);
        input.documentMetadata.method.updateCommitment.splice(ucIndex, 1);
      }
    }

    const nextUpdateCommitmentHash = input.nextUpdatePublicKeys.map(x => Multihash.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode));
    
    const delta = {
      patches,
      updateCommitment: [...input.documentMetadata.method.updateCommitment, ...nextUpdateCommitmentHash]
    };
    
    const deltaHash = Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);

    const dataToBeSigned = {
      updateKey: input.updatePublicKey,
      deltaHash: deltaHash
    };

    const compactJws = await input.signer.sign({ alg: 'ES256K' }, dataToBeSigned);

    return {
      type: OperationType.Update,
      didSuffix: input.didSuffix,
      revealValue,
      delta,
      signedData: compactJws
    };
  }

  private static validateDidSuffix(didSuffix: string) {
    Multihash.validateEncodedHashComputedUsingSupportedHashAlgorithm(didSuffix, 'didSuffix');
  }

  private static validateDidDocumentKeys(publicKeys?: ModenaPublicKeyModel[]) {
    if (publicKeys === undefined) {
      return;
    }

    // Validate each public key.
    const publicKeyIdSet: Set<string> = new Set();
    for (const publicKey of publicKeys) {
      if (Array.isArray(publicKey.publicKeyJwk)) {
        throw new ModenaError(ErrorCode.DidDocumentPublicKeyMissingOrIncorrectType, `DID Document key 'publicKeyJwk' property is not a non-array object.`);
      }

      InputValidator.validateId(publicKey.id);

      // 'id' must be unique across all given keys.
      if (publicKeyIdSet.has(publicKey.id)) {
        throw new ModenaError(ErrorCode.DidDocumentPublicKeyIdDuplicated, `DID Document key with ID '${publicKey.id}' already exists.`);
      }
      publicKeyIdSet.add(publicKey.id);

      InputValidator.validatePublicKeyPurposes(publicKey.purposes);
    }
  }

  private static validateServices(services?: ModenaServiceModel[]) {
    if (services !== undefined && services.length !== 0) {
      const serviceIdSet: Set<string> = new Set();
      for (const service of services) {
        ModenaRequest.validateService(service);
        if (serviceIdSet.has(service.id)) {
          throw new ModenaError(ErrorCode.DidDocumentServiceIdDuplicated, 'Service id has to be unique');
        }
        serviceIdSet.add(service.id);
      }
    }
  }

  private static validateService(service: ModenaServiceModel) {
    InputValidator.validateId(service.id);

    const maxTypeLength = 30;
    if (service.type.length > maxTypeLength) {
      const errorMessage = `Service endpoint type length ${service.type.length} exceeds max allowed length of ${maxTypeLength}.`;
      throw new ModenaError(ErrorCode.ServiceTypeTooLong, errorMessage);
    }

    // Throw error if `serviceEndpoint` is an array.
    if (Array.isArray(service.serviceEndpoint)) {
      const errorMessage = 'Service endpoint value cannot be an array.';
      throw new ModenaError(ErrorCode.ServiceEndpointCannotBeAnArray, errorMessage);
    }

    if (typeof service.serviceEndpoint === 'string') {
      const uri = URI.parse(service.serviceEndpoint);
      if (uri.error !== undefined) {
        throw new ModenaError(ErrorCode.ServiceEndpointStringNotValidUri, `Service endpoint string '${service.serviceEndpoint}' is not a URI.`);
      }
    }
  }

  private static validateDeltaSize(delta: object) {
    const deltaBuffer = JsonCanonicalizer.canonicalizeAsBuffer(delta);
    if (deltaBuffer.length > ModenaSdkConfig.maxCanonicalizedDeltaSizeInBytes) {
      const errorMessage = `Delta of ${deltaBuffer.length} bytes exceeded limit of ${ModenaSdkConfig.maxCanonicalizedDeltaSizeInBytes} bytes.`;
      throw new ModenaError(ErrorCode.DeltaExceedsMaximumSize, errorMessage);
    }
  }
}

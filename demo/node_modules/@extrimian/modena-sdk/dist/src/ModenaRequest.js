"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const URI = require("uri-js");
const ErrorCode_1 = require("./ErrorCode");
const InputValidator_1 = require("./InputValidator");
const ModenaError_1 = require("./ModenaError");
const ModenaSdkConfig_1 = require("./ModenaSdkConfig");
const JsonCanonicalizer_1 = require("./JsonCanonicalizer");
const Multihash_1 = require("./Multihash");
const OperationKeyType_1 = require("./enums/OperationKeyType");
const OperationType_1 = require("./enums/OperationType");
const PatchAction_1 = require("./enums/PatchAction");
const UpdateCommitmentUtils_1 = require("./utils/UpdateCommitmentUtils");
/**
 * Class containing operations related to Modena requests.
 */
class ModenaRequest {
    /**
     * Creates an Modena DID create request.
     * @param input.document The initial state to be associate with the Modena DID to be created using a `replace` document patch action.
     */
    static createCreateRequest(input) {
        const recoveryKeys = input.recoveryKeys;
        const updateKeys = input.updateKeys;
        const didDocumentKeys = input.document.publicKeys;
        const services = input.document.services;
        // Validate recovery and update public keys.
        recoveryKeys.forEach(recoveryKey => {
            InputValidator_1.default.validateEs256kOperationKey(recoveryKey, OperationKeyType_1.default.Public);
        });
        updateKeys.forEach(updateKey => {
            InputValidator_1.default.validateEs256kOperationKey(updateKey, OperationKeyType_1.default.Public);
        });
        // Validate all given DID Document keys.
        ModenaRequest.validateDidDocumentKeys(didDocumentKeys);
        // Validate all given service.
        ModenaRequest.validateServices(services);
        const hashAlgorithmInMultihashCode = ModenaSdkConfig_1.default.hashAlgorithmInMultihashCode;
        const patches = [{
                action: PatchAction_1.default.Replace,
                document: input.document
            }];
        const delta = {
            updateCommitment: updateKeys.map(x => Multihash_1.default.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode)),
            patches
        };
        ModenaRequest.validateDeltaSize(delta);
        const deltaHash = Multihash_1.default.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
        const suffixData = {
            deltaHash,
            recoveryCommitment: recoveryKeys.map(recoveryKey => Multihash_1.default.canonicalizeThenDoubleHashThenEncode(recoveryKey, hashAlgorithmInMultihashCode))
        };
        const operationRequest = {
            type: OperationType_1.default.Create,
            suffixData: suffixData,
            delta: delta
        };
        return operationRequest;
    }
    static createDeactivateRequest(input) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate DID suffix
            ModenaRequest.validateDidSuffix(input.didSuffix);
            // Validates recovery public key
            InputValidator_1.default.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType_1.default.Public);
            const hashAlgorithmInMultihashCode = ModenaSdkConfig_1.default.hashAlgorithmInMultihashCode;
            const revealValue = Multihash_1.default.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);
            const dataToBeSigned = {
                didSuffix: input.didSuffix,
                recoveryKey: input.recoveryPublicKey
            };
            const compactJws = yield input.signer.sign({ alg: 'ES256K' }, dataToBeSigned);
            return {
                type: OperationType_1.default.Deactivate,
                didSuffix: input.didSuffix,
                revealValue: revealValue,
                signedData: compactJws
            };
        });
    }
    static createRecoverRequest(input) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate DID suffix
            ModenaRequest.validateDidSuffix(input.didSuffix);
            // Validate recovery public key
            InputValidator_1.default.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType_1.default.Public);
            // Validate next recovery public key
            input.nextRecoveryPublicKeys.forEach(nextRecoveryPublicKey => InputValidator_1.default.validateEs256kOperationKey(nextRecoveryPublicKey, OperationKeyType_1.default.Public));
            // Validate next update public key
            input.nextUpdatePublicKeys.forEach(nextUpdatePublicKey => InputValidator_1.default.validateEs256kOperationKey(nextUpdatePublicKey, OperationKeyType_1.default.Public));
            // Validate all given DID Document keys.
            ModenaRequest.validateDidDocumentKeys(input.document.publicKeys);
            // Validate all given service.
            ModenaRequest.validateServices(input.document.services);
            const hashAlgorithmInMultihashCode = ModenaSdkConfig_1.default.hashAlgorithmInMultihashCode;
            const revealValue = Multihash_1.default.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);
            const patches = [{
                    action: PatchAction_1.default.Replace,
                    document: input.document
                }];
            const nextUpdateCommitmentHash = input.nextUpdatePublicKeys.map(x => Multihash_1.default.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode));
            const delta = {
                patches,
                updateCommitment: nextUpdateCommitmentHash
            };
            const deltaHash = Multihash_1.default.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
            const nextRecoveryCommitmentHash = input.nextRecoveryPublicKeys.map(x => Multihash_1.default.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode));
            const dataToBeSigned = {
                recoveryCommitment: nextRecoveryCommitmentHash,
                recoveryKey: input.recoveryPublicKey,
                deltaHash: deltaHash
            };
            const compactJws = yield input.signer.sign({ alg: 'ES256K' }, dataToBeSigned);
            return {
                type: OperationType_1.default.Recover,
                didSuffix: input.didSuffix,
                revealValue: revealValue,
                delta: delta,
                signedData: compactJws
            };
        });
    }
    static createUpdateRequest(input) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            // Validate DID suffix
            ModenaRequest.validateDidSuffix(input.didSuffix);
            // Validate update public key
            InputValidator_1.default.validateEs256kOperationKey(input.updatePublicKey, OperationKeyType_1.default.Public);
            // Validate next update public key
            input.nextUpdatePublicKeys.forEach(x => InputValidator_1.default.validateEs256kOperationKey(x, OperationKeyType_1.default.Public));
            // Validate all given service.
            ModenaRequest.validateServices(input.servicesToAdd);
            // Validate all given DID Document keys.
            ModenaRequest.validateDidDocumentKeys(input.publicKeysToAdd);
            // Validate all given service id to remove.
            if (input.idsOfServicesToRemove !== undefined) {
                for (const id of input.idsOfServicesToRemove) {
                    InputValidator_1.default.validateId(id);
                }
            }
            // Validate all given public key id to remove.
            if (input.idsOfPublicKeysToRemove !== undefined) {
                for (const id of input.idsOfPublicKeysToRemove) {
                    InputValidator_1.default.validateId(id);
                }
            }
            const patches = [];
            // Create patches for add services
            const servicesToAdd = input.servicesToAdd;
            if (servicesToAdd !== undefined && servicesToAdd.length > 0) {
                const patch = {
                    action: PatchAction_1.default.AddServices,
                    services: servicesToAdd
                };
                patches.push(patch);
            }
            // Create patches for remove services
            const idsOfServicesToRemove = input.idsOfServicesToRemove;
            if (idsOfServicesToRemove !== undefined && idsOfServicesToRemove.length > 0) {
                const patch = {
                    action: PatchAction_1.default.RemoveServices,
                    ids: idsOfServicesToRemove
                };
                patches.push(patch);
            }
            // Create patches for adding public keys
            const publicKeysToAdd = input.publicKeysToAdd;
            if (publicKeysToAdd !== undefined && publicKeysToAdd.length > 0) {
                const patch = {
                    action: PatchAction_1.default.AddPublicKeys,
                    publicKeys: publicKeysToAdd
                };
                patches.push(patch);
            }
            // Create patch for removing public keys
            const idsOfPublicKeysToRemove = input.idsOfPublicKeysToRemove;
            if (idsOfPublicKeysToRemove !== undefined && idsOfPublicKeysToRemove.length > 0) {
                const patch = {
                    action: PatchAction_1.default.RemovePublicKeys,
                    ids: idsOfPublicKeysToRemove
                };
                patches.push(patch);
            }
            const hashAlgorithmInMultihashCode = ModenaSdkConfig_1.default.hashAlgorithmInMultihashCode;
            const revealValue = Multihash_1.default.canonicalizeThenHashThenEncode(input.updatePublicKey, hashAlgorithmInMultihashCode);
            const ucIndex = input.documentMetadata.method.updateCommitment.findIndex(x => x == UpdateCommitmentUtils_1.UpdateCommitmentUtils.getUpdateCommitmentHash(input.updatePublicKey));
            input.documentMetadata.method.updateCommitment.splice(ucIndex, 1);
            if ((_a = input.updateKeysToRemove) === null || _a === void 0 ? void 0 : _a.publicKeys) {
                for (let key of (_b = input.updateKeysToRemove) === null || _b === void 0 ? void 0 : _b.publicKeys) {
                    const ucIndex = input.documentMetadata.method.updateCommitment.findIndex(x => x == UpdateCommitmentUtils_1.UpdateCommitmentUtils.getUpdateCommitmentHash(key));
                    input.documentMetadata.method.updateCommitment.splice(ucIndex, 1);
                }
            }
            if ((_c = input.updateKeysToRemove) === null || _c === void 0 ? void 0 : _c.updateCommitment) {
                for (let key of (_d = input.updateKeysToRemove) === null || _d === void 0 ? void 0 : _d.updateCommitment) {
                    const ucIndex = input.documentMetadata.method.updateCommitment.findIndex(x => x == key);
                    input.documentMetadata.method.updateCommitment.splice(ucIndex, 1);
                }
            }
            const nextUpdateCommitmentHash = input.nextUpdatePublicKeys.map(x => Multihash_1.default.canonicalizeThenDoubleHashThenEncode(x, hashAlgorithmInMultihashCode));
            const delta = {
                patches,
                updateCommitment: [...input.documentMetadata.method.updateCommitment, ...nextUpdateCommitmentHash]
            };
            const deltaHash = Multihash_1.default.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
            const dataToBeSigned = {
                updateKey: input.updatePublicKey,
                deltaHash: deltaHash
            };
            const compactJws = yield input.signer.sign({ alg: 'ES256K' }, dataToBeSigned);
            return {
                type: OperationType_1.default.Update,
                didSuffix: input.didSuffix,
                revealValue,
                delta,
                signedData: compactJws
            };
        });
    }
    static validateDidSuffix(didSuffix) {
        Multihash_1.default.validateEncodedHashComputedUsingSupportedHashAlgorithm(didSuffix, 'didSuffix');
    }
    static validateDidDocumentKeys(publicKeys) {
        if (publicKeys === undefined) {
            return;
        }
        // Validate each public key.
        const publicKeyIdSet = new Set();
        for (const publicKey of publicKeys) {
            if (Array.isArray(publicKey.publicKeyJwk)) {
                throw new ModenaError_1.default(ErrorCode_1.default.DidDocumentPublicKeyMissingOrIncorrectType, `DID Document key 'publicKeyJwk' property is not a non-array object.`);
            }
            InputValidator_1.default.validateId(publicKey.id);
            // 'id' must be unique across all given keys.
            if (publicKeyIdSet.has(publicKey.id)) {
                throw new ModenaError_1.default(ErrorCode_1.default.DidDocumentPublicKeyIdDuplicated, `DID Document key with ID '${publicKey.id}' already exists.`);
            }
            publicKeyIdSet.add(publicKey.id);
            InputValidator_1.default.validatePublicKeyPurposes(publicKey.purposes);
        }
    }
    static validateServices(services) {
        if (services !== undefined && services.length !== 0) {
            const serviceIdSet = new Set();
            for (const service of services) {
                ModenaRequest.validateService(service);
                if (serviceIdSet.has(service.id)) {
                    throw new ModenaError_1.default(ErrorCode_1.default.DidDocumentServiceIdDuplicated, 'Service id has to be unique');
                }
                serviceIdSet.add(service.id);
            }
        }
    }
    static validateService(service) {
        InputValidator_1.default.validateId(service.id);
        const maxTypeLength = 30;
        if (service.type.length > maxTypeLength) {
            const errorMessage = `Service endpoint type length ${service.type.length} exceeds max allowed length of ${maxTypeLength}.`;
            throw new ModenaError_1.default(ErrorCode_1.default.ServiceTypeTooLong, errorMessage);
        }
        // Throw error if `serviceEndpoint` is an array.
        if (Array.isArray(service.serviceEndpoint)) {
            const errorMessage = 'Service endpoint value cannot be an array.';
            throw new ModenaError_1.default(ErrorCode_1.default.ServiceEndpointCannotBeAnArray, errorMessage);
        }
        if (typeof service.serviceEndpoint === 'string') {
            const uri = URI.parse(service.serviceEndpoint);
            if (uri.error !== undefined) {
                throw new ModenaError_1.default(ErrorCode_1.default.ServiceEndpointStringNotValidUri, `Service endpoint string '${service.serviceEndpoint}' is not a URI.`);
            }
        }
    }
    static validateDeltaSize(delta) {
        const deltaBuffer = JsonCanonicalizer_1.default.canonicalizeAsBuffer(delta);
        if (deltaBuffer.length > ModenaSdkConfig_1.default.maxCanonicalizedDeltaSizeInBytes) {
            const errorMessage = `Delta of ${deltaBuffer.length} bytes exceeded limit of ${ModenaSdkConfig_1.default.maxCanonicalizedDeltaSizeInBytes} bytes.`;
            throw new ModenaError_1.default(ErrorCode_1.default.DeltaExceedsMaximumSize, errorMessage);
        }
    }
}
exports.default = ModenaRequest;
//# sourceMappingURL=ModenaRequest.js.map
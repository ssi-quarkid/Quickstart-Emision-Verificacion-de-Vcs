"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const kms_core_1 = require("@extrimian/kms-core");
const kms_client_1 = require("@extrimian/kms-client");
const index_1 = require("../src/index");
const ModenaPublicKeyPurpose_1 = require("../src/enums/ModenaPublicKeyPurpose");
const ModenaRequest_1 = require("../src/ModenaRequest");
jest.setTimeout(5000000);
let _kms = null;
let did;
let recoveryKey;
let modenaEndpoint = "http://localhost:3000";
const getKMS = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!_kms) {
        let mapping = new Map();
        let storage = {
            add: (key, data) => __awaiter(void 0, void 0, void 0, function* () { mapping.set(key, data); }),
            get: (key) => mapping.get(key),
            getAll: () => __awaiter(void 0, void 0, void 0, function* () { return mapping; }),
            remove: (key) => mapping.delete(key),
            update: (key, data) => mapping.set(key, data),
        };
        _kms = new kms_client_1.KMSClient({
            lang: kms_core_1.LANG.es,
            storage: storage,
        });
    }
    return _kms;
});
const getDidDocument = (did) => new Promise((resolve, reject) => {
    setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
        let response = yield fetch(`${modenaEndpoint}/resolve/${did}`, {
            method: "GET",
            headers: {
                'Content-Type': 'application/json',
            },
        });
        if (response.status >= 200 && response.status < 300) {
            const didDocument = yield response.json();
            resolve(didDocument);
        }
        reject(response);
    }), 60000);
});
describe("STORAGE", () => {
    it("Create and public extended DID Doc", () => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        let kms = yield getKMS();
        const publicKey1 = yield kms.create(kms_core_1.Suite.ES256k);
        const secret1 = yield kms.export(publicKey1.publicKeyJWK);
        console.log(secret1);
        const publicKey2 = yield kms.create(kms_core_1.Suite.ES256k);
        const secret2 = yield kms.export(publicKey2.publicKeyJWK);
        console.log(secret2);
        //CREATE BBS PUBLIC KEYS
        const bbs = yield kms.create(kms_core_1.Suite.Bbsbls2020);
        const secretBbs = yield kms.export(bbs.publicKeyJWK);
        console.log(secretBbs);
        const document = {
            publicKeys: [{
                    id: "bbs2020",
                    publicKeyJwk: bbs.publicKeyJWK,
                    type: "Bls12381G1Key2020",
                    purposes: [ModenaPublicKeyPurpose_1.default.AssertionMethod],
                }],
            services: [],
            // roles: {
            //     admin: ["did:example:admin1", "did:example:admin2"],
            //     user: ["did:example:user1", "did:example:user1"],
            // }
        };
        const recoveryKeys = [publicKey1.publicKeyJWK, publicKey2.publicKeyJWK];
        recoveryKey = recoveryKeys[0];
        const updateKeys = [publicKey1.publicKeyJWK, publicKey2.publicKeyJWK];
        //Publicacion de un DID
        const input = { recoveryKeys, updateKeys, document };
        const result = ModenaRequest_1.default.createCreateRequest(input);
        index_1.ModenaSdkConfig.network = "quarkid:matic";
        const longDID = yield index_1.ModenaDid.createLongFormDid({
            document: document,
            recoveryKeys: recoveryKeys,
            updateKeys: updateKeys
        });
        console.log(longDID);
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(result)
        };
        let response = yield fetch(`${modenaEndpoint}/create`, options);
        if (response.status != 200 && response.status != 201) {
            const msg = yield response.json();
            throw new Error(`Ion DID creation is not ok: ${msg}`);
        }
        const resp = yield response.json();
        const canonicalId = (_a = resp.didDocumentMetadata) === null || _a === void 0 ? void 0 : _a.canonicalId;
        did = canonicalId.substring(canonicalId.lastIndexOf(":") + 1);
        console.log(did);
        const didDocument = yield getDidDocument(did);
        console.log(didDocument);
    }));
    it("Upate", () => __awaiter(void 0, void 0, void 0, function* () {
        let kms = yield getKMS();
        const updateKey = (yield kms.getPublicKeysBySuiteType(kms_core_1.Suite.ES256k))[0];
        const nextUpdateKey1 = yield kms.create(kms_core_1.Suite.ES256k);
        const nextUpdateKey2 = yield kms.create(kms_core_1.Suite.ES256k);
        const services = [{
                "id": "Service1Id",
                "type": "service1Type",
                "serviceEndpoint": "http://www.service1.com"
            }];
        const bbs = yield kms.create(kms_core_1.Suite.Bbsbls2020);
        const publicKeysToAdd = [{
                id: "updatedBbs2020",
                publicKeyJwk: bbs.publicKeyJWK,
                type: "Bls12381G1Key2020",
                purposes: [ModenaPublicKeyPurpose_1.default.AssertionMethod],
            }];
        const input = {
            didSuffix: did,
            updatePublicKey: updateKey,
            nextUpdatePublicKeys: [nextUpdateKey1.publicKeyJWK, nextUpdateKey2.publicKeyJWK],
            signer: {
                sign: (header, content) => __awaiter(void 0, void 0, void 0, function* () {
                    console.log(header);
                    return yield kms.sign(kms_core_1.Suite.ES256k, updateKey, content);
                })
            },
            servicesToAdd: services,
            idsOfServicesToRemove: ['service5Id'],
            publicKeysToAdd: publicKeysToAdd,
            idsOfPublicKeysToRemove: ['publicKeyModel333Id']
        };
        const result = yield ModenaRequest_1.default.createUpdateRequest(input);
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(result)
        };
        let response = yield fetch(`${modenaEndpoint}/create`, options);
        if (response.status != 200 && response.status != 201) {
            const msg = yield response.json();
            throw new Error(`Ion DID creation is not ok: ${msg}`);
        }
        const didDocument = yield getDidDocument(did);
        const pk = didDocument.verificationMethod.filter((x) => x.id == "#updatedBbs2020");
        expect(pk.length).toBe(1);
        console.log(pk);
    }));
    it("Recovery", () => __awaiter(void 0, void 0, void 0, function* () {
        // const publicKey = recoveryKey;
        let kms = yield getKMS();
        const nextUpdateKey1 = yield kms.create(kms_core_1.Suite.ES256k);
        const nextUpdateKey2 = yield kms.create(kms_core_1.Suite.ES256k);
        const bbsbls2020 = yield kms.create(kms_core_1.Suite.Bbsbls2020);
        const document = {
            publicKeys: [{
                    id: "bbsbls-recovery",
                    publicKeyJwk: bbsbls2020.publicKeyJWK,
                    type: "Bls12381G1Key2020",
                    purposes: [ModenaPublicKeyPurpose_1.default.AssertionMethod],
                }],
            services: [{
                    id: "dwn-from-recovery",
                    serviceEndpoint: "http://dwn.extrimian.com",
                    type: "DecentralizedWebNode"
                }]
        };
        const result = yield ModenaRequest_1.default.createRecoverRequest({
            didSuffix: did,
            recoveryPublicKey: recoveryKey,
            nextRecoveryPublicKeys: [nextUpdateKey1.publicKeyJWK, nextUpdateKey2.publicKeyJWK],
            nextUpdatePublicKeys: [nextUpdateKey1.publicKeyJWK, nextUpdateKey2.publicKeyJWK],
            document,
            signer: {
                sign: (header, content) => __awaiter(void 0, void 0, void 0, function* () {
                    console.log(header);
                    return yield kms.sign(kms_core_1.Suite.ES256k, recoveryKey, content);
                })
            },
        });
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(result)
        };
        let ionCoreEndpoint = "http://localhost:3000/create";
        let response = yield fetch(`${ionCoreEndpoint}`, options);
        if (response.status != 200 && response.status != 201) {
            const msg = yield response.json();
            throw new Error(`Ion DID creation is not ok: ${msg}`);
        }
        const didDocument = yield getDidDocument(did);
        const pk = didDocument.verificationMethod.filter((x) => x.id == "#bbsbls-recovery");
        expect(pk.length).toBe(1);
        console.log(pk);
    }));
});
//# sourceMappingURL=modena-extension-sdk.test.js.map
import { IVCJsonLDKeyPair, IVCSuite } from "@extrimian/kms-core";
import { AuthenticationPurpose, DIDDocument, Purpose, VerificationMethod } from "@extrimian/did-core";
const jsonld = require("jsonld-signatures");
const documentLoaders = require("jsonld");
const axios = require("axios");
import { isArray } from "util";

export abstract class JsonLDSuite implements IVCSuite {
    protected didDocumentResolver: (did: string) => Promise<DIDDocument>;

    contextDictionary =
        [
            { key: "https://www.w3.org/2018/credentials/v1", value: "https://storage.googleapis.com/contexts/credentials-v1.json" },
            { key: "https://w3id.org/security/bbs/v1", value: "https://storage.googleapis.com/contexts/vc-di-bbs.json" },
        ];


    private cache = new Map<string, any>();
    private useCache: boolean;

    protected secret?: IVCJsonLDKeyPair;

    customDocLoader = async (url: string): Promise<any> => {
        if (url.indexOf('did:') > -1 && url.indexOf("#") > -1) {
            const vm = await this.getVerificationMethod(url);

            if (vm) {
                return {
                    contextUrl: null, // this is for a context via a link header
                    document: this.vmConvertions(vm), // this is the actual document that was loaded
                    documentUrl: url // this is the actual context URL after redirects
                };
            }
        } else if (url.indexOf("did:") > -1) {
            const didDocument = await this.cacheGetter(url, async () => await this.didDocumentResolver(url));

            return {
                contextUrl: null, // this is for a context via a link header
                document: didDocument, // this is the actual document that was loaded
                documentUrl: url // this is the actual context URL after redirects
            };
        } else {
            const response = await this.cacheGetter(url, async () => {
                let contextURL = this.contextDictionary.find(x => url.includes(x.key))?.value || url;
                const response = await axios.get(contextURL);
                return response.data;
            });

            return {
                contextUrl: null,
                document: response,
                documentUrl: url
            };
        }
    };

    documentLoader: any = jsonld.extendContextLoader(this.customDocLoader);

    constructor() {

    }

    loadSuite(params: {
        secrets: IVCJsonLDKeyPair,
        useCache: boolean,
    }) {
        this.secret = params.secrets;
        this.useCache = params.useCache;
    }

    abstract create(): Promise<IVCJsonLDKeyPair>;

    async sign(documentToSign: any, controllerDid: string, verificationMethodId: string, purpuse: Purpose) {
        const suite = await this.getSuite({
            controllerDid,
            verificationMethodId
        });

        const purpose = await this.getPurpose(purpuse);

        const parsedDocumentToSign = JSON.parse(JSON.stringify(documentToSign));

        const signedDocument = await jsonld.sign(parsedDocumentToSign, {
            suite: suite,
            purpose: purpose,
            documentLoader: this.documentLoader,
        });
        return signedDocument;
    }

    protected abstract getSuite(params?: { verificationMethodId: string, controllerDid: string }): Promise<any>;

    async verify(data: string, purpose: Purpose): Promise<boolean> {
        const suite = await this.getSuite();

        const dataToSign = JSON.parse(data);

        let verifyProof = await jsonld.verify(dataToSign, {
            suite: suite,
            purpose: await this.getPurpose(purpose),
            documentLoader: this.documentLoader
        });

        return verifyProof.verified;
    }

    private async cacheGetter(key: string, action: (key: string) => Promise<any>) {
        if (!this.cache.has(key)) {
            const value = await action(key);
            this.cache.set(key, value);
        }

        return this.cache.get(key);
    }

    private getPurpose(purpose: Purpose) {
        if (purpose.name == "authentication") {
            if ((<AuthenticationPurpose>purpose).challenge) {
                return new jsonld.purposes.AuthenticationProofPurpose({
                    challenge: (<AuthenticationPurpose>purpose).challenge
                });
            }

            throw new Error("Authentication purpose requires challenge. Set this on purpose.challenge field");

        }

        return new jsonld.purposes.ControllerProofPurpose({ term: purpose.name });
    }

    vmConvertions(vm: VerificationMethod): VerificationMethod { return vm; }

    protected async getVerificationMethod<TVerificationMethod extends VerificationMethod = VerificationMethod>
        (vmId: string): Promise<TVerificationMethod> {
        const did = vmId.substring(0, vmId.indexOf("#"));

        const didDocument = await this.cacheGetter(did, async () => await this.didDocumentResolver(did));

        if (!didDocument || !didDocument?.id) throw new Error("DID Document can't be resolved");

        const vm = didDocument.verificationMethod.find(
            (x: any) => x.id.substring(x.id.lastIndexOf("#")) == vmId.substring(vmId.lastIndexOf("#")));

        if (vm) return vm;

        for (const field in didDocument) {
            if (isArray(didDocument[field])) {
                for (const vm in didDocument[field]) {
                    if (didDocument[field][vm].id == vmId) {
                        return didDocument[field][vm];
                    }
                }
            }
        }

        throw new Error("Verification method not found: " + vmId);
    }
}
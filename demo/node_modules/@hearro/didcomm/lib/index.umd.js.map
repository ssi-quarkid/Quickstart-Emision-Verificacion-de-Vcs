{"version":3,"file":"index.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import * as Base58 from 'base-58'\nimport sodium from 'libsodium-wrappers'\n\ninterface IUnpackedMsg {\n    message: string,\n    recipientKey: any,\n    senderKey: string\n    nonRepudiableVerification: boolean\n}\n\ninterface JWSUnpacked {\n    content: string,\n    verkey: string,\n    verified: boolean\n}\n\nexport class DIDComm {\n\n    public readonly ready: Promise<undefined>\n    private sodium: any\n\n    /**\n     * Creates a new PackUnpack object. The returned object contains a .Ready property:\n     * a promise that must be resolved before the object can be used. You can\n     * simply `await` the resolution of the .Ready property.\n     *\n     * Example:\n     * let packUnpack = new PackUnpack\n     * (async () => {\n     *  await packUnpack.Ready\n     * }())\n     */\n    constructor() {\n        this.ready = new Promise(async (res, rej) => {\n            try {\n                await sodium.ready\n                this.sodium = sodium\n                res()\n            } catch (err) {\n                rej(err)\n            }\n        })\n    }\n\n    /**\n    * Uses libsodium to generate a key pair, you may pass these keys into the pack/unpack functions\n    * @\n    */\n    public async generateKeyPair(): Promise<sodium.KeyPair> {\n        return this.sodium.crypto_sign_keypair()\n    }\n\n\n    /**\n     * Used to encrypt or encrypt and sign a message for one or many recipients so the recipients can authenticate the \n     * sender in both repudiable and non repudiable formats. By default messages should use repudiable authentication.\n     * This should be the most common API used.\n     * @param msg the message to be encrypted or encrypted and signed\n     * @param recipientKeys the keys which the message will be encrypted for\n     * @param senderKeys the keys used to encrypted or encrypt and sign a message\n     * @param nonRepudiable determines whether a message is encrypted only or signed and encrypted\n     * @returns if nonRepudiable == true returns the msg encrypted and signed as follows JWE(JWS(msg))\n     *          if nonRepudiable == false returns the msg encrypted as follows JWE(msg)\n     */\n    public async pack_auth_msg_for_recipients(\n        msg: string, recipientKeys: Uint8Array[], senderKeys: sodium.KeyPair, nonRepudiable: Boolean = false): Promise<string> {\n        if (nonRepudiable) {\n            //return JWE(JWS(msg))\n            let signedMsg = await this.signContent(msg, senderKeys);\n            return this.packMessage(signedMsg, recipientKeys, senderKeys);\n        } else {\n            // return (JWE(msg))\n            return this.packMessage(msg, recipientKeys, senderKeys);\n\n        }\n    }\n\n    /**\n     * \n     * @param msg this is the message which will be anonymously encrypted for one or many recipients\n     * @param recipientKeys a list of the recipients keys\n     * @returns a JWE with an ephemeral sender key\n     */\n    public async pack_anon_msg_for_recipients(msg: string, recipientKeys: Uint8Array[]): Promise<string> {\n        return this.packMessage(msg, recipientKeys, null)\n    }\n\n\n    /**\n     * \n     * @param msg the message to signed with non-repudiation but not encrypted\n     * @param senderKeys the key used to sign the \n     * @returns a compact JWS\n     */\n    public async pack_nonrepudiable_msg_for_anyone(msg: string, senderKeys: sodium.KeyPair): Promise<string> {\n        return this.signContent(msg, senderKeys);\n    }\n\n    /**\n     * Unpacks a message\n     * @param encMsg message to be decrypted\n     * @param toKeys key pair of party decrypting the message\n     */\n    public async unpackMessage(packedMsg: string, toKeys: sodium.KeyPair): Promise<IUnpackedMsg> {\n        try {\n            return await this.unpackEncrypted(packedMsg, toKeys)\n        } catch (err) {\n            let jwsChecked = this.verifyContent(packedMsg)\n            return {\n                message: jwsChecked.content,\n                recipientKey: null,\n                senderKey: jwsChecked.verkey,\n                nonRepudiableVerification: jwsChecked.verified\n            }\n        }\n    }\n\n    /**\n     *\n     * Packs a message.\n     * @param message string message to be encrypted\n     * @param toKeys public key of the entity encrypting message for\n     * @param fromKeys keypair of person encrypting message\n     */\n    private async packMessage(\n        msg: string, recipientKeys: Uint8Array[], fromKeys: sodium.KeyPair | null = null): Promise<string> {\n\n        let [recipsJson, cek] = this.prepareRecipientKeys(recipientKeys, fromKeys)\n        let recipsB64 = this.b64url(recipsJson)\n\n        let [ciphertext, tag, iv] = this.encryptPlaintext(msg, recipsB64, cek)\n\n        return JSON.stringify({\n            ciphertext: this.b64url(ciphertext),\n            iv: this.b64url(iv),\n            protected: recipsB64,\n            tag: this.b64url(tag),\n        })\n    }\n\n    private async unpackEncrypted(encMsg: string, toKeys: sodium.KeyPair): Promise<IUnpackedMsg> {\n        let wrapper\n        if (typeof encMsg === 'string') {\n            wrapper = JSON.parse(encMsg)\n        } else {\n            wrapper = encMsg\n        }\n        if (typeof toKeys.publicKey === 'string') {\n            toKeys.publicKey = Base58.decode(toKeys.publicKey)\n        }\n        if (typeof toKeys.privateKey === 'string') {\n            toKeys.privateKey = Base58.decode(toKeys.privateKey)\n        }\n        let recipsJson = this.strB64dec(wrapper.protected)\n        let recipsOuter = JSON.parse(recipsJson)\n\n        let alg = recipsOuter.alg\n        let isAuthcrypt = alg === 'Authcrypt'\n        if (!isAuthcrypt && alg !== 'Anoncrypt') {\n            throw new Error('Unsupported pack algorithm: ' + alg)\n        }\n        let [cek, senderVk, recipVk] = this.locateRecKey(recipsOuter.recipients, toKeys)\n        if (!senderVk && isAuthcrypt) {\n            throw new Error('Sender public key not provided in Authcrypt message')\n        }\n        let ciphertext = this.b64dec(wrapper.ciphertext)\n        let nonce = this.b64dec(wrapper.iv)\n        let tag = this.b64dec(wrapper.tag)\n\n        let message = this.decryptPlaintext(ciphertext, tag, wrapper.protected, nonce, cek)\n        try {\n            let jwsVerified = this.verifyContent(message)\n            return {\n                message: jwsVerified.content,\n                recipientKey: recipVk,\n                senderKey: senderVk,\n                nonRepudiableVerification: senderVk === jwsVerified.verkey ? true : false\n            }\n        } catch (err) {\n            return {\n                message,\n                recipientKey: recipVk,\n                senderKey: senderVk,\n                nonRepudiableVerification: false,\n            }\n        }\n    }\n\n    private async signContent(msg: string, signerKeyPair: sodium.KeyPair): Promise<string> {\n        // get public key base58 encoded\n        let senderVk = Base58.encode(signerKeyPair.publicKey)\n\n        // generate jose header, b64url encode it, and concat to b64url encoded payload\n        let joseHeader = {\n            alg: 'EdDSA',\n            kid: senderVk\n        }\n        let joseString = JSON.stringify(joseHeader);\n        let b64JoseStr = this.b64url(joseString);\n        let b64Payload = this.b64url(msg);\n        let headerAndPayloadConcat = `${b64JoseStr}.${b64Payload}`;\n\n        //sign data and return compact JWS\n        let signature = this.b64url(sodium.crypto_sign(headerAndPayloadConcat, signerKeyPair.privateKey));\n        return `${headerAndPayloadConcat}.${signature}`;\n    }\n\n    private verifyContent(jws: string): JWSUnpacked {\n        let jwsSplit = jws.split('.');\n        let joseHeader = JSON.parse(this.strB64dec(jwsSplit[0]));\n        if (joseHeader.alg != 'EdDSA') {\n            throw \"Cryptographic algorithm unidentifiable\"\n        };\n        let sigMsg = sodium.crypto_sign_open(this.b64dec(jwsSplit[2]), Base58.decode(joseHeader.kid));\n\n        return {\n            content: this.strB64dec(jwsSplit[1]),\n            verkey: joseHeader.kid,\n            verified: (sodium.to_string(sigMsg) === `${jwsSplit[0]}.${jwsSplit[1]}`) ? true : false\n        };\n    }\n\n    b64url(input: any) {\n        return this.sodium.to_base64(input, this.sodium.base64_variants.URLSAFE)\n    }\n\n    b64dec(input: any) {\n        return this.sodium.from_base64(input, this.sodium.base64_variants.URLSAFE)\n    }\n\n    private strB64dec(input: any) {\n        return this.sodium.to_string(this.sodium.from_base64(input, this.sodium.base64_variants.URLSAFE))\n    }\n\n    private encryptPlaintext(message: any, addData: any, key: any) {\n        let iv = this.sodium.randombytes_buf(this.sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n        let out = this.sodium.crypto_aead_chacha20poly1305_ietf_encrypt_detached(message, addData, null, iv, key)\n        return [out.ciphertext, out.mac, iv]\n    }\n\n    private decryptPlaintext(ciphertext: any, mac: any, recipsBin: any, nonce: any, key: any) {\n        return this.sodium.to_string(\n            this.sodium.crypto_aead_chacha20poly1305_ietf_decrypt_detached(\n                null, // nsec\n                ciphertext,\n                mac,\n                recipsBin, // ad\n                nonce, // npub\n                key,\n            ),\n        )\n    }\n\n    private prepareRecipientKeys(toKeys: any, fromKeys: any = null) {\n        let cek = this.sodium.crypto_aead_chacha20poly1305_ietf_keygen()\n        let recips: any[] = []\n\n        toKeys.forEach((targetVk: any) => {\n            let encCek = null\n            let encSender = null\n            let nonce = null\n\n            let targetPk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(targetVk)\n\n            if (fromKeys) {\n                let senderVk = Base58.encode(fromKeys.publicKey)\n                let senderSk = this.sodium.crypto_sign_ed25519_sk_to_curve25519(fromKeys.privateKey)\n                encSender = this.sodium.crypto_box_seal(senderVk, targetPk)\n\n                nonce = this.sodium.randombytes_buf(this.sodium.crypto_box_NONCEBYTES)\n                encCek = this.sodium.crypto_box_easy(cek, nonce, targetPk, senderSk)\n            } else {\n                encCek = this.sodium.crypto_box_seal(cek, targetPk)\n            }\n\n            recips.push(\n                {\n                    encrypted_key: this.b64url(encCek),\n                    header: {\n                        iv: nonce ? this.b64url(nonce) : null,\n                        kid: Base58.encode(targetVk),\n                        sender: encSender ? this.b64url(encSender) : null,\n                    },\n                },\n            )\n        })\n\n        let data = {\n            alg: fromKeys ? 'Authcrypt' : 'Anoncrypt',\n            enc: 'chacha20poly1305_ietf',\n            recipients: recips,\n            typ: 'JWM/1.0',\n        }\n        return [JSON.stringify(data), cek]\n    }\n\n    private locateRecKey(recipients: any, keys: any) {\n        let notFound = []\n        /* tslint:disable */\n        for (let index in recipients) {\n            let recip = recipients[index]\n            if (!('header' in recip) || !('encrypted_key' in recip)) {\n                throw new Error('Invalid recipient header')\n            }\n\n            let recipVk = Base58.decode(recip.header.kid)\n            if (!this.sodium.memcmp(recipVk, keys.publicKey)) {\n                notFound.push(recip.header.kid)\n            }\n            let pk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(keys.publicKey)\n            let sk = this.sodium.crypto_sign_ed25519_sk_to_curve25519(keys.privateKey)\n\n            let encrytpedKey = this.b64dec(recip.encrypted_key)\n            let nonce = recip.header.iv ? this.b64dec(recip.header.iv) : null\n            let encSender = recip.header.sender ? this.b64dec(recip.header.sender) : null\n\n            let senderVk = null\n            let cek = null\n            if (nonce && encSender) {\n                senderVk = this.sodium.to_string(this.sodium.crypto_box_seal_open(encSender, pk, sk))\n                let senderPk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(Base58.decode(senderVk))\n                cek = this.sodium.crypto_box_open_easy(encrytpedKey, nonce, senderPk, sk)\n            } else {\n                cek = this.sodium.crypto_box_seal_open(encrytpedKey, pk, sk)\n            }\n            return [cek, senderVk, recip.header.kid]\n        }\n\n        throw new Error('No corresponding recipient key found in recipients')\n    }\n}\n"],"names":["_catch","body","recover","result","e","then","Symbol","iterator","asyncIterator","DIDComm","constructor","this","ready","Promise","res","rej","sodium","err","generateKeyPair","crypto_sign_keypair","pack_auth_msg_for_recipients","msg","recipientKeys","senderKeys","nonRepudiable","_this3","signContent","signedMsg","packMessage","pack_anon_msg_for_recipients","pack_nonrepudiable_msg_for_anyone","unpackMessage","packedMsg","toKeys","_this6","unpackEncrypted","jwsChecked","verifyContent","message","content","senderKey","verkey","nonRepudiableVerification","verified","fromKeys","prepareRecipientKeys","recipsB64","b64url","encryptPlaintext","cek","JSON","stringify","ciphertext","iv","tag","encMsg","wrapper","parse","publicKey","Base58","privateKey","recipsJson","strB64dec","protected","recipsOuter","alg","isAuthcrypt","Error","locateRecKey","recipients","senderVk","b64dec","nonce","decryptPlaintext","jwsVerified","recipVk","signerKeyPair","joseString","headerAndPayloadConcat","signature","crypto_sign","jws","jwsSplit","split","joseHeader","sigMsg","crypto_sign_open","kid","to_string","input","to_base64","base64_variants","URLSAFE","from_base64","addData","key","randombytes_buf","crypto_aead_chacha20poly1305_ietf_NPUBBYTES","out","crypto_aead_chacha20poly1305_ietf_encrypt_detached","mac","recipsBin","crypto_aead_chacha20poly1305_ietf_decrypt_detached","crypto_aead_chacha20poly1305_ietf_keygen","recips","forEach","targetVk","encCek","encSender","targetPk","crypto_sign_ed25519_pk_to_curve25519","senderSk","crypto_sign_ed25519_sk_to_curve25519","crypto_box_seal","crypto_box_NONCEBYTES","crypto_box_easy","push","encrypted_key","header","keys","let","index","recip","memcmp","pk","sk","encrytpedKey","sender","crypto_box_seal_open","senderPk","crypto_box_open_easy"],"mappings":"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"}
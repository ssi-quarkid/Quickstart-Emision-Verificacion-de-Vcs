import sodium from 'libsodium-wrappers';
interface IUnpackedMsg {
    message: string;
    recipientKey: any;
    senderKey: string;
    nonRepudiableVerification: boolean;
}
export declare class DIDComm {
    readonly ready: Promise<undefined>;
    private sodium;
    /**
     * Creates a new PackUnpack object. The returned object contains a .Ready property:
     * a promise that must be resolved before the object can be used. You can
     * simply `await` the resolution of the .Ready property.
     *
     * Example:
     * let packUnpack = new PackUnpack
     * (async () => {
     *  await packUnpack.Ready
     * }())
     */
    constructor();
    /**
    * Uses libsodium to generate a key pair, you may pass these keys into the pack/unpack functions
    * @
    */
    generateKeyPair(): Promise<sodium.KeyPair>;
    /**
     * Used to encrypt or encrypt and sign a message for one or many recipients so the recipients can authenticate the
     * sender in both repudiable and non repudiable formats. By default messages should use repudiable authentication.
     * This should be the most common API used.
     * @param msg the message to be encrypted or encrypted and signed
     * @param recipientKeys the keys which the message will be encrypted for
     * @param senderKeys the keys used to encrypted or encrypt and sign a message
     * @param nonRepudiable determines whether a message is encrypted only or signed and encrypted
     * @returns if nonRepudiable == true returns the msg encrypted and signed as follows JWE(JWS(msg))
     *          if nonRepudiable == false returns the msg encrypted as follows JWE(msg)
     */
    pack_auth_msg_for_recipients(msg: string, recipientKeys: Uint8Array[], senderKeys: sodium.KeyPair, nonRepudiable?: Boolean): Promise<string>;
    /**
     *
     * @param msg this is the message which will be anonymously encrypted for one or many recipients
     * @param recipientKeys a list of the recipients keys
     * @returns a JWE with an ephemeral sender key
     */
    pack_anon_msg_for_recipients(msg: string, recipientKeys: Uint8Array[]): Promise<string>;
    /**
     *
     * @param msg the message to signed with non-repudiation but not encrypted
     * @param senderKeys the key used to sign the
     * @returns a compact JWS
     */
    pack_nonrepudiable_msg_for_anyone(msg: string, senderKeys: sodium.KeyPair): Promise<string>;
    /**
     * Unpacks a message
     * @param encMsg message to be decrypted
     * @param toKeys key pair of party decrypting the message
     */
    unpackMessage(packedMsg: string, toKeys: sodium.KeyPair): Promise<IUnpackedMsg>;
    /**
     *
     * Packs a message.
     * @param message string message to be encrypted
     * @param toKeys public key of the entity encrypting message for
     * @param fromKeys keypair of person encrypting message
     */
    private packMessage;
    private unpackEncrypted;
    private signContent;
    private verifyContent;
    b64url(input: any): any;
    b64dec(input: any): any;
    private strB64dec;
    private encryptPlaintext;
    private decryptPlaintext;
    private prepareRecipientKeys;
    private locateRecKey;
}
export {};

{"code":"import * as Base58 from 'base-58';\r\nimport sodium from 'libsodium-wrappers';\r\nexport class DIDComm {\r\n    /**\r\n     * Creates a new PackUnpack object. The returned object contains a .Ready property:\r\n     * a promise that must be resolved before the object can be used. You can\r\n     * simply `await` the resolution of the .Ready property.\r\n     *\r\n     * Example:\r\n     * let packUnpack = new PackUnpack\r\n     * (async () => {\r\n     *  await packUnpack.Ready\r\n     * }())\r\n     */\r\n    constructor() {\r\n        this.ready = new Promise(async (res, rej) => {\r\n            try {\r\n                await sodium.ready;\r\n                this.sodium = sodium;\r\n                res();\r\n            }\r\n            catch (err) {\r\n                rej(err);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n    * Uses libsodium to generate a key pair, you may pass these keys into the pack/unpack functions\r\n    * @\r\n    */\r\n    async generateKeyPair() {\r\n        return this.sodium.crypto_sign_keypair();\r\n    }\r\n    /**\r\n     * Used to encrypt or encrypt and sign a message for one or many recipients so the recipients can authenticate the\r\n     * sender in both repudiable and non repudiable formats. By default messages should use repudiable authentication.\r\n     * This should be the most common API used.\r\n     * @param msg the message to be encrypted or encrypted and signed\r\n     * @param recipientKeys the keys which the message will be encrypted for\r\n     * @param senderKeys the keys used to encrypted or encrypt and sign a message\r\n     * @param nonRepudiable determines whether a message is encrypted only or signed and encrypted\r\n     * @returns if nonRepudiable == true returns the msg encrypted and signed as follows JWE(JWS(msg))\r\n     *          if nonRepudiable == false returns the msg encrypted as follows JWE(msg)\r\n     */\r\n    async pack_auth_msg_for_recipients(msg, recipientKeys, senderKeys, nonRepudiable = false) {\r\n        if (nonRepudiable) {\r\n            //return JWE(JWS(msg))\r\n            let signedMsg = await this.signContent(msg, senderKeys);\r\n            return this.packMessage(signedMsg, recipientKeys, senderKeys);\r\n        }\r\n        else {\r\n            // return (JWE(msg))\r\n            return this.packMessage(msg, recipientKeys, senderKeys);\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param msg this is the message which will be anonymously encrypted for one or many recipients\r\n     * @param recipientKeys a list of the recipients keys\r\n     * @returns a JWE with an ephemeral sender key\r\n     */\r\n    async pack_anon_msg_for_recipients(msg, recipientKeys) {\r\n        return this.packMessage(msg, recipientKeys, null);\r\n    }\r\n    /**\r\n     *\r\n     * @param msg the message to signed with non-repudiation but not encrypted\r\n     * @param senderKeys the key used to sign the\r\n     * @returns a compact JWS\r\n     */\r\n    async pack_nonrepudiable_msg_for_anyone(msg, senderKeys) {\r\n        return this.signContent(msg, senderKeys);\r\n    }\r\n    /**\r\n     * Unpacks a message\r\n     * @param encMsg message to be decrypted\r\n     * @param toKeys key pair of party decrypting the message\r\n     */\r\n    async unpackMessage(packedMsg, toKeys) {\r\n        try {\r\n            return await this.unpackEncrypted(packedMsg, toKeys);\r\n        }\r\n        catch (err) {\r\n            let jwsChecked = this.verifyContent(packedMsg);\r\n            return {\r\n                message: jwsChecked.content,\r\n                recipientKey: null,\r\n                senderKey: jwsChecked.verkey,\r\n                nonRepudiableVerification: jwsChecked.verified\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * Packs a message.\r\n     * @param message string message to be encrypted\r\n     * @param toKeys public key of the entity encrypting message for\r\n     * @param fromKeys keypair of person encrypting message\r\n     */\r\n    async packMessage(msg, recipientKeys, fromKeys = null) {\r\n        let [recipsJson, cek] = this.prepareRecipientKeys(recipientKeys, fromKeys);\r\n        let recipsB64 = this.b64url(recipsJson);\r\n        let [ciphertext, tag, iv] = this.encryptPlaintext(msg, recipsB64, cek);\r\n        return JSON.stringify({\r\n            ciphertext: this.b64url(ciphertext),\r\n            iv: this.b64url(iv),\r\n            protected: recipsB64,\r\n            tag: this.b64url(tag),\r\n        });\r\n    }\r\n    async unpackEncrypted(encMsg, toKeys) {\r\n        let wrapper;\r\n        if (typeof encMsg === 'string') {\r\n            wrapper = JSON.parse(encMsg);\r\n        }\r\n        else {\r\n            wrapper = encMsg;\r\n        }\r\n        if (typeof toKeys.publicKey === 'string') {\r\n            toKeys.publicKey = Base58.decode(toKeys.publicKey);\r\n        }\r\n        if (typeof toKeys.privateKey === 'string') {\r\n            toKeys.privateKey = Base58.decode(toKeys.privateKey);\r\n        }\r\n        let recipsJson = this.strB64dec(wrapper.protected);\r\n        let recipsOuter = JSON.parse(recipsJson);\r\n        let alg = recipsOuter.alg;\r\n        let isAuthcrypt = alg === 'Authcrypt';\r\n        if (!isAuthcrypt && alg !== 'Anoncrypt') {\r\n            throw new Error('Unsupported pack algorithm: ' + alg);\r\n        }\r\n        let [cek, senderVk, recipVk] = this.locateRecKey(recipsOuter.recipients, toKeys);\r\n        if (!senderVk && isAuthcrypt) {\r\n            throw new Error('Sender public key not provided in Authcrypt message');\r\n        }\r\n        let ciphertext = this.b64dec(wrapper.ciphertext);\r\n        let nonce = this.b64dec(wrapper.iv);\r\n        let tag = this.b64dec(wrapper.tag);\r\n        let message = this.decryptPlaintext(ciphertext, tag, wrapper.protected, nonce, cek);\r\n        try {\r\n            let jwsVerified = this.verifyContent(message);\r\n            return {\r\n                message: jwsVerified.content,\r\n                recipientKey: recipVk,\r\n                senderKey: senderVk,\r\n                nonRepudiableVerification: senderVk === jwsVerified.verkey ? true : false\r\n            };\r\n        }\r\n        catch (err) {\r\n            return {\r\n                message,\r\n                recipientKey: recipVk,\r\n                senderKey: senderVk,\r\n                nonRepudiableVerification: false,\r\n            };\r\n        }\r\n    }\r\n    async signContent(msg, signerKeyPair) {\r\n        // get public key base58 encoded\r\n        let senderVk = Base58.encode(signerKeyPair.publicKey);\r\n        // generate jose header, b64url encode it, and concat to b64url encoded payload\r\n        let joseHeader = {\r\n            alg: 'EdDSA',\r\n            kid: senderVk\r\n        };\r\n        let joseString = JSON.stringify(joseHeader);\r\n        let b64JoseStr = this.b64url(joseString);\r\n        let b64Payload = this.b64url(msg);\r\n        let headerAndPayloadConcat = `${b64JoseStr}.${b64Payload}`;\r\n        //sign data and return compact JWS\r\n        let signature = this.b64url(sodium.crypto_sign(headerAndPayloadConcat, signerKeyPair.privateKey));\r\n        return `${headerAndPayloadConcat}.${signature}`;\r\n    }\r\n    verifyContent(jws) {\r\n        let jwsSplit = jws.split('.');\r\n        let joseHeader = JSON.parse(this.strB64dec(jwsSplit[0]));\r\n        if (joseHeader.alg != 'EdDSA') {\r\n            throw \"Cryptographic algorithm unidentifiable\";\r\n        }\r\n        ;\r\n        let sigMsg = sodium.crypto_sign_open(this.b64dec(jwsSplit[2]), Base58.decode(joseHeader.kid));\r\n        return {\r\n            content: this.strB64dec(jwsSplit[1]),\r\n            verkey: joseHeader.kid,\r\n            verified: (sodium.to_string(sigMsg) === `${jwsSplit[0]}.${jwsSplit[1]}`) ? true : false\r\n        };\r\n    }\r\n    b64url(input) {\r\n        return this.sodium.to_base64(input, this.sodium.base64_variants.URLSAFE);\r\n    }\r\n    b64dec(input) {\r\n        return this.sodium.from_base64(input, this.sodium.base64_variants.URLSAFE);\r\n    }\r\n    strB64dec(input) {\r\n        return this.sodium.to_string(this.sodium.from_base64(input, this.sodium.base64_variants.URLSAFE));\r\n    }\r\n    encryptPlaintext(message, addData, key) {\r\n        let iv = this.sodium.randombytes_buf(this.sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES);\r\n        let out = this.sodium.crypto_aead_chacha20poly1305_ietf_encrypt_detached(message, addData, null, iv, key);\r\n        return [out.ciphertext, out.mac, iv];\r\n    }\r\n    decryptPlaintext(ciphertext, mac, recipsBin, nonce, key) {\r\n        return this.sodium.to_string(this.sodium.crypto_aead_chacha20poly1305_ietf_decrypt_detached(null, // nsec\r\n        ciphertext, mac, recipsBin, // ad\r\n        nonce, // npub\r\n        key));\r\n    }\r\n    prepareRecipientKeys(toKeys, fromKeys = null) {\r\n        let cek = this.sodium.crypto_aead_chacha20poly1305_ietf_keygen();\r\n        let recips = [];\r\n        toKeys.forEach((targetVk) => {\r\n            let encCek = null;\r\n            let encSender = null;\r\n            let nonce = null;\r\n            let targetPk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(targetVk);\r\n            if (fromKeys) {\r\n                let senderVk = Base58.encode(fromKeys.publicKey);\r\n                let senderSk = this.sodium.crypto_sign_ed25519_sk_to_curve25519(fromKeys.privateKey);\r\n                encSender = this.sodium.crypto_box_seal(senderVk, targetPk);\r\n                nonce = this.sodium.randombytes_buf(this.sodium.crypto_box_NONCEBYTES);\r\n                encCek = this.sodium.crypto_box_easy(cek, nonce, targetPk, senderSk);\r\n            }\r\n            else {\r\n                encCek = this.sodium.crypto_box_seal(cek, targetPk);\r\n            }\r\n            recips.push({\r\n                encrypted_key: this.b64url(encCek),\r\n                header: {\r\n                    iv: nonce ? this.b64url(nonce) : null,\r\n                    kid: Base58.encode(targetVk),\r\n                    sender: encSender ? this.b64url(encSender) : null,\r\n                },\r\n            });\r\n        });\r\n        let data = {\r\n            alg: fromKeys ? 'Authcrypt' : 'Anoncrypt',\r\n            enc: 'chacha20poly1305_ietf',\r\n            recipients: recips,\r\n            typ: 'JWM/1.0',\r\n        };\r\n        return [JSON.stringify(data), cek];\r\n    }\r\n    locateRecKey(recipients, keys) {\r\n        let notFound = [];\r\n        /* tslint:disable */\r\n        for (let index in recipients) {\r\n            let recip = recipients[index];\r\n            if (!('header' in recip) || !('encrypted_key' in recip)) {\r\n                throw new Error('Invalid recipient header');\r\n            }\r\n            let recipVk = Base58.decode(recip.header.kid);\r\n            if (!this.sodium.memcmp(recipVk, keys.publicKey)) {\r\n                notFound.push(recip.header.kid);\r\n            }\r\n            let pk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(keys.publicKey);\r\n            let sk = this.sodium.crypto_sign_ed25519_sk_to_curve25519(keys.privateKey);\r\n            let encrytpedKey = this.b64dec(recip.encrypted_key);\r\n            let nonce = recip.header.iv ? this.b64dec(recip.header.iv) : null;\r\n            let encSender = recip.header.sender ? this.b64dec(recip.header.sender) : null;\r\n            let senderVk = null;\r\n            let cek = null;\r\n            if (nonce && encSender) {\r\n                senderVk = this.sodium.to_string(this.sodium.crypto_box_seal_open(encSender, pk, sk));\r\n                let senderPk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(Base58.decode(senderVk));\r\n                cek = this.sodium.crypto_box_open_easy(encrytpedKey, nonce, senderPk, sk);\r\n            }\r\n            else {\r\n                cek = this.sodium.crypto_box_seal_open(encrytpedKey, pk, sk);\r\n            }\r\n            return [cek, senderVk, recip.header.kid];\r\n        }\r\n        throw new Error('No corresponding recipient key found in recipients');\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map","map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/index.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/seth/dev/DIDComm-js/index.d.ts","writeByteOrderMark":false,"text":"import sodium from 'libsodium-wrappers';\r\ninterface IUnpackedMsg {\r\n    message: string;\r\n    recipientKey: any;\r\n    senderKey: string;\r\n    nonRepudiableVerification: boolean;\r\n}\r\nexport declare class DIDComm {\r\n    readonly ready: Promise<undefined>;\r\n    private sodium;\r\n    /**\r\n     * Creates a new PackUnpack object. The returned object contains a .Ready property:\r\n     * a promise that must be resolved before the object can be used. You can\r\n     * simply `await` the resolution of the .Ready property.\r\n     *\r\n     * Example:\r\n     * let packUnpack = new PackUnpack\r\n     * (async () => {\r\n     *  await packUnpack.Ready\r\n     * }())\r\n     */\r\n    constructor();\r\n    /**\r\n    * Uses libsodium to generate a key pair, you may pass these keys into the pack/unpack functions\r\n    * @\r\n    */\r\n    generateKeyPair(): Promise<sodium.KeyPair>;\r\n    /**\r\n     * Used to encrypt or encrypt and sign a message for one or many recipients so the recipients can authenticate the\r\n     * sender in both repudiable and non repudiable formats. By default messages should use repudiable authentication.\r\n     * This should be the most common API used.\r\n     * @param msg the message to be encrypted or encrypted and signed\r\n     * @param recipientKeys the keys which the message will be encrypted for\r\n     * @param senderKeys the keys used to encrypted or encrypt and sign a message\r\n     * @param nonRepudiable determines whether a message is encrypted only or signed and encrypted\r\n     * @returns if nonRepudiable == true returns the msg encrypted and signed as follows JWE(JWS(msg))\r\n     *          if nonRepudiable == false returns the msg encrypted as follows JWE(msg)\r\n     */\r\n    pack_auth_msg_for_recipients(msg: string, recipientKeys: Uint8Array[], senderKeys: sodium.KeyPair, nonRepudiable?: Boolean): Promise<string>;\r\n    /**\r\n     *\r\n     * @param msg this is the message which will be anonymously encrypted for one or many recipients\r\n     * @param recipientKeys a list of the recipients keys\r\n     * @returns a JWE with an ephemeral sender key\r\n     */\r\n    pack_anon_msg_for_recipients(msg: string, recipientKeys: Uint8Array[]): Promise<string>;\r\n    /**\r\n     *\r\n     * @param msg the message to signed with non-repudiation but not encrypted\r\n     * @param senderKeys the key used to sign the\r\n     * @returns a compact JWS\r\n     */\r\n    pack_nonrepudiable_msg_for_anyone(msg: string, senderKeys: sodium.KeyPair): Promise<string>;\r\n    /**\r\n     * Unpacks a message\r\n     * @param encMsg message to be decrypted\r\n     * @param toKeys key pair of party decrypting the message\r\n     */\r\n    unpackMessage(packedMsg: string, toKeys: sodium.KeyPair): Promise<IUnpackedMsg>;\r\n    /**\r\n     *\r\n     * Packs a message.\r\n     * @param message string message to be encrypted\r\n     * @param toKeys public key of the entity encrypting message for\r\n     * @param fromKeys keypair of person encrypting message\r\n     */\r\n    private packMessage;\r\n    private unpackEncrypted;\r\n    private signContent;\r\n    private verifyContent;\r\n    b64url(input: any): any;\r\n    b64dec(input: any): any;\r\n    private strB64dec;\r\n    private encryptPlaintext;\r\n    private decryptPlaintext;\r\n    private prepareRecipientKeys;\r\n    private locateRecKey;\r\n}\r\nexport {};\r\n"}}

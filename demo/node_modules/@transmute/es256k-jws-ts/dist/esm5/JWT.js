import { __assign, __awaiter, __extends, __generator } from "tslib";
import JWS from './JWS';
/** default expiration in hours added automatically */
var defaultExpiresInHours = 1;
var JWTVerificationFailed = /** @class */ (function (_super) {
    __extends(JWTVerificationFailed, _super);
    function JWTVerificationFailed(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'JWTVerificationFailed';
        return _this;
    }
    return JWTVerificationFailed;
}(Error));
/** return a JWT singed with ES256K JWS */
export var sign = function (payload, privateKeyJWK) { return __awaiter(void 0, void 0, void 0, function () {
    var iat, exp;
    return __generator(this, function (_a) {
        iat = Math.floor(Date.now() / 1000);
        exp = iat + 60 * 60 * defaultExpiresInHours;
        return [2 /*return*/, JWS.sign(__assign(__assign({}, payload), { exp: payload.exp || exp, iat: iat }), privateKeyJWK, {
                alg: 'ES256K',
                kid: privateKeyJWK.kid,
            })];
    });
}); };
/** verify a JWT singed with ES256K JWS */
export var verify = function (jwt, publicKeyJWK) { return __awaiter(void 0, void 0, void 0, function () {
    var verified;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, JWS.verify(jwt, publicKeyJWK)];
            case 1:
                verified = _a.sent();
                if (Math.floor(Date.now() / 1000) > verified.exp) {
                    throw new JWTVerificationFailed('token is expired');
                }
                return [2 /*return*/, verified];
        }
    });
}); };
export default { sign: sign, decode: JWS.decode, verify: verify };
//# sourceMappingURL=JWT.js.map
import { __assign, __awaiter, __generator } from "tslib";
import keyto from '@trust/keyto';
import base64url from 'base64url';
import crypto from 'crypto';
import { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';
import stringify from 'json-stringify-deterministic';
var compressedHexEncodedPublicKeyLength = 66;
/**
 * Example
 * ```js
 * {
 *  kty: 'EC',
 *  crv: 'secp256k1',
 *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',
 *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',
 *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',
 *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'
 * }
 * ```
 * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.
 */
export var getKid = function (jwk) {
    var copy = __assign({}, jwk);
    delete copy.d;
    delete copy.kid;
    delete copy.alg;
    var digest = crypto
        .createHash('sha256')
        .update(stringify(copy))
        .digest();
    return base64url.encode(Buffer.from(digest));
};
/** convert compressed hex encoded private key to jwk */
export var privateJWKFromPrivateKeyHex = function (privateKeyHex) { return __awaiter(void 0, void 0, void 0, function () {
    var jwk, kid;
    return __generator(this, function (_a) {
        jwk = __assign(__assign({}, keyto.from(privateKeyHex, 'blk').toJwk('private')), { crv: 'secp256k1' });
        kid = getKid(jwk);
        return [2 /*return*/, __assign(__assign({}, jwk), { kid: kid })];
    });
}); };
/** convert compressed hex encoded public key to jwk */
export var publicJWKFromPublicKeyHex = function (publicKeyHex) { return __awaiter(void 0, void 0, void 0, function () {
    var secp256k1, key, jwk, kid;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, instantiateSecp256k1()];
            case 1:
                secp256k1 = _a.sent();
                key = publicKeyHex;
                if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {
                    key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));
                }
                jwk = __assign(__assign({}, keyto.from(key, 'blk').toJwk('public')), { crv: 'secp256k1' });
                kid = getKid(jwk);
                return [2 /*return*/, __assign(__assign({}, jwk), { kid: kid })];
        }
    });
}); };
/** convert pem encoded private key to jwk */
export var privateJWKFromPrivateKeyPem = function (privateKeyPem) {
    var jwk = __assign(__assign({}, keyto.from(privateKeyPem, 'pem').toJwk('private')), { crv: 'secp256k1' });
    // console.log(jwk);
    var kid = getKid(jwk);
    return __assign(__assign({}, jwk), { kid: kid });
};
/** convert pem encoded private key to jwk */
export var publicJWKFromPublicKeyPem = function (publicKeyPem) {
    var jwk = __assign(__assign({}, keyto.from(publicKeyPem, 'pem').toJwk('public')), { crv: 'secp256k1' });
    var kid = getKid(jwk);
    return __assign(__assign({}, jwk), { kid: kid });
};
/** convert jwk to hex encoded private key */
export var privateKeyHexFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, keyto
                .from(__assign(__assign({}, jwk), { crv: 'K-256' }), 'jwk')
                .toString('blk', 'private')];
    });
}); };
/** convert jwk to hex encoded public key */
export var publicKeyHexFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {
    var secp256k1, uncompressedPublicKey, compressed;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, instantiateSecp256k1()];
            case 1:
                secp256k1 = _a.sent();
                uncompressedPublicKey = keyto
                    .from(__assign(__assign({}, jwk), { crv: 'K-256' }), 'jwk')
                    .toString('blk', 'public');
                compressed = secp256k1.compressPublicKey(hexToBin(uncompressedPublicKey));
                return [2 /*return*/, binToHex(compressed)];
        }
    });
}); };
/** convert jwk to binary encoded private key */
export var privateKeyUInt8ArrayFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {
    var privateKeyHex;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, privateKeyHexFromJWK(jwk)];
            case 1:
                privateKeyHex = _a.sent();
                return [2 /*return*/, hexToBin(privateKeyHex)];
        }
    });
}); };
/** convert jwk to binary encoded public key */
export var publicKeyUInt8ArrayFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {
    var publicKeyHex;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, publicKeyHexFromJWK(jwk)];
            case 1:
                publicKeyHex = _a.sent();
                return [2 /*return*/, hexToBin(publicKeyHex)];
        }
    });
}); };
export default {
    binToHex: binToHex,
    getKid: getKid,
    hexToBin: hexToBin,
    privateJWKFromPrivateKeyHex: privateJWKFromPrivateKeyHex,
    privateJWKFromPrivateKeyPem: privateJWKFromPrivateKeyPem,
    privateKeyHexFromJWK: privateKeyHexFromJWK,
    privateKeyUInt8ArrayFromJWK: privateKeyUInt8ArrayFromJWK,
    publicJWKFromPublicKeyHex: publicJWKFromPublicKeyHex,
    publicJWKFromPublicKeyPem: publicJWKFromPublicKeyPem,
    publicKeyHexFromJWK: publicKeyHexFromJWK,
    publicKeyUInt8ArrayFromJWK: publicKeyUInt8ArrayFromJWK,
};
//# sourceMappingURL=keyUtils.js.map
import { __awaiter, __extends, __generator } from "tslib";
import base64url from 'base64url';
import { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';
import crypto from 'crypto';
import { privateKeyUInt8ArrayFromJWK, publicKeyUInt8ArrayFromJWK, } from './keyUtils';
/** error matching @panva/jose for JWS verification failure. */
var JWSVerificationFailed = /** @class */ (function (_super) {
    __extends(JWSVerificationFailed, _super);
    function JWSVerificationFailed(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'JWSVerificationFailed';
        return _this;
    }
    return JWSVerificationFailed;
}(Error));
/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
export var signDetached = function (
// in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData
payload, privateKeyJWK, header) {
    if (header === void 0) { header = {
        alg: 'ES256K',
        b64: false,
        crit: ['b64'],
    }; }
    return __awaiter(void 0, void 0, void 0, function () {
        var privateKeyUInt8Array, secp256k1, encodedHeader, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, privateKeyUInt8ArrayFromJWK(privateKeyJWK)];
                case 1:
                    privateKeyUInt8Array = _a.sent();
                    return [4 /*yield*/, instantiateSecp256k1()];
                case 2:
                    secp256k1 = _a.sent();
                    encodedHeader = base64url.encode(JSON.stringify(header));
                    toBeSignedBuffer = Buffer.concat([
                        Buffer.from(encodedHeader + '.', 'utf8'),
                        Buffer.from(payload.buffer, payload.byteOffset, payload.length),
                    ]);
                    message = Buffer.from(toBeSignedBuffer);
                    digest = crypto
                        .createHash('sha256')
                        .update(message)
                        .digest()
                        .toString('hex');
                    messageHashUInt8Array = hexToBin(digest);
                    signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);
                    signatureHex = binToHex(signatureUInt8Array);
                    encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));
                    return [2 /*return*/, encodedHeader + ".." + encodedSignature];
            }
        });
    });
};
/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
export var verifyDetached = function (jws, payload, publicKeyJWK) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, encodedHeader, encodedSignature, header, publicKeyUInt8Array, secp256k1, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (jws.indexOf('..') === -1) {
                    throw new JWSVerificationFailed('not a valid rfc7797 jws.');
                }
                _a = jws.split('..'), encodedHeader = _a[0], encodedSignature = _a[1];
                header = JSON.parse(base64url.decode(encodedHeader));
                if (header.alg !== 'ES256K') {
                    throw new Error('JWS alg is not signed with ES256K.');
                }
                if (header.b64 !== false ||
                    !header.crit ||
                    !header.crit.length ||
                    header.crit[0] !== 'b64') {
                    throw new Error('JWS Header is not in rfc7797 format (not detached).');
                }
                return [4 /*yield*/, publicKeyUInt8ArrayFromJWK(publicKeyJWK)];
            case 1:
                publicKeyUInt8Array = _b.sent();
                return [4 /*yield*/, instantiateSecp256k1()];
            case 2:
                secp256k1 = _b.sent();
                toBeSignedBuffer = Buffer.concat([
                    Buffer.from(encodedHeader + '.', 'utf8'),
                    Buffer.from(payload.buffer, payload.byteOffset, payload.length),
                ]);
                message = Buffer.from(toBeSignedBuffer);
                digest = crypto
                    .createHash('sha256')
                    .update(message)
                    .digest()
                    .toString('hex');
                messageHashUInt8Array = hexToBin(digest);
                signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));
                verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);
                if (verified) {
                    return [2 /*return*/, true];
                }
                throw new Error('Cannot verify detached signature.');
        }
    });
}); };
/** Produce a normal ES256K JWS */
export var sign = function (payload, privateKeyJWK, header) {
    if (header === void 0) { header = { alg: 'ES256K' }; }
    return __awaiter(void 0, void 0, void 0, function () {
        var privateKeyUInt8Array, secp256k1, encodedHeader, encodedPayload, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, privateKeyUInt8ArrayFromJWK(privateKeyJWK)];
                case 1:
                    privateKeyUInt8Array = _a.sent();
                    return [4 /*yield*/, instantiateSecp256k1()];
                case 2:
                    secp256k1 = _a.sent();
                    encodedHeader = base64url.encode(JSON.stringify(header));
                    encodedPayload = base64url.encode(JSON.stringify(payload));
                    toBeSigned = encodedHeader + "." + encodedPayload;
                    message = Buffer.from(toBeSigned);
                    digest = crypto
                        .createHash('sha256')
                        .update(message)
                        .digest()
                        .toString('hex');
                    messageHashUInt8Array = hexToBin(digest);
                    signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);
                    signatureHex = binToHex(signatureUInt8Array);
                    encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));
                    return [2 /*return*/, encodedHeader + "." + encodedPayload + "." + encodedSignature];
            }
        });
    });
};
/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */
export var verify = function (jws, publicKeyJWK) { return __awaiter(void 0, void 0, void 0, function () {
    var secp256k1, publicKeyUInt8Array, _a, encodedHeader, encodedPayload, encodedSignature, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, instantiateSecp256k1()];
            case 1:
                secp256k1 = _b.sent();
                return [4 /*yield*/, publicKeyUInt8ArrayFromJWK(publicKeyJWK)];
            case 2:
                publicKeyUInt8Array = _b.sent();
                _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];
                toBeSigned = encodedHeader + "." + encodedPayload;
                message = Buffer.from(toBeSigned);
                digest = crypto
                    .createHash('sha256')
                    .update(message)
                    .digest()
                    .toString('hex');
                messageHashUInt8Array = hexToBin(digest);
                signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));
                verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);
                if (verified) {
                    return [2 /*return*/, JSON.parse(base64url.decode(encodedPayload))];
                }
                throw new JWSVerificationFailed('signature verification failed');
        }
    });
}); };
/** decode a JWS (without verifying it) */
export var decode = function (jws, options) {
    if (options === void 0) { options = { complete: false }; }
    var _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];
    if (options.complete) {
        return {
            header: JSON.parse(base64url.decode(encodedHeader)),
            payload: JSON.parse(base64url.decode(encodedPayload)),
            signature: encodedSignature,
        };
    }
    return JSON.parse(base64url.decode(encodedPayload));
};
export default {
    decode: decode,
    sign: sign,
    signDetached: signDetached,
    verify: verify,
    verifyDetached: verifyDetached,
};
//# sourceMappingURL=JWS.js.map
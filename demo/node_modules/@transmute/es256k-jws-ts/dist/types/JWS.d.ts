/// <reference types="node" />
import { ISecp256k1PrivateKeyJWK, ISecp256k1PublicJWK } from './keyUtils';
/** JWS Header */
export interface IJWSHeader {
    /** algorithm, ES256K */
    alg: string;
    /** type, JWT */
    typ?: string;
    /** signing key id, ... */
    kid?: string;
}
/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
export declare const signDetached: (payload: Buffer, privateKeyJWK: ISecp256k1PrivateKeyJWK, header?: {
    alg: string;
    b64: boolean;
    crit: string[];
}) => Promise<string>;
/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
export declare const verifyDetached: (jws: string, payload: Buffer, publicKeyJWK: ISecp256k1PublicJWK) => Promise<boolean>;
/** Produce a normal ES256K JWS */
export declare const sign: (payload: any, privateKeyJWK: ISecp256k1PrivateKeyJWK, header?: IJWSHeader) => Promise<string>;
/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */
export declare const verify: (jws: string, publicKeyJWK: ISecp256k1PublicJWK) => Promise<any>;
/** decode a JWS (without verifying it) */
export declare const decode: (jws: string, options?: {
    complete: boolean;
}) => any;
declare const _default: {
    decode: (jws: string, options?: {
        complete: boolean;
    }) => any;
    sign: (payload: any, privateKeyJWK: ISecp256k1PrivateKeyJWK, header?: IJWSHeader) => Promise<string>;
    signDetached: (payload: Buffer, privateKeyJWK: ISecp256k1PrivateKeyJWK, header?: {
        alg: string;
        b64: boolean;
        crit: string[];
    }) => Promise<string>;
    verify: (jws: string, publicKeyJWK: ISecp256k1PublicJWK) => Promise<any>;
    verifyDetached: (jws: string, payload: Buffer, publicKeyJWK: ISecp256k1PublicJWK) => Promise<boolean>;
};
export default _default;
//# sourceMappingURL=JWS.d.ts.map
import keyto from '@trust/keyto';
import base64url from 'base64url';
import crypto from 'crypto';
import { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';
import stringify from 'json-stringify-deterministic';
const compressedHexEncodedPublicKeyLength = 66;
/**
 * Example
 * ```js
 * {
 *  kty: 'EC',
 *  crv: 'secp256k1',
 *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',
 *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',
 *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',
 *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'
 * }
 * ```
 * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.
 */
export const getKid = (jwk) => {
    const copy = { ...jwk };
    delete copy.d;
    delete copy.kid;
    delete copy.alg;
    const digest = crypto
        .createHash('sha256')
        .update(stringify(copy))
        .digest();
    return base64url.encode(Buffer.from(digest));
};
/** convert compressed hex encoded private key to jwk */
export const privateJWKFromPrivateKeyHex = async (privateKeyHex) => {
    const jwk = {
        ...keyto.from(privateKeyHex, 'blk').toJwk('private'),
        crv: 'secp256k1',
    };
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert compressed hex encoded public key to jwk */
export const publicJWKFromPublicKeyHex = async (publicKeyHex) => {
    const secp256k1 = await instantiateSecp256k1();
    let key = publicKeyHex;
    if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {
        key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));
    }
    const jwk = {
        ...keyto.from(key, 'blk').toJwk('public'),
        crv: 'secp256k1',
    };
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert pem encoded private key to jwk */
export const privateJWKFromPrivateKeyPem = (privateKeyPem) => {
    const jwk = {
        ...keyto.from(privateKeyPem, 'pem').toJwk('private'),
        crv: 'secp256k1',
    };
    // console.log(jwk);
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert pem encoded private key to jwk */
export const publicJWKFromPublicKeyPem = (publicKeyPem) => {
    const jwk = {
        ...keyto.from(publicKeyPem, 'pem').toJwk('public'),
        crv: 'secp256k1',
    };
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert jwk to hex encoded private key */
export const privateKeyHexFromJWK = async (jwk) => keyto
    .from({
    ...jwk,
    crv: 'K-256',
}, 'jwk')
    .toString('blk', 'private');
/** convert jwk to hex encoded public key */
export const publicKeyHexFromJWK = async (jwk) => {
    const secp256k1 = await instantiateSecp256k1();
    const uncompressedPublicKey = keyto
        .from({
        ...jwk,
        crv: 'K-256',
    }, 'jwk')
        .toString('blk', 'public');
    const compressed = secp256k1.compressPublicKey(hexToBin(uncompressedPublicKey));
    return binToHex(compressed);
};
/** convert jwk to binary encoded private key */
export const privateKeyUInt8ArrayFromJWK = async (jwk) => {
    const privateKeyHex = await privateKeyHexFromJWK(jwk);
    return hexToBin(privateKeyHex);
};
/** convert jwk to binary encoded public key */
export const publicKeyUInt8ArrayFromJWK = async (jwk) => {
    const publicKeyHex = await publicKeyHexFromJWK(jwk);
    return hexToBin(publicKeyHex);
};
export default {
    binToHex,
    getKid,
    hexToBin,
    privateJWKFromPrivateKeyHex,
    privateJWKFromPrivateKeyPem,
    privateKeyHexFromJWK,
    privateKeyUInt8ArrayFromJWK,
    publicJWKFromPublicKeyHex,
    publicJWKFromPublicKeyPem,
    publicKeyHexFromJWK,
    publicKeyUInt8ArrayFromJWK,
};
//# sourceMappingURL=keyUtils.js.map
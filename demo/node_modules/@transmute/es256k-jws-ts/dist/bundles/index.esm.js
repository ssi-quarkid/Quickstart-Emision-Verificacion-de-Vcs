import base64url from 'base64url';
import { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';
import crypto from 'crypto';
import keyto from '@trust/keyto';
import stringify from 'json-stringify-deterministic';

const compressedHexEncodedPublicKeyLength = 66;
/**
 * Example
 * ```js
 * {
 *  kty: 'EC',
 *  crv: 'secp256k1',
 *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',
 *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',
 *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',
 *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'
 * }
 * ```
 * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.
 */
const getKid = (jwk) => {
    const copy = { ...jwk };
    delete copy.d;
    delete copy.kid;
    delete copy.alg;
    const digest = crypto
        .createHash('sha256')
        .update(stringify(copy))
        .digest();
    return base64url.encode(Buffer.from(digest));
};
/** convert compressed hex encoded private key to jwk */
const privateJWKFromPrivateKeyHex = async (privateKeyHex) => {
    const jwk = {
        ...keyto.from(privateKeyHex, 'blk').toJwk('private'),
        crv: 'secp256k1',
    };
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert compressed hex encoded public key to jwk */
const publicJWKFromPublicKeyHex = async (publicKeyHex) => {
    const secp256k1 = await instantiateSecp256k1();
    let key = publicKeyHex;
    if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {
        key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));
    }
    const jwk = {
        ...keyto.from(key, 'blk').toJwk('public'),
        crv: 'secp256k1',
    };
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert pem encoded private key to jwk */
const privateJWKFromPrivateKeyPem = (privateKeyPem) => {
    const jwk = {
        ...keyto.from(privateKeyPem, 'pem').toJwk('private'),
        crv: 'secp256k1',
    };
    // console.log(jwk);
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert pem encoded private key to jwk */
const publicJWKFromPublicKeyPem = (publicKeyPem) => {
    const jwk = {
        ...keyto.from(publicKeyPem, 'pem').toJwk('public'),
        crv: 'secp256k1',
    };
    const kid = getKid(jwk);
    return {
        ...jwk,
        kid,
    };
};
/** convert jwk to hex encoded private key */
const privateKeyHexFromJWK = async (jwk) => keyto
    .from({
    ...jwk,
    crv: 'K-256',
}, 'jwk')
    .toString('blk', 'private');
/** convert jwk to hex encoded public key */
const publicKeyHexFromJWK = async (jwk) => {
    const secp256k1 = await instantiateSecp256k1();
    const uncompressedPublicKey = keyto
        .from({
        ...jwk,
        crv: 'K-256',
    }, 'jwk')
        .toString('blk', 'public');
    const compressed = secp256k1.compressPublicKey(hexToBin(uncompressedPublicKey));
    return binToHex(compressed);
};
/** convert jwk to binary encoded private key */
const privateKeyUInt8ArrayFromJWK = async (jwk) => {
    const privateKeyHex = await privateKeyHexFromJWK(jwk);
    return hexToBin(privateKeyHex);
};
/** convert jwk to binary encoded public key */
const publicKeyUInt8ArrayFromJWK = async (jwk) => {
    const publicKeyHex = await publicKeyHexFromJWK(jwk);
    return hexToBin(publicKeyHex);
};
var keyUtils = {
    binToHex,
    getKid,
    hexToBin,
    privateJWKFromPrivateKeyHex,
    privateJWKFromPrivateKeyPem,
    privateKeyHexFromJWK,
    privateKeyUInt8ArrayFromJWK,
    publicJWKFromPublicKeyHex,
    publicJWKFromPublicKeyPem,
    publicKeyHexFromJWK,
    publicKeyUInt8ArrayFromJWK,
};

/** error matching @panva/jose for JWS verification failure. */
class JWSVerificationFailed extends Error {
    constructor(message) {
        super(message);
        this.name = 'JWSVerificationFailed';
    }
}
/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
const signDetached = async (
// in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData
payload, privateKeyJWK, header = {
    alg: 'ES256K',
    b64: false,
    crit: ['b64'],
}) => {
    const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJWK(privateKeyJWK);
    const secp256k1 = await instantiateSecp256k1();
    const encodedHeader = base64url.encode(JSON.stringify(header));
    const toBeSignedBuffer = Buffer.concat([
        Buffer.from(encodedHeader + '.', 'utf8'),
        Buffer.from(payload.buffer, payload.byteOffset, payload.length),
    ]);
    const message = Buffer.from(toBeSignedBuffer);
    const digest = crypto
        .createHash('sha256')
        .update(message)
        .digest()
        .toString('hex');
    const messageHashUInt8Array = hexToBin(digest);
    const signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);
    const signatureHex = binToHex(signatureUInt8Array);
    const encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));
    return `${encodedHeader}..${encodedSignature}`;
};
/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
const verifyDetached = async (jws, payload, publicKeyJWK) => {
    if (jws.indexOf('..') === -1) {
        throw new JWSVerificationFailed('not a valid rfc7797 jws.');
    }
    const [encodedHeader, encodedSignature] = jws.split('..');
    const header = JSON.parse(base64url.decode(encodedHeader));
    if (header.alg !== 'ES256K') {
        throw new Error('JWS alg is not signed with ES256K.');
    }
    if (header.b64 !== false ||
        !header.crit ||
        !header.crit.length ||
        header.crit[0] !== 'b64') {
        throw new Error('JWS Header is not in rfc7797 format (not detached).');
    }
    const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJWK(publicKeyJWK);
    const secp256k1 = await instantiateSecp256k1();
    const toBeSignedBuffer = Buffer.concat([
        Buffer.from(encodedHeader + '.', 'utf8'),
        Buffer.from(payload.buffer, payload.byteOffset, payload.length),
    ]);
    const message = Buffer.from(toBeSignedBuffer);
    const digest = crypto
        .createHash('sha256')
        .update(message)
        .digest()
        .toString('hex');
    const messageHashUInt8Array = hexToBin(digest);
    const signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));
    const verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);
    if (verified) {
        return true;
    }
    throw new Error('Cannot verify detached signature.');
};
/** Produce a normal ES256K JWS */
const sign = async (payload, privateKeyJWK, header = { alg: 'ES256K' }) => {
    const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJWK(privateKeyJWK);
    const secp256k1 = await instantiateSecp256k1();
    const encodedHeader = base64url.encode(JSON.stringify(header));
    const encodedPayload = base64url.encode(JSON.stringify(payload));
    const toBeSigned = `${encodedHeader}.${encodedPayload}`;
    const message = Buffer.from(toBeSigned);
    const digest = crypto
        .createHash('sha256')
        .update(message)
        .digest()
        .toString('hex');
    const messageHashUInt8Array = hexToBin(digest);
    const signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);
    const signatureHex = binToHex(signatureUInt8Array);
    const encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));
    return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
};
/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */
const verify = async (jws, publicKeyJWK) => {
    const secp256k1 = await instantiateSecp256k1();
    const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJWK(publicKeyJWK);
    const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');
    const toBeSigned = `${encodedHeader}.${encodedPayload}`;
    const message = Buffer.from(toBeSigned);
    const digest = crypto
        .createHash('sha256')
        .update(message)
        .digest()
        .toString('hex');
    const messageHashUInt8Array = hexToBin(digest);
    const signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));
    const verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);
    if (verified) {
        return JSON.parse(base64url.decode(encodedPayload));
    }
    throw new JWSVerificationFailed('signature verification failed');
};
/** decode a JWS (without verifying it) */
const decode = (jws, options = { complete: false }) => {
    const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');
    if (options.complete) {
        return {
            header: JSON.parse(base64url.decode(encodedHeader)),
            payload: JSON.parse(base64url.decode(encodedPayload)),
            signature: encodedSignature,
        };
    }
    return JSON.parse(base64url.decode(encodedPayload));
};
var JWS = {
    decode,
    sign,
    signDetached,
    verify,
    verifyDetached,
};

/** default expiration in hours added automatically */
const defaultExpiresInHours = 1;
class JWTVerificationFailed extends Error {
    constructor(message) {
        super(message);
        this.name = 'JWTVerificationFailed';
    }
}
/** return a JWT singed with ES256K JWS */
const sign$1 = async (payload, privateKeyJWK) => {
    const iat = Math.floor(Date.now() / 1000);
    const exp = iat + 60 * 60 * defaultExpiresInHours;
    return JWS.sign({
        ...payload,
        exp: payload.exp || exp,
        iat,
    }, privateKeyJWK, {
        alg: 'ES256K',
        kid: privateKeyJWK.kid,
    });
};
/** verify a JWT singed with ES256K JWS */
const verify$1 = async (jwt, publicKeyJWK) => {
    const verified = await JWS.verify(jwt, publicKeyJWK);
    if (Math.floor(Date.now() / 1000) > verified.exp) {
        throw new JWTVerificationFailed('token is expired');
    }
    return verified;
};
var JWT = { sign: sign$1, decode: JWS.decode, verify: verify$1 };

export { JWS, JWT, keyUtils };
//# sourceMappingURL=index.esm.js.map

import e from"base64url";import{binToHex as r,hexToBin as t,instantiateSecp256k1 as o}from"bitcoin-ts";import i from"crypto";import a from"@trust/keyto";import n from"json-stringify-deterministic";const c=r=>{const t={...r};delete t.d,delete t.kid,delete t.alg;const o=i.createHash("sha256").update(n(t)).digest();return e.encode(Buffer.from(o))},s=async e=>a.from({...e,crv:"K-256"},"jwk").toString("blk","private"),f=async e=>{const i=await o(),n=a.from({...e,crv:"K-256"},"jwk").toString("blk","public"),c=i.compressPublicKey(t(n));return r(c)},d=async e=>{const r=await s(e);return t(r)},u=async e=>{const r=await f(e);return t(r)};var p={binToHex:r,getKid:c,hexToBin:t,privateJWKFromPrivateKeyHex:async e=>{const r={...a.from(e,"blk").toJwk("private"),crv:"secp256k1"},t=c(r);return{...r,kid:t}},privateJWKFromPrivateKeyPem:e=>{const r={...a.from(e,"pem").toJwk("private"),crv:"secp256k1"},t=c(r);return{...r,kid:t}},privateKeyHexFromJWK:s,privateKeyUInt8ArrayFromJWK:d,publicJWKFromPublicKeyHex:async e=>{const i=await o();let n=e;66===e.length&&(n=r(i.uncompressPublicKey(t(e))));const s={...a.from(n,"blk").toJwk("public"),crv:"secp256k1"},f=c(s);return{...s,kid:f}},publicJWKFromPublicKeyPem:e=>{const r={...a.from(e,"pem").toJwk("public"),crv:"secp256k1"},t=c(r);return{...r,kid:t}},publicKeyHexFromJWK:f,publicKeyUInt8ArrayFromJWK:u};class m extends Error{constructor(e){super(e),this.name="JWSVerificationFailed"}}var l={decode:(r,t={complete:!1})=>{const[o,i,a]=r.split(".");return t.complete?{header:JSON.parse(e.decode(o)),payload:JSON.parse(e.decode(i)),signature:a}:JSON.parse(e.decode(i))},sign:async(a,n,c={alg:"ES256K"})=>{const s=await d(n),f=await o(),u=e.encode(JSON.stringify(c)),p=e.encode(JSON.stringify(a)),m=`${u}.${p}`,l=Buffer.from(m),g=i.createHash("sha256").update(l).digest().toString("hex"),h=t(g),y=f.signMessageHashCompact(s,h),w=r(y);return`${u}.${p}.${e.encode(Buffer.from(w,"hex"))}`},signDetached:async(a,n,c={alg:"ES256K",b64:!1,crit:["b64"]})=>{const s=await d(n),f=await o(),u=e.encode(JSON.stringify(c)),p=Buffer.concat([Buffer.from(u+".","utf8"),Buffer.from(a.buffer,a.byteOffset,a.length)]),m=Buffer.from(p),l=i.createHash("sha256").update(m).digest().toString("hex"),g=t(l),h=f.signMessageHashCompact(s,g),y=r(h);return`${u}..${e.encode(Buffer.from(y,"hex"))}`},verify:async(r,a)=>{const n=await o(),c=await u(a),[s,f,d]=r.split("."),p=`${s}.${f}`,l=Buffer.from(p),g=i.createHash("sha256").update(l).digest().toString("hex"),h=t(g),y=t(e.toBuffer(d).toString("hex"));if(n.verifySignatureCompact(y,c,h))return JSON.parse(e.decode(f));throw new m("signature verification failed")},verifyDetached:async(r,a,n)=>{if(-1===r.indexOf(".."))throw new m("not a valid rfc7797 jws.");const[c,s]=r.split(".."),f=JSON.parse(e.decode(c));if("ES256K"!==f.alg)throw new Error("JWS alg is not signed with ES256K.");if(!1!==f.b64||!f.crit||!f.crit.length||"b64"!==f.crit[0])throw new Error("JWS Header is not in rfc7797 format (not detached).");const d=await u(n),p=await o(),l=Buffer.concat([Buffer.from(c+".","utf8"),Buffer.from(a.buffer,a.byteOffset,a.length)]),g=Buffer.from(l),h=i.createHash("sha256").update(g).digest().toString("hex"),y=t(h),w=t(e.toBuffer(s).toString("hex"));if(p.verifySignatureCompact(w,d,y))return!0;throw new Error("Cannot verify detached signature.")}};class g extends Error{constructor(e){super(e),this.name="JWTVerificationFailed"}}var h={sign:async(e,r)=>{const t=Math.floor(Date.now()/1e3),o=t+3600;return l.sign({...e,exp:e.exp||o,iat:t},r,{alg:"ES256K",kid:r.kid})},decode:l.decode,verify:async(e,r)=>{const t=await l.verify(e,r);if(Math.floor(Date.now()/1e3)>t.exp)throw new g("token is expired");return t}};export{l as JWS,h as JWT,p as keyUtils};
//# sourceMappingURL=index.esm.min.js.map

{"version":3,"file":"index.umd.min.js","sources":["../../src/keyUtils.ts","../../src/JWS.ts","../../src/JWT.ts"],"sourcesContent":["import keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\n\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\n\nimport stringify from 'json-stringify-deterministic';\n\nconst compressedHexEncodedPublicKeyLength = 66;\n\n/** Secp256k1 Private Key JWK  */\nexport interface ISecp256k1PrivateKeyJWK {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** private point */\n  d: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/** Secp256k1 Public Key JWK  */\nexport interface ISecp256k1PublicJWK {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.\n */\nexport const getKid = (jwk: ISecp256k1PrivateKeyJWK | ISecp256k1PublicJWK) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(stringify(copy))\n    .digest();\n\n  return base64url.encode(Buffer.from(digest));\n};\n\n/** convert compressed hex encoded private key to jwk */\nexport const privateJWKFromPrivateKeyHex = async (privateKeyHex: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert compressed hex encoded public key to jwk */\nexport const publicJWKFromPublicKeyHex = async (publicKeyHex: string) => {\n  const secp256k1 = await instantiateSecp256k1();\n  let key = publicKeyHex;\n  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n    key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));\n  }\n  const jwk = {\n    ...keyto.from(key, 'blk').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const privateJWKFromPrivateKeyPem = (privateKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyPem, 'pem').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  // console.log(jwk);\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const publicJWKFromPublicKeyPem = (publicKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(publicKeyPem, 'pem').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert jwk to hex encoded private key */\nexport const privateKeyHexFromJWK = async (jwk: ISecp256k1PrivateKeyJWK) =>\n  keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'private');\n\n/** convert jwk to hex encoded public key */\nexport const publicKeyHexFromJWK = async (jwk: ISecp256k1PublicJWK) => {\n  const secp256k1 = await instantiateSecp256k1();\n  const uncompressedPublicKey = keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'public');\n  const compressed = secp256k1.compressPublicKey(\n    hexToBin(uncompressedPublicKey)\n  );\n  return binToHex(compressed);\n};\n\n/** convert jwk to binary encoded private key */\nexport const privateKeyUInt8ArrayFromJWK = async (\n  jwk: ISecp256k1PrivateKeyJWK\n) => {\n  const privateKeyHex = await privateKeyHexFromJWK(jwk);\n  return hexToBin(privateKeyHex);\n};\n\n/** convert jwk to binary encoded public key */\nexport const publicKeyUInt8ArrayFromJWK = async (jwk: ISecp256k1PublicJWK) => {\n  const publicKeyHex = await publicKeyHexFromJWK(jwk);\n  return hexToBin(publicKeyHex);\n};\n\nexport default {\n  binToHex,\n  getKid,\n  hexToBin,\n  privateJWKFromPrivateKeyHex,\n  privateJWKFromPrivateKeyPem,\n  privateKeyHexFromJWK,\n  privateKeyUInt8ArrayFromJWK,\n  publicJWKFromPublicKeyHex,\n  publicJWKFromPublicKeyPem,\n  publicKeyHexFromJWK,\n  publicKeyUInt8ArrayFromJWK,\n};\n","import base64url from 'base64url';\n\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\n\nimport crypto from 'crypto';\n\nimport {\n  ISecp256k1PrivateKeyJWK,\n  ISecp256k1PublicJWK,\n  privateKeyUInt8ArrayFromJWK,\n  publicKeyUInt8ArrayFromJWK,\n} from './keyUtils';\n\n/** error matching @panva/jose for JWS verification failure. */\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\n/** JWS Header */\nexport interface IJWSHeader {\n  /** algorithm, ES256K */\n  alg: string;\n\n  /** type, JWT */\n  typ?: string;\n  /** signing key id, ... */\n  kid?: string;\n}\n\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const signDetached = async (\n  // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\n  payload: Buffer,\n  privateKeyJWK: ISecp256k1PrivateKeyJWK,\n  header = {\n    alg: 'ES256K',\n    b64: false,\n    crit: ['b64'],\n  }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJWK(privateKeyJWK);\n  const secp256k1 = await instantiateSecp256k1();\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n\n  const messageHashUInt8Array = hexToBin(digest);\n\n  const signatureUInt8Array = secp256k1.signMessageHashCompact(\n    privateKeyUInt8Array,\n    messageHashUInt8Array\n  );\n\n  const signatureHex = binToHex(signatureUInt8Array);\n  const encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const verifyDetached = async (\n  jws: string,\n  payload: Buffer,\n  publicKeyJWK: ISecp256k1PublicJWK\n) => {\n  if (jws.indexOf('..') === -1) {\n    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K') {\n    throw new Error('JWS alg is not signed with ES256K.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJWK(publicKeyJWK);\n  const secp256k1 = await instantiateSecp256k1();\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n  const messageHashUInt8Array = hexToBin(digest);\n  const signatureUInt8Array = hexToBin(\n    base64url.toBuffer(encodedSignature).toString('hex')\n  );\n  const verified = secp256k1.verifySignatureCompact(\n    signatureUInt8Array,\n    publicKeyUInt8Array,\n    messageHashUInt8Array\n  );\n  if (verified) {\n    return true;\n  }\n  throw new Error('Cannot verify detached signature.');\n};\n\n/** Produce a normal ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJWK: ISecp256k1PrivateKeyJWK,\n  header: IJWSHeader = { alg: 'ES256K' }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJWK(privateKeyJWK);\n  const secp256k1 = await instantiateSecp256k1();\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n  const messageHashUInt8Array = hexToBin(digest);\n  const signatureUInt8Array = secp256k1.signMessageHashCompact(\n    privateKeyUInt8Array,\n    messageHashUInt8Array\n  );\n  const signatureHex = binToHex(signatureUInt8Array);\n  const encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport const verify = async (\n  jws: string,\n  publicKeyJWK: ISecp256k1PublicJWK\n) => {\n  const secp256k1 = await instantiateSecp256k1();\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJWK(publicKeyJWK);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n\n  const messageHashUInt8Array = hexToBin(digest);\n\n  const signatureUInt8Array = hexToBin(\n    base64url.toBuffer(encodedSignature).toString('hex')\n  );\n\n  const verified = secp256k1.verifySignatureCompact(\n    signatureUInt8Array,\n    publicKeyUInt8Array,\n    messageHashUInt8Array\n  );\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n  throw new JWSVerificationFailed('signature verification failed');\n};\n\n/** decode a JWS (without verifying it) */\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n\nexport default {\n  decode,\n\n  sign,\n  signDetached,\n\n  verify,\n  verifyDetached,\n};\n","import JWS from './JWS';\n\nimport { ISecp256k1PrivateKeyJWK, ISecp256k1PublicJWK } from './keyUtils';\n\n/** default expiration in hours added automatically */\nconst defaultExpiresInHours = 1;\n\nclass JWTVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWTVerificationFailed';\n  }\n}\n\n/** return a JWT singed with ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJWK: ISecp256k1PrivateKeyJWK\n) => {\n  const iat = Math.floor(Date.now() / 1000);\n\n  const exp = iat + 60 * 60 * defaultExpiresInHours;\n\n  return JWS.sign(\n    {\n      ...payload,\n      exp: payload.exp || exp,\n      iat,\n    },\n    privateKeyJWK,\n    {\n      alg: 'ES256K',\n      kid: privateKeyJWK.kid,\n    }\n  );\n};\n\n/** verify a JWT singed with ES256K JWS */\nexport const verify = async (\n  jwt: string,\n  publicKeyJWK: ISecp256k1PublicJWK\n) => {\n  const verified = await JWS.verify(jwt, publicKeyJWK);\n  if (Math.floor(Date.now() / 1000) > verified.exp) {\n    throw new JWTVerificationFailed('token is expired');\n  }\n  return verified;\n};\n\nexport default { sign, decode: JWS.decode, verify };\n"],"names":["getKid","jwk","copy","__assign","d","kid","alg","digest","crypto","createHash","update","stringify","base64url","encode","Buffer","from","privateKeyHexFromJWK","keyto","crv","toString","publicKeyHexFromJWK","instantiateSecp256k1","secp256k1","_a","uncompressedPublicKey","compressed","compressPublicKey","hexToBin","binToHex","privateKeyUInt8ArrayFromJWK","privateKeyHex","publicKeyUInt8ArrayFromJWK","publicKeyHex","privateJWKFromPrivateKeyHex","toJwk","privateJWKFromPrivateKeyPem","privateKeyPem","publicJWKFromPublicKeyHex","key","length","uncompressPublicKey","publicJWKFromPublicKeyPem","publicKeyPem","message","_super","_this","name","__extends","Error","decode","jws","options","complete","encodedHeader","encodedPayload","encodedSignature","header","JSON","parse","payload","signature","sign","privateKeyJWK","privateKeyUInt8Array","toBeSigned","messageHashUInt8Array","signatureUInt8Array","signMessageHashCompact","signatureHex","signDetached","b64","crit","toBeSignedBuffer","concat","buffer","byteOffset","verify","publicKeyJWK","_b","publicKeyUInt8Array","split","toBuffer","verifySignatureCompact","JWSVerificationFailed","verifyDetached","indexOf","iat","Math","floor","Date","now","exp","JWS","jwt","verified","JWTVerificationFailed"],"mappings":"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"}
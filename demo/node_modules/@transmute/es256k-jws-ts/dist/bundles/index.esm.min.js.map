{"version":3,"file":"index.esm.min.js","sources":["../../src/keyUtils.ts","../../src/JWS.ts","../../src/JWT.ts"],"sourcesContent":["import keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\n\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\n\nimport stringify from 'json-stringify-deterministic';\n\nconst compressedHexEncodedPublicKeyLength = 66;\n\n/** Secp256k1 Private Key JWK  */\nexport interface ISecp256k1PrivateKeyJWK {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** private point */\n  d: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/** Secp256k1 Public Key JWK  */\nexport interface ISecp256k1PublicJWK {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.\n */\nexport const getKid = (jwk: ISecp256k1PrivateKeyJWK | ISecp256k1PublicJWK) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(stringify(copy))\n    .digest();\n\n  return base64url.encode(Buffer.from(digest));\n};\n\n/** convert compressed hex encoded private key to jwk */\nexport const privateJWKFromPrivateKeyHex = async (privateKeyHex: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert compressed hex encoded public key to jwk */\nexport const publicJWKFromPublicKeyHex = async (publicKeyHex: string) => {\n  const secp256k1 = await instantiateSecp256k1();\n  let key = publicKeyHex;\n  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n    key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));\n  }\n  const jwk = {\n    ...keyto.from(key, 'blk').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const privateJWKFromPrivateKeyPem = (privateKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyPem, 'pem').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  // console.log(jwk);\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const publicJWKFromPublicKeyPem = (publicKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(publicKeyPem, 'pem').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert jwk to hex encoded private key */\nexport const privateKeyHexFromJWK = async (jwk: ISecp256k1PrivateKeyJWK) =>\n  keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'private');\n\n/** convert jwk to hex encoded public key */\nexport const publicKeyHexFromJWK = async (jwk: ISecp256k1PublicJWK) => {\n  const secp256k1 = await instantiateSecp256k1();\n  const uncompressedPublicKey = keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'public');\n  const compressed = secp256k1.compressPublicKey(\n    hexToBin(uncompressedPublicKey)\n  );\n  return binToHex(compressed);\n};\n\n/** convert jwk to binary encoded private key */\nexport const privateKeyUInt8ArrayFromJWK = async (\n  jwk: ISecp256k1PrivateKeyJWK\n) => {\n  const privateKeyHex = await privateKeyHexFromJWK(jwk);\n  return hexToBin(privateKeyHex);\n};\n\n/** convert jwk to binary encoded public key */\nexport const publicKeyUInt8ArrayFromJWK = async (jwk: ISecp256k1PublicJWK) => {\n  const publicKeyHex = await publicKeyHexFromJWK(jwk);\n  return hexToBin(publicKeyHex);\n};\n\nexport default {\n  binToHex,\n  getKid,\n  hexToBin,\n  privateJWKFromPrivateKeyHex,\n  privateJWKFromPrivateKeyPem,\n  privateKeyHexFromJWK,\n  privateKeyUInt8ArrayFromJWK,\n  publicJWKFromPublicKeyHex,\n  publicJWKFromPublicKeyPem,\n  publicKeyHexFromJWK,\n  publicKeyUInt8ArrayFromJWK,\n};\n","import base64url from 'base64url';\n\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\n\nimport crypto from 'crypto';\n\nimport {\n  ISecp256k1PrivateKeyJWK,\n  ISecp256k1PublicJWK,\n  privateKeyUInt8ArrayFromJWK,\n  publicKeyUInt8ArrayFromJWK,\n} from './keyUtils';\n\n/** error matching @panva/jose for JWS verification failure. */\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\n/** JWS Header */\nexport interface IJWSHeader {\n  /** algorithm, ES256K */\n  alg: string;\n\n  /** type, JWT */\n  typ?: string;\n  /** signing key id, ... */\n  kid?: string;\n}\n\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const signDetached = async (\n  // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\n  payload: Buffer,\n  privateKeyJWK: ISecp256k1PrivateKeyJWK,\n  header = {\n    alg: 'ES256K',\n    b64: false,\n    crit: ['b64'],\n  }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJWK(privateKeyJWK);\n  const secp256k1 = await instantiateSecp256k1();\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n\n  const messageHashUInt8Array = hexToBin(digest);\n\n  const signatureUInt8Array = secp256k1.signMessageHashCompact(\n    privateKeyUInt8Array,\n    messageHashUInt8Array\n  );\n\n  const signatureHex = binToHex(signatureUInt8Array);\n  const encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const verifyDetached = async (\n  jws: string,\n  payload: Buffer,\n  publicKeyJWK: ISecp256k1PublicJWK\n) => {\n  if (jws.indexOf('..') === -1) {\n    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K') {\n    throw new Error('JWS alg is not signed with ES256K.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJWK(publicKeyJWK);\n  const secp256k1 = await instantiateSecp256k1();\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n  const messageHashUInt8Array = hexToBin(digest);\n  const signatureUInt8Array = hexToBin(\n    base64url.toBuffer(encodedSignature).toString('hex')\n  );\n  const verified = secp256k1.verifySignatureCompact(\n    signatureUInt8Array,\n    publicKeyUInt8Array,\n    messageHashUInt8Array\n  );\n  if (verified) {\n    return true;\n  }\n  throw new Error('Cannot verify detached signature.');\n};\n\n/** Produce a normal ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJWK: ISecp256k1PrivateKeyJWK,\n  header: IJWSHeader = { alg: 'ES256K' }\n) => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJWK(privateKeyJWK);\n  const secp256k1 = await instantiateSecp256k1();\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n  const messageHashUInt8Array = hexToBin(digest);\n  const signatureUInt8Array = secp256k1.signMessageHashCompact(\n    privateKeyUInt8Array,\n    messageHashUInt8Array\n  );\n  const signatureHex = binToHex(signatureUInt8Array);\n  const encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport const verify = async (\n  jws: string,\n  publicKeyJWK: ISecp256k1PublicJWK\n) => {\n  const secp256k1 = await instantiateSecp256k1();\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJWK(publicKeyJWK);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest()\n    .toString('hex');\n\n  const messageHashUInt8Array = hexToBin(digest);\n\n  const signatureUInt8Array = hexToBin(\n    base64url.toBuffer(encodedSignature).toString('hex')\n  );\n\n  const verified = secp256k1.verifySignatureCompact(\n    signatureUInt8Array,\n    publicKeyUInt8Array,\n    messageHashUInt8Array\n  );\n  if (verified) {\n    return JSON.parse(base64url.decode(encodedPayload));\n  }\n  throw new JWSVerificationFailed('signature verification failed');\n};\n\n/** decode a JWS (without verifying it) */\nexport const decode = (jws: string, options = { complete: false }) => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n\nexport default {\n  decode,\n\n  sign,\n  signDetached,\n\n  verify,\n  verifyDetached,\n};\n","import JWS from './JWS';\n\nimport { ISecp256k1PrivateKeyJWK, ISecp256k1PublicJWK } from './keyUtils';\n\n/** default expiration in hours added automatically */\nconst defaultExpiresInHours = 1;\n\nclass JWTVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWTVerificationFailed';\n  }\n}\n\n/** return a JWT singed with ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJWK: ISecp256k1PrivateKeyJWK\n) => {\n  const iat = Math.floor(Date.now() / 1000);\n\n  const exp = iat + 60 * 60 * defaultExpiresInHours;\n\n  return JWS.sign(\n    {\n      ...payload,\n      exp: payload.exp || exp,\n      iat,\n    },\n    privateKeyJWK,\n    {\n      alg: 'ES256K',\n      kid: privateKeyJWK.kid,\n    }\n  );\n};\n\n/** verify a JWT singed with ES256K JWS */\nexport const verify = async (\n  jwt: string,\n  publicKeyJWK: ISecp256k1PublicJWK\n) => {\n  const verified = await JWS.verify(jwt, publicKeyJWK);\n  if (Math.floor(Date.now() / 1000) > verified.exp) {\n    throw new JWTVerificationFailed('token is expired');\n  }\n  return verified;\n};\n\nexport default { sign, decode: JWS.decode, verify };\n"],"names":["getKid","jwk","copy","d","kid","alg","digest","crypto","createHash","update","stringify","base64url","encode","Buffer","from","privateKeyHexFromJWK","async","keyto","crv","toString","publicKeyHexFromJWK","secp256k1","instantiateSecp256k1","uncompressedPublicKey","compressed","compressPublicKey","hexToBin","binToHex","privateKeyUInt8ArrayFromJWK","privateKeyHex","publicKeyUInt8ArrayFromJWK","publicKeyHex","privateJWKFromPrivateKeyHex","toJwk","privateJWKFromPrivateKeyPem","privateKeyPem","publicJWKFromPublicKeyHex","key","length","uncompressPublicKey","publicJWKFromPublicKeyPem","publicKeyPem","JWSVerificationFailed","Error","[object Object]","message","super","this","name","decode","jws","options","complete","encodedHeader","encodedPayload","encodedSignature","split","header","JSON","parse","payload","signature","sign","privateKeyJWK","privateKeyUInt8Array","toBeSigned","messageHashUInt8Array","signatureUInt8Array","signMessageHashCompact","signatureHex","signDetached","b64","crit","toBeSignedBuffer","concat","buffer","byteOffset","verify","publicKeyJWK","publicKeyUInt8Array","toBuffer","verifySignatureCompact","verifyDetached","indexOf","JWTVerificationFailed","iat","Math","floor","Date","now","exp","JWS","jwt","verified"],"mappings":"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"}
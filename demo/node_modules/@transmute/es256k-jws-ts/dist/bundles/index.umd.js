(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('base64url'), require('bitcoin-ts'), require('crypto'), require('@trust/keyto'), require('json-stringify-deterministic')) :
    typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'base64url', 'bitcoin-ts', 'crypto', '@trust/keyto', 'json-stringify-deterministic'], factory) :
    (global = global || self, factory(global.Es256kJwsTs = {}, global.tslib, global.base64url, global.BitcoinTS, global.crypto, global.keyto, global.stringify));
}(this, function (exports, tslib, base64url, bitcoinTs, crypto, keyto, stringify) { 'use strict';

    base64url = base64url && base64url.hasOwnProperty('default') ? base64url['default'] : base64url;
    crypto = crypto && crypto.hasOwnProperty('default') ? crypto['default'] : crypto;
    keyto = keyto && keyto.hasOwnProperty('default') ? keyto['default'] : keyto;
    stringify = stringify && stringify.hasOwnProperty('default') ? stringify['default'] : stringify;

    var compressedHexEncodedPublicKeyLength = 66;
    /**
     * Example
     * ```js
     * {
     *  kty: 'EC',
     *  crv: 'secp256k1',
     *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',
     *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',
     *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',
     *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'
     * }
     * ```
     * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.
     */
    var getKid = function (jwk) {
        var copy = tslib.__assign({}, jwk);
        delete copy.d;
        delete copy.kid;
        delete copy.alg;
        var digest = crypto
            .createHash('sha256')
            .update(stringify(copy))
            .digest();
        return base64url.encode(Buffer.from(digest));
    };
    /** convert compressed hex encoded private key to jwk */
    var privateJWKFromPrivateKeyHex = function (privateKeyHex) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var jwk, kid;
        return tslib.__generator(this, function (_a) {
            jwk = tslib.__assign(tslib.__assign({}, keyto.from(privateKeyHex, 'blk').toJwk('private')), { crv: 'secp256k1' });
            kid = getKid(jwk);
            return [2 /*return*/, tslib.__assign(tslib.__assign({}, jwk), { kid: kid })];
        });
    }); };
    /** convert compressed hex encoded public key to jwk */
    var publicJWKFromPublicKeyHex = function (publicKeyHex) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var secp256k1, key, jwk, kid;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, bitcoinTs.instantiateSecp256k1()];
                case 1:
                    secp256k1 = _a.sent();
                    key = publicKeyHex;
                    if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {
                        key = bitcoinTs.binToHex(secp256k1.uncompressPublicKey(bitcoinTs.hexToBin(publicKeyHex)));
                    }
                    jwk = tslib.__assign(tslib.__assign({}, keyto.from(key, 'blk').toJwk('public')), { crv: 'secp256k1' });
                    kid = getKid(jwk);
                    return [2 /*return*/, tslib.__assign(tslib.__assign({}, jwk), { kid: kid })];
            }
        });
    }); };
    /** convert pem encoded private key to jwk */
    var privateJWKFromPrivateKeyPem = function (privateKeyPem) {
        var jwk = tslib.__assign(tslib.__assign({}, keyto.from(privateKeyPem, 'pem').toJwk('private')), { crv: 'secp256k1' });
        // console.log(jwk);
        var kid = getKid(jwk);
        return tslib.__assign(tslib.__assign({}, jwk), { kid: kid });
    };
    /** convert pem encoded private key to jwk */
    var publicJWKFromPublicKeyPem = function (publicKeyPem) {
        var jwk = tslib.__assign(tslib.__assign({}, keyto.from(publicKeyPem, 'pem').toJwk('public')), { crv: 'secp256k1' });
        var kid = getKid(jwk);
        return tslib.__assign(tslib.__assign({}, jwk), { kid: kid });
    };
    /** convert jwk to hex encoded private key */
    var privateKeyHexFromJWK = function (jwk) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            return [2 /*return*/, keyto
                    .from(tslib.__assign(tslib.__assign({}, jwk), { crv: 'K-256' }), 'jwk')
                    .toString('blk', 'private')];
        });
    }); };
    /** convert jwk to hex encoded public key */
    var publicKeyHexFromJWK = function (jwk) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var secp256k1, uncompressedPublicKey, compressed;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, bitcoinTs.instantiateSecp256k1()];
                case 1:
                    secp256k1 = _a.sent();
                    uncompressedPublicKey = keyto
                        .from(tslib.__assign(tslib.__assign({}, jwk), { crv: 'K-256' }), 'jwk')
                        .toString('blk', 'public');
                    compressed = secp256k1.compressPublicKey(bitcoinTs.hexToBin(uncompressedPublicKey));
                    return [2 /*return*/, bitcoinTs.binToHex(compressed)];
            }
        });
    }); };
    /** convert jwk to binary encoded private key */
    var privateKeyUInt8ArrayFromJWK = function (jwk) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var privateKeyHex;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, privateKeyHexFromJWK(jwk)];
                case 1:
                    privateKeyHex = _a.sent();
                    return [2 /*return*/, bitcoinTs.hexToBin(privateKeyHex)];
            }
        });
    }); };
    /** convert jwk to binary encoded public key */
    var publicKeyUInt8ArrayFromJWK = function (jwk) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var publicKeyHex;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, publicKeyHexFromJWK(jwk)];
                case 1:
                    publicKeyHex = _a.sent();
                    return [2 /*return*/, bitcoinTs.hexToBin(publicKeyHex)];
            }
        });
    }); };
    var keyUtils = {
        binToHex: bitcoinTs.binToHex,
        getKid: getKid,
        hexToBin: bitcoinTs.hexToBin,
        privateJWKFromPrivateKeyHex: privateJWKFromPrivateKeyHex,
        privateJWKFromPrivateKeyPem: privateJWKFromPrivateKeyPem,
        privateKeyHexFromJWK: privateKeyHexFromJWK,
        privateKeyUInt8ArrayFromJWK: privateKeyUInt8ArrayFromJWK,
        publicJWKFromPublicKeyHex: publicJWKFromPublicKeyHex,
        publicJWKFromPublicKeyPem: publicJWKFromPublicKeyPem,
        publicKeyHexFromJWK: publicKeyHexFromJWK,
        publicKeyUInt8ArrayFromJWK: publicKeyUInt8ArrayFromJWK,
    };

    /** error matching @panva/jose for JWS verification failure. */
    var JWSVerificationFailed = /** @class */ (function (_super) {
        tslib.__extends(JWSVerificationFailed, _super);
        function JWSVerificationFailed(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'JWSVerificationFailed';
            return _this;
        }
        return JWSVerificationFailed;
    }(Error));
    /** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
    var signDetached = function (
    // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData
    payload, privateKeyJWK, header) {
        if (header === void 0) { header = {
            alg: 'ES256K',
            b64: false,
            crit: ['b64'],
        }; }
        return tslib.__awaiter(void 0, void 0, void 0, function () {
            var privateKeyUInt8Array, secp256k1, encodedHeader, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, privateKeyUInt8ArrayFromJWK(privateKeyJWK)];
                    case 1:
                        privateKeyUInt8Array = _a.sent();
                        return [4 /*yield*/, bitcoinTs.instantiateSecp256k1()];
                    case 2:
                        secp256k1 = _a.sent();
                        encodedHeader = base64url.encode(JSON.stringify(header));
                        toBeSignedBuffer = Buffer.concat([
                            Buffer.from(encodedHeader + '.', 'utf8'),
                            Buffer.from(payload.buffer, payload.byteOffset, payload.length),
                        ]);
                        message = Buffer.from(toBeSignedBuffer);
                        digest = crypto
                            .createHash('sha256')
                            .update(message)
                            .digest()
                            .toString('hex');
                        messageHashUInt8Array = bitcoinTs.hexToBin(digest);
                        signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);
                        signatureHex = bitcoinTs.binToHex(signatureUInt8Array);
                        encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));
                        return [2 /*return*/, encodedHeader + ".." + encodedSignature];
                }
            });
        });
    };
    /** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */
    var verifyDetached = function (jws, payload, publicKeyJWK) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var _a, encodedHeader, encodedSignature, header, publicKeyUInt8Array, secp256k1, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (jws.indexOf('..') === -1) {
                        throw new JWSVerificationFailed('not a valid rfc7797 jws.');
                    }
                    _a = jws.split('..'), encodedHeader = _a[0], encodedSignature = _a[1];
                    header = JSON.parse(base64url.decode(encodedHeader));
                    if (header.alg !== 'ES256K') {
                        throw new Error('JWS alg is not signed with ES256K.');
                    }
                    if (header.b64 !== false ||
                        !header.crit ||
                        !header.crit.length ||
                        header.crit[0] !== 'b64') {
                        throw new Error('JWS Header is not in rfc7797 format (not detached).');
                    }
                    return [4 /*yield*/, publicKeyUInt8ArrayFromJWK(publicKeyJWK)];
                case 1:
                    publicKeyUInt8Array = _b.sent();
                    return [4 /*yield*/, bitcoinTs.instantiateSecp256k1()];
                case 2:
                    secp256k1 = _b.sent();
                    toBeSignedBuffer = Buffer.concat([
                        Buffer.from(encodedHeader + '.', 'utf8'),
                        Buffer.from(payload.buffer, payload.byteOffset, payload.length),
                    ]);
                    message = Buffer.from(toBeSignedBuffer);
                    digest = crypto
                        .createHash('sha256')
                        .update(message)
                        .digest()
                        .toString('hex');
                    messageHashUInt8Array = bitcoinTs.hexToBin(digest);
                    signatureUInt8Array = bitcoinTs.hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));
                    verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);
                    if (verified) {
                        return [2 /*return*/, true];
                    }
                    throw new Error('Cannot verify detached signature.');
            }
        });
    }); };
    /** Produce a normal ES256K JWS */
    var sign = function (payload, privateKeyJWK, header) {
        if (header === void 0) { header = { alg: 'ES256K' }; }
        return tslib.__awaiter(void 0, void 0, void 0, function () {
            var privateKeyUInt8Array, secp256k1, encodedHeader, encodedPayload, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, privateKeyUInt8ArrayFromJWK(privateKeyJWK)];
                    case 1:
                        privateKeyUInt8Array = _a.sent();
                        return [4 /*yield*/, bitcoinTs.instantiateSecp256k1()];
                    case 2:
                        secp256k1 = _a.sent();
                        encodedHeader = base64url.encode(JSON.stringify(header));
                        encodedPayload = base64url.encode(JSON.stringify(payload));
                        toBeSigned = encodedHeader + "." + encodedPayload;
                        message = Buffer.from(toBeSigned);
                        digest = crypto
                            .createHash('sha256')
                            .update(message)
                            .digest()
                            .toString('hex');
                        messageHashUInt8Array = bitcoinTs.hexToBin(digest);
                        signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);
                        signatureHex = bitcoinTs.binToHex(signatureUInt8Array);
                        encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));
                        return [2 /*return*/, encodedHeader + "." + encodedPayload + "." + encodedSignature];
                }
            });
        });
    };
    /** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */
    var verify = function (jws, publicKeyJWK) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var secp256k1, publicKeyUInt8Array, _a, encodedHeader, encodedPayload, encodedSignature, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, bitcoinTs.instantiateSecp256k1()];
                case 1:
                    secp256k1 = _b.sent();
                    return [4 /*yield*/, publicKeyUInt8ArrayFromJWK(publicKeyJWK)];
                case 2:
                    publicKeyUInt8Array = _b.sent();
                    _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];
                    toBeSigned = encodedHeader + "." + encodedPayload;
                    message = Buffer.from(toBeSigned);
                    digest = crypto
                        .createHash('sha256')
                        .update(message)
                        .digest()
                        .toString('hex');
                    messageHashUInt8Array = bitcoinTs.hexToBin(digest);
                    signatureUInt8Array = bitcoinTs.hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));
                    verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);
                    if (verified) {
                        return [2 /*return*/, JSON.parse(base64url.decode(encodedPayload))];
                    }
                    throw new JWSVerificationFailed('signature verification failed');
            }
        });
    }); };
    /** decode a JWS (without verifying it) */
    var decode = function (jws, options) {
        if (options === void 0) { options = { complete: false }; }
        var _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];
        if (options.complete) {
            return {
                header: JSON.parse(base64url.decode(encodedHeader)),
                payload: JSON.parse(base64url.decode(encodedPayload)),
                signature: encodedSignature,
            };
        }
        return JSON.parse(base64url.decode(encodedPayload));
    };
    var JWS = {
        decode: decode,
        sign: sign,
        signDetached: signDetached,
        verify: verify,
        verifyDetached: verifyDetached,
    };

    /** default expiration in hours added automatically */
    var defaultExpiresInHours = 1;
    var JWTVerificationFailed = /** @class */ (function (_super) {
        tslib.__extends(JWTVerificationFailed, _super);
        function JWTVerificationFailed(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'JWTVerificationFailed';
            return _this;
        }
        return JWTVerificationFailed;
    }(Error));
    /** return a JWT singed with ES256K JWS */
    var sign$1 = function (payload, privateKeyJWK) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var iat, exp;
        return tslib.__generator(this, function (_a) {
            iat = Math.floor(Date.now() / 1000);
            exp = iat + 60 * 60 * defaultExpiresInHours;
            return [2 /*return*/, JWS.sign(tslib.__assign(tslib.__assign({}, payload), { exp: payload.exp || exp, iat: iat }), privateKeyJWK, {
                    alg: 'ES256K',
                    kid: privateKeyJWK.kid,
                })];
        });
    }); };
    /** verify a JWT singed with ES256K JWS */
    var verify$1 = function (jwt, publicKeyJWK) { return tslib.__awaiter(void 0, void 0, void 0, function () {
        var verified;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, JWS.verify(jwt, publicKeyJWK)];
                case 1:
                    verified = _a.sent();
                    if (Math.floor(Date.now() / 1000) > verified.exp) {
                        throw new JWTVerificationFailed('token is expired');
                    }
                    return [2 /*return*/, verified];
            }
        });
    }); };
    var JWT = { sign: sign$1, decode: JWS.decode, verify: verify$1 };

    exports.JWS = JWS;
    exports.JWT = JWT;
    exports.keyUtils = keyUtils;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.umd.js.map

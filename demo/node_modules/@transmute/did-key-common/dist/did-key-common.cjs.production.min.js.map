{"version":3,"file":"did-key-common.cjs.production.min.js","sources":["../src/Jws/index.ts","../src/getResolver.ts","../src/getGet.ts","../src/types/index.ts"],"sourcesContent":["import base64url from 'base64url';\nimport canonicalize from 'canonicalize';\n\nexport const createJws = async (signer: any, payload: any, header: object) => {\n  const encodedHeader = base64url.encode(canonicalize(header));\n  const encodedPayload = base64url.encode(canonicalize(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  return `${toBeSigned}.${base64url.encode(Buffer.from(signature))}`;\n};\n\nexport const verifyJws = async (verifier: any, jws: string) => {\n  const [header, payload, signature] = jws.split('.');\n  const toBeVerified = `${header}.${payload}`;\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(signature)\n  );\n\n  return verified;\n};\n\nexport const createDetachedJws = async (\n  signer: any,\n  payload: Buffer,\n  header: object\n) => {\n  const encodedHeader = base64url.encode(\n    canonicalize({ ...header, b64: false, crit: ['b64'] })\n  );\n\n  const toBeSigned = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n  const signature = await signer.sign(Buffer.from(toBeSigned));\n  const encodedSignature = base64url.encode(Buffer.from(signature));\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\nexport const verifyDetachedJws = async (\n  verifier: any,\n  payload: Buffer,\n  signature: string\n) => {\n  const [encodedHeader, encodedSignature] = signature.split('..');\n\n  const toBeVerified = new Uint8Array(\n    Buffer.concat([\n      Buffer.from(encodedHeader, 'utf-8'),\n      Buffer.from('.', 'utf-8'),\n      payload,\n    ])\n  );\n\n  const verified = await verifier.verify(\n    Buffer.from(toBeVerified),\n    base64url.toBuffer(encodedSignature)\n  );\n\n  return verified;\n};\n","const cbor = require('borc');\n\nexport const getVerificationMethod = (\n  instance: any,\n  contentType: string = 'application/did+ld+json'\n) => {\n  switch (contentType) {\n    case 'application/did+json': {\n      return instance.toJsonWebKeyPair();\n    }\n    case 'application/did+cbor': {\n      return instance.toJsonWebKeyPair();\n    }\n    case 'application/did+ld+json': {\n      return instance.toKeyPair();\n    }\n  }\n  throw new Error(\n    'This implementation of did:key does not support: ' + contentType\n  );\n};\n\nconst supportedContentTypes = [\n  'application/did+json',\n  'application/did+ld+json',\n  'application/did+cbor',\n];\n\nexport const keyToDidDoc = async (\n  didKeyPairInstance: any,\n  contentType: string = 'application/did+ld+json'\n) => {\n  if (supportedContentTypes.indexOf(contentType) === -1) {\n    throw new Error('Unsupported DID Document representation. ' + contentType);\n  }\n  const did = `did:key:${didKeyPairInstance.fingerprint()}`;\n  const externalKeyRepresentation = getVerificationMethod(\n    didKeyPairInstance,\n    contentType\n  );\n  let verificationRelationships: any = {\n    verificationMethod: [externalKeyRepresentation],\n  };\n\n  if (didKeyPairInstance.verifier) {\n    verificationRelationships = {\n      ...verificationRelationships,\n      authentication: [externalKeyRepresentation.id],\n      assertionMethod: [externalKeyRepresentation.id],\n      capabilityInvocation: [externalKeyRepresentation.id],\n      capabilityDelegation: [externalKeyRepresentation.id],\n    };\n  }\n\n  if (didKeyPairInstance.deriveSecret) {\n    verificationRelationships = {\n      ...verificationRelationships,\n      keyAgreement: [externalKeyRepresentation.id],\n    };\n  }\n\n  if (didKeyPairInstance.type === 'Ed25519VerificationKey2018') {\n    const kek = await didKeyPairInstance.toX25519KeyPair(false);\n    const externalKeyRepresentation2 = getVerificationMethod(kek, contentType);\n    verificationRelationships = {\n      ...verificationRelationships,\n      verificationMethod: [\n        ...verificationRelationships.verificationMethod,\n        externalKeyRepresentation2,\n      ],\n      keyAgreement: [externalKeyRepresentation2.id],\n    };\n  }\n  const didDocument = {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      'https://ns.did.ai/transmute/v1',\n      {\n        '@base': did,\n      },\n    ],\n    id: did,\n    ...verificationRelationships,\n  };\n\n  return didDocument;\n};\n\n// resolve ( did, did-resolution-input-metadata )\n//      -> ( did-resolution-metadata, did-document, did-document-metadata )\nexport const getResolve = (DidKeyPairClass: any) => {\n  const resolve = async (\n    didUri: string,\n    resolutionMetaData: any = { accept: 'application/did+ld+json' }\n  ) => {\n    const fingerprint = didUri\n      .split('#')[0]\n      .split('did:key:')\n      .pop();\n    const publicKey = await DidKeyPairClass.fromFingerprint({ fingerprint });\n    const didDocument = await keyToDidDoc(publicKey, resolutionMetaData.accept);\n\n    const didResolutionResponse = {\n      '@context': 'https://w3id.org/did-resolution/v1',\n      didDocument,\n      didDocumentMetadata: {\n        'content-type': resolutionMetaData.accept,\n      },\n      didResolutionMetadata: {},\n    };\n    if (resolutionMetaData.accept === 'application/did+cbor') {\n      return cbor.encode(didResolutionResponse);\n    }\n    return didResolutionResponse;\n  };\n  return resolve;\n};\n","export const getGet = (resolve: any) => {\n  const get = async ({ did, url }: any = {}) => {\n    did = did || url;\n    if (!did) {\n      throw new TypeError('\"did\" must be a string.');\n    }\n    const result = await resolve(did);\n    return result.didDocument;\n  };\n  return get;\n};\n","/* class decorator */\nexport const staticImplements = <T>() => {\n  return <U extends T>(constructor: U) => {\n    return constructor;\n  };\n};\n\nexport * from './JWE_ALG';\nexport * from './JWS_ALG';\n\nexport * from './KeyPairClass';\nexport * from './KeyPairInstance';\nexport * from './KeyAgreementKeyPairClass';\nexport * from './KeyPairGenerateOptions';\nexport * from './EpkResult';\nexport * from './KeyEncryptionKeyFromEphemeralPublicKeyOptions';\nexport * from './KeyEncryptionKeyFromStaticPublicKeyOptions';\nexport * from './DeriveSecretOptions';\n\nexport * from './KeyPairBase';\n\nexport * from './KeyPairJwk';\nexport * from './JsonWebKeyPair';\n\nexport * from './KeyPairBase58';\nexport * from './LinkedDataKeyPair';\n\nexport * from './KeyAgreementKeyPairInstance';\n"],"names":["signer","payload","header","toBeSigned","base64url","encode","canonicalize","sign","Buffer","from","signature","verifier","jws","split","verify","toBuffer","encodedHeader","b64","crit","Uint8Array","concat","encodedSignature","toBeVerified","cbor","require","getVerificationMethod","instance","contentType","toJsonWebKeyPair","toKeyPair","Error","supportedContentTypes","keyToDidDoc","didKeyPairInstance","did","id","verificationRelationships","indexOf","fingerprint","externalKeyRepresentation","verificationMethod","authentication","assertionMethod","capabilityInvocation","capabilityDelegation","deriveSecret","keyAgreement","type","toX25519KeyPair","kek","externalKeyRepresentation2","resolve","url","TypeError","result","didDocument","DidKeyPairClass","didUri","resolutionMetaData","accept","pop","fromFingerprint","publicKey","didResolutionResponse","didDocumentMetadata","didResolutionMetadata","constructor"],"mappings":"oZAGO,yCAAyBA,EAAaC,EAAcC,WAGnDC,EAFgBC,EAAUC,OAAOC,EAAaJ,QAC7BE,EAAUC,OAAOC,EAAaL,2BAE7BD,EAAOO,KAAKC,OAAOC,KAAKN,oBAA1CO,UACIP,MAAcC,EAAUC,OAAOG,OAAOC,KAAKC,8DAGvBC,EAAeC,aACRA,EAAIC,MAAM,KAAvBH,8BAEDC,EAASG,OAC9BN,OAAOC,oBACPL,EAAUW,SAASL,oEAOrBV,EACAC,EACAC,WAEMc,EAAgBZ,EAAUC,OAC9BC,OAAkBJ,GAAQe,KAAK,EAAOC,KAAM,CAAC,WAGzCf,EAAa,IAAIgB,WACrBX,OAAOY,OAAO,CACZZ,OAAOC,KAAKO,EAAe,SAC3BR,OAAOC,KAAK,IAAK,SACjBR,4BAGoBD,EAAOO,KAAKC,OAAOC,KAAKN,oBAA1CO,OACAW,EAAmBjB,EAAUC,OAAOG,OAAOC,KAAKC,WAC5CM,OAAkBK,oEAI5BV,EACAV,EACAS,aAE0CA,EAAUG,MAAM,MAApCQ,OAEhBC,EAAe,IAAIH,WACvBX,OAAOY,OAAO,CACZZ,OAAOC,UAAoB,SAC3BD,OAAOC,KAAK,IAAK,SACjBR,4BAImBU,EAASG,OAC9BN,OAAOC,KAAKa,GACZlB,EAAUW,SAASM,0CC5DjBE,EAAOC,QAAQ,QAERC,EAAwB,SACnCC,EACAC,mBAAAA,IAAAA,EAAsB,2BAEdA,OACD,2BAGA,8BACID,EAASE,uBAEb,iCACIF,EAASG,kBAGd,IAAIC,MACR,oDAAsDH,IAIpDI,EAAwB,CAC5B,uBACA,0BACA,wBAGWC,WACXC,EACAN,YAAAA,IAAAA,EAAsB,qEA4CR,CACV,+BACA,iCACA,SACWO,IAGbC,GAAID,GACDE,QAlD+C,IAAhDL,EAAsBM,QAAQV,SAC1B,IAAIG,MAAM,4CAA8CH,OAE1DO,aAAiBD,EAAmBK,cACpCC,EAA4Bd,EAChCQ,EACAN,GAEES,EAAiC,CACnCI,mBAAoB,CAACD,IAGnBN,EAAmBtB,WACrByB,OACKA,GACHK,eAAgB,CAACF,EAA0BJ,IAC3CO,gBAAiB,CAACH,EAA0BJ,IAC5CQ,qBAAsB,CAACJ,EAA0BJ,IACjDS,qBAAsB,CAACL,EAA0BJ,OAIjDF,EAAmBY,eACrBT,OACKA,GACHU,aAAc,CAACP,EAA0BJ,2BAIb,+BAA5BF,EAAmBc,4BACHd,EAAmBe,iBAAgB,mBAA/CC,OACAC,EAA6BzB,EAAsBwB,EAAKtB,GAC9DS,OACKA,GACHI,6BACKJ,EAA0BI,oBAC7BU,IAEFJ,aAAc,CAACI,EAA2Bf,6HCtE1B,SAACgB,uCACkB,KAAlBjB,IAAAA,IAAKkB,IAAAA,aACxBlB,EAAMA,GAAOkB,SAEL,IAAIC,UAAU,kDAEDF,EAAQjB,mBAAvBoB,UACCA,EAAOC,uEDmFQ,SAACC,mBAEvBC,EACAC,YAAAA,IAAAA,EAA0B,CAAEC,OAAQ,oCAE9BrB,EAAcmB,EACjB5C,MAAM,KAAK,GACXA,MAAM,YACN+C,6BACqBJ,EAAgBK,gBAAgB,CAAEvB,YAAAA,oBAApDwB,0BACoB9B,EAAY8B,EAAWJ,EAAmBC,wBAA9DJ,OAEAQ,EAAwB,YAChB,qCACZR,YAAAA,EACAS,oBAAqB,gBACHN,EAAmBC,QAErCM,sBAAuB,UAES,yBAA9BP,EAAmBC,OACdpC,EAAKlB,OAAO0D,GAEdA,kJEhHqB,kBACvB,SAAcG,UACZA"}
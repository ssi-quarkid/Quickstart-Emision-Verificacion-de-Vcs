{"version":3,"file":"did-key-secp256k1.cjs.production.min.js","sources":["../src/keyUtils.ts","../src/ES256K.ts","../src/ES256K-R.ts","../src/Secp256k1KeyPair.ts","../src/driver.ts"],"sourcesContent":["import keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport canonicalize from 'canonicalize';\n\nconst compressedHexEncodedPublicKeyLength = 66;\n\n/** Secp256k1 Private Key  */\nexport interface ISecp256k1PrivateKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** private point */\n  d: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/** Secp256k1 Public Key  */\nexport interface ISecp256k1PublicKeyJwk {\n  /** key type */\n  kty: string;\n\n  /** curve */\n  crv: string;\n\n  /** public point */\n  x: string;\n\n  /** public point */\n  y: string;\n\n  /** key id */\n  kid: string;\n}\n\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on Jwk.\n */\nexport const getKid = (\n  jwk: ISecp256k1PrivateKeyJwk | ISecp256k1PublicKeyJwk\n) => {\n  const copy = { ...jwk } as any;\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  const digest = crypto\n    .createHash('sha256')\n    .update(canonicalize(copy))\n    .digest();\n\n  return base64url.encode(Buffer.from(digest));\n};\n\n/** convert compressed hex encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyHex = (privateKeyHex: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert compressed hex encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyHex = (publicKeyHex: string) => {\n  let key = publicKeyHex;\n  if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n    const keyBin = secp256k1.publicKeyConvert(\n      Buffer.from(publicKeyHex, 'hex'),\n      false\n    );\n    key = Buffer.from(keyBin).toString('hex');\n  }\n  const jwk = {\n    ...keyto.from(key, 'blk').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded private key to jwk */\nexport const privateKeyJwkFromPrivateKeyPem = (privateKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(privateKeyPem, 'pem').toJwk('private'),\n    crv: 'secp256k1',\n  };\n  // console.log(jwk);\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert pem encoded public key to jwk */\nexport const publicKeyJwkFromPublicKeyPem = (publicKeyPem: string) => {\n  const jwk = {\n    ...keyto.from(publicKeyPem, 'pem').toJwk('public'),\n    crv: 'secp256k1',\n  };\n  const kid = getKid(jwk);\n\n  return {\n    ...jwk,\n    kid,\n  };\n};\n\n/** convert jwk to hex encoded private key */\nexport const privateKeyHexFromJwk = (jwk: ISecp256k1PrivateKeyJwk) =>\n  keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'private');\n\n/** convert jwk to hex encoded public key */\nexport const publicKeyHexFromJwk = (jwk: ISecp256k1PublicKeyJwk) => {\n  const uncompressedPublicKey = keyto\n    .from(\n      {\n        ...jwk,\n        crv: 'K-256',\n      },\n      'jwk'\n    )\n    .toString('blk', 'public');\n\n  const compressed = secp256k1.publicKeyConvert(\n    Buffer.from(uncompressedPublicKey, 'hex'),\n    true\n  );\n  return Buffer.from(compressed).toString('hex');\n};\n\n/** convert jwk to binary encoded private key */\nexport const privateKeyUInt8ArrayFromJwk = (jwk: ISecp256k1PrivateKeyJwk) => {\n  const privateKeyHex = privateKeyHexFromJwk(jwk);\n  let asBuffer = Buffer.from(privateKeyHex, 'hex');\n  let padding = 32 - asBuffer.length;\n  while (padding > 0) {\n    asBuffer = Buffer.concat([Buffer.from('00', 'hex'), asBuffer]);\n    padding--;\n  }\n  return asBuffer;\n};\n\n/** convert jwk to binary encoded public key */\nexport const publicKeyUInt8ArrayFromJwk = (jwk: ISecp256k1PublicKeyJwk) => {\n  const publicKeyHex = publicKeyHexFromJwk(jwk);\n  let asBuffer = Buffer.from(publicKeyHex, 'hex');\n  let padding = 32 - asBuffer.length;\n  while (padding > 0) {\n    asBuffer = Buffer.concat([Buffer.from('00', 'hex'), asBuffer]);\n    padding--;\n  }\n  return asBuffer;\n};\n\n/** convert publicKeyHex to base58 */\nexport const publicKeyBase58FromPublicKeyHex = (publicKeyHex: string) => {\n  return bs58.encode(Buffer.from(publicKeyHex, 'hex'));\n};\n\n/** convert publicKeyHex to base58 */\nexport const privateKeyBase58FromPrivateKeyHex = (privateKeyHex: string) => {\n  return bs58.encode(Buffer.from(privateKeyHex, 'hex'));\n};\n\nexport const privateKeyUInt8ArrayFromPrivateKeyBase58 = (\n  privateKeyBase58: string\n) => {\n  return bs58.decode(privateKeyBase58);\n};\n\nexport const publicKeyUInt8ArrayFromPublicKeyBase58 = (\n  publicKeyBase58: string\n) => {\n  return bs58.decode(publicKeyBase58);\n};\n\nexport const publicKeyHexFromPrivateKeyHex = (privateKeyHex: string) => {\n  const publicKey = secp256k1.publicKeyCreate(\n    new Uint8Array(Buffer.from(privateKeyHex, 'hex'))\n  );\n  return Buffer.from(publicKey).toString('hex');\n};\n\nexport const publicKeyJwkFromPublicKeyBase58 = (publicKeybase58: string) => {\n  return publicKeyJwkFromPublicKeyHex(\n    bs58.decode(publicKeybase58).toString('hex')\n  );\n};\n\nexport const privateKeyJwkFromPrivateKeyBase58 = (privateKeyBase58: string) => {\n  return privateKeyJwkFromPrivateKeyHex(\n    bs58.decode(privateKeyBase58).toString('hex')\n  );\n};\n","import base64url from 'base64url';\n\nimport crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\n\nimport {\n  ISecp256k1PrivateKeyJwk,\n  ISecp256k1PublicKeyJwk,\n  privateKeyUInt8ArrayFromJwk,\n  publicKeyUInt8ArrayFromJwk,\n} from './keyUtils';\n\n/** error matching @panva/jose for JWS verification failure. */\nclass JWSVerificationFailed extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'JWSVerificationFailed';\n  }\n}\n\n/** JWS Header */\nexport interface IJWSHeader {\n  /** algorithm, ES256K */\n  alg: string;\n\n  /** type, JWT */\n  typ?: string;\n  /** signing key id, ... */\n  kid?: string;\n}\n\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const signDetached = async (\n  // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\n  payload: Buffer,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header = {\n    alg: 'ES256K',\n    b64: false,\n    crit: ['b64'],\n  }\n): Promise<string> => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(Buffer.from(sigObj.signature));\n\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport const verifyDetached = async (\n  jws: string,\n  payload: Buffer,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n): Promise<boolean> => {\n  if (jws.indexOf('..') === -1) {\n    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K') {\n    throw new Error('JWS alg is not signed with ES256K.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n\n  return verified;\n};\n\n/** Produce a normal ES256K JWS */\nexport const sign = async (\n  payload: any,\n  privateKeyJwk: ISecp256k1PrivateKeyJwk,\n  header: IJWSHeader = { alg: 'ES256K' }\n): Promise<string> => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(sigObj.signature);\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport const verify = async (\n  jws: string,\n  publicKeyJwk: ISecp256k1PublicKeyJwk\n): Promise<boolean> => {\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n\n  return verified;\n};\n\n/** decode a JWS (without verifying it) */\nexport const decode = (jws: string, options = { complete: false }): any => {\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature,\n    };\n  }\n  return JSON.parse(base64url.decode(encodedPayload));\n};\n","import {\n  privateKeyUInt8ArrayFromJwk,\n  publicKeyUInt8ArrayFromJwk,\n} from './keyUtils';\nimport base64url from 'base64url';\nimport secp256k1 from 'secp256k1';\nimport crypto from 'crypto';\n\nexport const sign = async (\n  payload: any,\n  privateKeyJwk: any,\n  header: any = { alg: 'ES256K-R' }\n): Promise<string> => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n\n  const sigObj: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const encodedSignature = base64url.encode(sigObj.signature);\n  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n};\n\nexport const verify = async (\n  jws: string,\n  publicKeyJwk: any\n): Promise<boolean> => {\n  const publicKeyUInt8Array = await publicKeyUInt8ArrayFromJwk(publicKeyJwk);\n  const [encodedHeader, encodedPayload, encodedSignature] = jws.split('.');\n\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K-R') {\n    throw new Error('Expecteed header.alg to be  ES256K-R');\n  }\n  const toBeSigned = `${encodedHeader}.${encodedPayload}`;\n  const message = Buffer.from(toBeSigned);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const signatureUInt8Array = base64url.toBuffer(encodedSignature);\n  let signatureLowerS = secp256k1.signatureNormalize(signatureUInt8Array);\n\n  const verified = secp256k1.ecdsaVerify(\n    signatureLowerS,\n    messageHashUInt8Array,\n    publicKeyUInt8Array\n  );\n\n  return verified;\n};\n\nexport const signDetached = async (\n  payload: Buffer,\n  privateKeyJwk: any,\n  header = {\n    alg: 'ES256K-R',\n    b64: false,\n    crit: ['b64'],\n  }\n): Promise<string> => {\n  const privateKeyUInt8Array = await privateKeyUInt8ArrayFromJwk(privateKeyJwk);\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n\n  const message = Buffer.from(toBeSignedBuffer);\n  const digest = crypto\n    .createHash('sha256')\n    .update(message)\n    .digest();\n\n  const messageHashUInt8Array = digest;\n  const { signature, recid }: any = secp256k1.ecdsaSign(\n    messageHashUInt8Array,\n    privateKeyUInt8Array\n  );\n\n  const signatureUInt8Array = Buffer.concat([\n    Buffer.from(signature),\n    Buffer.from(new Uint8Array([recid])),\n  ]);\n\n  const encodedSignature = base64url.encode(signatureUInt8Array);\n  return `${encodedHeader}..${encodedSignature}`;\n};\n\nexport const recoverPublicKey = async (\n  jws: string,\n  payload: any\n): Promise<Uint8Array> => {\n  if (jws.indexOf('..') === -1) {\n    throw new Error('not a valid rfc7797 jws.');\n  }\n  const [encodedHeader, encodedSignature] = jws.split('..');\n  const header = JSON.parse(base64url.decode(encodedHeader));\n  if (header.alg !== 'ES256K-R') {\n    throw new Error('JWS alg is not signed with ES256K-R.');\n  }\n  if (\n    header.b64 !== false ||\n    !header.crit ||\n    !header.crit.length ||\n    header.crit[0] !== 'b64'\n  ) {\n    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n  }\n\n  const toBeSignedBuffer = Buffer.concat([\n    Buffer.from(encodedHeader + '.', 'utf8'),\n    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n  ]);\n  const message = Buffer.from(toBeSignedBuffer);\n\n  const digest = new Uint8Array(\n    crypto\n      .createHash('sha256')\n      .update(message)\n      .digest()\n  );\n\n  let signatureUInt8Array = new Uint8Array(\n    base64url.toBuffer(encodedSignature)\n  );\n\n  const recoveryId = signatureUInt8Array[64];\n  signatureUInt8Array = signatureUInt8Array.slice(0, 64);\n\n  return secp256k1.ecdsaRecover(signatureUInt8Array, recoveryId, digest);\n};\n","import crypto from 'crypto';\n\nimport * as keyUtils from './keyUtils';\nimport bs58 from 'bs58';\nimport secp256k1 from 'secp256k1';\n\nimport * as common from '@transmute/did-key-common';\n\nconst _generate = (secureRandom: any) => {\n  let privateKey;\n  do {\n    privateKey = secureRandom();\n  } while (!secp256k1.privateKeyVerify(privateKey));\n\n  const publicKey = secp256k1.publicKeyCreate(privateKey);\n  return { publicKey, privateKey };\n};\n\n@common.types.staticImplements<common.types.KeyPairClass>()\nexport class Secp256k1KeyPair {\n  public id: string;\n  public type: string;\n  public controller: string;\n\n  public publicKeyBuffer: Buffer;\n  public privateKeyBuffer?: Buffer;\n\n  static fingerprintFromPublicKey(\n    keypair: common.types.KeyPairJwk | common.types.KeyPairBase58\n  ) {\n    let pubkeyBytes: any;\n\n    if ((keypair as any).publicKeyBase58) {\n      pubkeyBytes = bs58.decode(\n        (keypair as common.types.KeyPairBase58).publicKeyBase58\n      );\n    }\n\n    if ((keypair as any).publicKeyJwk) {\n      pubkeyBytes = new Uint8Array(\n        Buffer.from(\n          keyUtils.publicKeyHexFromJwk(\n            (keypair as common.types.KeyPairJwk).publicKeyJwk\n          )\n        )\n      );\n    }\n\n    const buffer = new Uint8Array(2 + pubkeyBytes.length);\n    // See https://github.com/multiformats/multicodec/blob/master/table.csv\n    // 0xe7 is Secp256k1 public key\n    buffer[0] = 0xe7; //\n    buffer[1] = 0x01;\n    buffer.set(pubkeyBytes, 2);\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${bs58.encode(buffer)}`;\n  }\n\n  static async generate(options: any = {}) {\n    let privateKey;\n    let publicKey;\n    if (options.secureRandom) {\n      ({ privateKey, publicKey } = _generate(options.secureRandom));\n    }\n\n    if (!privateKey) {\n      throw new Error('Cannot generate private key.');\n    }\n\n    const publicKeyBase58 = keyUtils.publicKeyBase58FromPublicKeyHex(\n      Buffer.from(publicKey).toString('hex')\n    );\n    const privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n      Buffer.from(privateKey).toString('hex')\n    );\n\n    const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n    const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58,\n    } as any)}`;\n\n    return new Secp256k1KeyPair({\n      id: keyId,\n      controller: did,\n      publicKeyBase58,\n      privateKeyBase58,\n    });\n  }\n\n  static async from(options: any) {\n    let privateKeyBase58 = options.privateKeyBase58;\n    let publicKeyBase58 = options.publicKeyBase58;\n\n    if (options.privateKeyHex) {\n      privateKeyBase58 = await keyUtils.privateKeyBase58FromPrivateKeyHex(\n        options.privateKeyHex\n      );\n    }\n\n    if (options.publicKeyHex) {\n      publicKeyBase58 = await keyUtils.publicKeyBase58FromPublicKeyHex(\n        options.publicKeyHex\n      );\n    }\n\n    if (options.privateKeyJwk) {\n      privateKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.privateKeyHexFromJwk(options.privateKeyJwk)\n      );\n    }\n\n    if (options.publicKeyJwk) {\n      publicKeyBase58 = keyUtils.privateKeyBase58FromPrivateKeyHex(\n        await keyUtils.publicKeyHexFromJwk(options.publicKeyJwk)\n      );\n    }\n\n    return new Secp256k1KeyPair({\n      ...options,\n      privateKeyBase58,\n      publicKeyBase58,\n    });\n  }\n\n  static fromFingerprint({ fingerprint }: any) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = bs58.decode(fingerprint.substr(1));\n\n    // https://github.com/multiformats/multicodec/blob/master/table.csv#L77\n    if (buffer[0] === 0xe7 && buffer[1] === 0x01) {\n      const publicKeyBase58 = bs58.encode(buffer.slice(2));\n      const did = `did:key:${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      const keyId = `#${Secp256k1KeyPair.fingerprintFromPublicKey({\n        publicKeyBase58,\n      } as any)}`;\n      return new Secp256k1KeyPair({\n        id: keyId,\n        controller: did,\n        publicKeyBase58,\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  constructor(options: any = {}) {\n    this.type = 'EcdsaSecp256k1VerificationKey2019';\n    this.id = options.id;\n    this.controller = options.controller;\n\n    if (options.publicKeyBase58) {\n      this.publicKeyBuffer = bs58.decode(options.publicKeyBase58);\n    } else if (options.publicKeyJwk) {\n      this.publicKeyBuffer = Buffer.from(\n        keyUtils.publicKeyHexFromJwk(options.publicKeyJwk),\n        'hex'\n      );\n    } else {\n      throw new Error(\n        'Secp256k1KeyPair requires publicKeyBase58 or publicKeyJwk, recieved neither.'\n      );\n    }\n\n    if (options.privateKeyBase58) {\n      this.privateKeyBuffer = bs58.decode(options.privateKeyBase58);\n    }\n\n    if (options.privateKeyJwk) {\n      this.privateKeyBuffer = Buffer.from(\n        keyUtils.privateKeyHexFromJwk(options.privateKeyJwk),\n        'hex'\n      );\n    }\n\n    if (this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n  }\n\n  publicNode() {\n    return this.toKeyPair(false);\n  }\n\n  signer() {\n    if (!this.privateKeyBuffer) {\n      throw new Error('No private key to sign with.');\n    }\n    let { privateKeyBuffer } = this;\n    return {\n      async sign({ data }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        const sigObj: any = secp256k1.ecdsaSign(\n          messageHashUInt8Array,\n          new Uint8Array(privateKeyBuffer)\n        );\n\n        return sigObj.signature;\n      },\n    };\n  }\n\n  verifier() {\n    if (!this.publicKeyBuffer) {\n      throw new Error('No public key to verify with.');\n    }\n    let { publicKeyBuffer } = this;\n    return {\n      async verify({ data, signature }: any) {\n        const messageHashUInt8Array = crypto\n          .createHash('sha256')\n          .update(data)\n          .digest();\n\n        let verified = false;\n        try {\n          verified = secp256k1.ecdsaVerify(\n            signature,\n            messageHashUInt8Array,\n            new Uint8Array(publicKeyBuffer)\n          );\n        } catch (e) {\n          console.error('An error occurred when verifying signature: ', e);\n        }\n        return verified;\n      },\n    };\n  }\n\n  fingerprint() {\n    return Secp256k1KeyPair.fingerprintFromPublicKey({\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    } as any);\n  }\n\n  verifyFingerprint(fingerprint: string) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false,\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = bs58.decode(fingerprint.slice(1));\n    } catch (e) {\n      return { error: e, valid: false };\n    }\n    let { publicKeyBuffer } = this;\n\n    // validate the first two multicodec bytes 0xe701\n    const valid =\n      fingerprintBuffer.slice(0, 2).toString('hex') === 'e701' &&\n      publicKeyBuffer.equals(fingerprintBuffer.slice(2));\n    if (!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false,\n      };\n    }\n    return { valid };\n  }\n\n  toJwk(_private: boolean = false) {\n    if (_private) {\n      if (!this.privateKeyBuffer) {\n        throw new Error('No private key to export');\n      }\n      return keyUtils.privateKeyJwkFromPrivateKeyHex(\n        this.privateKeyBuffer.toString('hex')\n      );\n    }\n    return keyUtils.publicKeyJwkFromPublicKeyHex(\n      this.publicKeyBuffer.toString('hex')\n    );\n  }\n\n  async toHex(_private: boolean = false) {\n    if (_private) {\n      if (!this.privateKeyBuffer) {\n        throw new Error('No private key to export');\n      }\n      return keyUtils.privateKeyHexFromJwk(\n        await keyUtils.privateKeyJwkFromPrivateKeyHex(\n          this.privateKeyBuffer.toString('hex')\n        )\n      );\n    }\n    return keyUtils.publicKeyHexFromJwk(\n      await keyUtils.publicKeyJwkFromPublicKeyHex(\n        this.publicKeyBuffer.toString('hex')\n      )\n    );\n  }\n\n  toKeyPair(exportPrivate = false) {\n    const kp: any = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller,\n      publicKeyBase58: bs58.encode(this.publicKeyBuffer),\n    };\n    if (exportPrivate) {\n      kp.privateKeyBase58 = bs58.encode(this.privateKeyBuffer);\n    }\n    return kp;\n  }\n\n  toJsonWebKeyPair(exportPrivate: boolean = false): any {\n    let kp: any = {\n      id: this.id,\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk(),\n    };\n    delete kp.publicKeyJwk.kid;\n    if (exportPrivate) {\n      kp.privateKeyJwk = this.toJwk(true);\n      delete kp.privateKeyJwk.kid;\n    }\n\n    return kp;\n  }\n}\n","import { Secp256k1KeyPair } from './Secp256k1KeyPair';\nimport { getResolve, getGet } from '@transmute/did-key-common';\n\nexport const resolve = getResolve(Secp256k1KeyPair);\nexport const get = getGet(resolve);\n"],"names":["getKid","jwk","copy","d","kid","alg","digest","crypto","createHash","update","canonicalize","base64url","encode","Buffer","from","privateKeyJwkFromPrivateKeyHex","privateKeyHex","keyto","toJwk","crv","publicKeyJwkFromPublicKeyHex","publicKeyHex","key","length","keyBin","secp256k1","publicKeyConvert","toString","privateKeyHexFromJwk","publicKeyHexFromJwk","uncompressedPublicKey","compressed","privateKeyUInt8ArrayFromJwk","asBuffer","padding","concat","publicKeyUInt8ArrayFromJwk","publicKeyBase58FromPublicKeyHex","bs58","privateKeyBase58FromPrivateKeyHex","privateKeyPem","publicKeyPem","privateKeyBase58","decode","publicKeyBase58","publicKey","publicKeyCreate","Uint8Array","publicKeybase58","JWSVerificationFailed","message","name","Error","payload","privateKeyJwk","header","b64","crit","privateKeyUInt8Array","encodedHeader","JSON","stringify","toBeSignedBuffer","buffer","byteOffset","sigObj","ecdsaSign","signature","jws","publicKeyJwk","indexOf","split","encodedSignature","parse","publicKeyUInt8Array","messageHashUInt8Array","signatureUInt8Array","toBuffer","signatureLowerS","signatureNormalize","ecdsaVerify","encodedPayload","options","complete","recid","recoveryId","slice","ecdsaRecover","Secp256k1KeyPair","type","id","controller","publicKeyBuffer","keyUtils","privateKeyBuffer","this","fingerprint","fingerprintFromPublicKey","keypair","pubkeyBytes","set","generate","privateKey","secureRandom","privateKeyVerify","_generate","did","Secp256k1KeyPair_1","keyId","fromFingerprint","substr","publicNode","toKeyPair","signer","sign","data","verifier","verify","verified","e","console","error","verifyFingerprint","valid","fingerprintBuffer","equals","_private","toHex","_this2","exportPrivate","kp","toJsonWebKeyPair","common","staticImplements","resolve","getResolve","getGet"],"mappings":"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"}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Encode a positive integer as a little-endian Uint8Array. For values exceeding
 * `Number.MAX_SAFE_INTEGER`, use `bigIntToBinUintLE`. Negative values will
 * return the same result as `0`.
 *
 * @param value - the number to encode
 */
exports.numberToBinUintLE = (value) => {
    const baseUint8Array = 256;
    const result = [];
    // eslint-disable-next-line functional/no-let
    let remaining = value;
    // eslint-disable-next-line functional/no-loop-statement
    while (remaining >= baseUint8Array) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        result.push(remaining % baseUint8Array);
        // eslint-disable-next-line functional/no-expression-statement
        remaining = Math.floor(remaining / baseUint8Array);
    }
    // eslint-disable-next-line functional/no-conditional-statement, functional/no-expression-statement, functional/immutable-data
    if (remaining > 0)
        result.push(remaining);
    return Uint8Array.from(result);
};
/**
 * Fill a new Uint8Array of a specific byte-length with the contents of a given
 * Uint8Array, truncating or padding the Uint8Array with zeros.
 *
 * @param bin - the Uint8Array to resize
 * @param bytes - the desired byte-length
 */
exports.binToFixedLength = (bin, bytes) => {
    const fixedBytes = new Uint8Array(bytes);
    const maxValue = 255;
    // eslint-disable-next-line functional/no-expression-statement, @typescript-eslint/no-unused-expressions
    bin.length > bytes ? fixedBytes.fill(maxValue) : fixedBytes.set(bin);
    return fixedBytes;
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array, clamping the
 * results. (Values exceeding `0xffff` return the same result as `0xffff`,
 * negative values will return the same result as `0`.)
 *
 * @param value - the number to encode
 */
exports.numberToBinUint16LEClamped = (value) => {
    const uint16 = 2;
    return exports.binToFixedLength(exports.numberToBinUintLE(value), uint16);
};
/**
 * Encode a positive integer as a 4-byte Uint32LE Uint8Array, clamping the
 * results. (Values exceeding `0xffffffff` return the same result as
 * `0xffffffff`, negative values will return the same result as `0`.)
 *
 * @param value - the number to encode
 */
exports.numberToBinUint32LEClamped = (value) => {
    const uint32 = 4;
    return exports.binToFixedLength(exports.numberToBinUintLE(value), uint32);
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff`.
 *
 * @param value - the number to encode
 */
exports.numberToBinUint16LE = (value) => {
    const uint16Length = 2;
    const bin = new Uint8Array(uint16Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statement
    view.setUint16(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff`.
 *
 * @param value - the number to encode
 */
exports.numberToBinUint16BE = (value) => {
    const uint16Length = 2;
    const bin = new Uint8Array(uint16Length);
    const writeAsLittleEndian = false;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statement
    view.setUint16(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive number as a 4-byte Uint32LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffffffff`.
 *
 * @param value - the number to encode
 */
exports.numberToBinUint32LE = (value) => {
    const uint32Length = 4;
    const bin = new Uint8Array(uint32Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statement
    view.setUint32(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive number as a 4-byte Uint32BE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffffffff`.
 *
 * @param value - the number to encode
 */
exports.numberToBinUint32BE = (value) => {
    const uint32Length = 4;
    const bin = new Uint8Array(uint32Length);
    const writeAsLittleEndian = false;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statement
    view.setUint32(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode a positive BigInt as little-endian Uint8Array. Negative values will
 * return the same result as `0`.
 *
 * @param value - the number to encode
 */
exports.bigIntToBinUintLE = (value) => {
    const baseUint8Array = 256;
    const base = BigInt(baseUint8Array);
    const result = [];
    // eslint-disable-next-line functional/no-let
    let remaining = value;
    // eslint-disable-next-line functional/no-loop-statement
    while (remaining >= base) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        result.push(Number(remaining % base));
        // eslint-disable-next-line functional/no-expression-statement
        remaining /= base;
    }
    // eslint-disable-next-line functional/no-conditional-statement, functional/no-expression-statement, functional/immutable-data
    if (remaining > BigInt(0))
        result.push(Number(remaining));
    return Uint8Array.from(result.length > 0 ? result : [0]);
};
/**
 * Encode a positive BigInt as an 8-byte Uint64LE Uint8Array, clamping the
 * results. (Values exceeding `0xffff_ffff_ffff_ffff` return the same result as
 * `0xffff_ffff_ffff_ffff`, negative values return the same result as `0`.)
 *
 * @param value - the number to encode
 */
exports.bigIntToBinUint64LEClamped = (value) => {
    const uint64 = 8;
    return exports.binToFixedLength(exports.bigIntToBinUintLE(value), uint64);
};
/**
 * Encode a positive BigInt as an 8-byte Uint64LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff_ffff_ffff_ffff`.
 *
 * @param value - the number to encode
 */
exports.bigIntToBinUint64LE = (value) => {
    const uint64Length = 8;
    const bin = new Uint8Array(uint64Length);
    const writeAsLittleEndian = true;
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    // eslint-disable-next-line functional/no-expression-statement
    view.setBigUint64(0, value, writeAsLittleEndian);
    return bin;
};
/**
 * Encode an integer as a 4-byte, little-endian Uint8Array using the number's
 * two's compliment representation (the format used by JavaScript's bitwise
 * operators).
 *
 * @remarks
 * The C++ bitcoin implementations sometimes represent short vectors using
 * signed 32-bit integers (e.g. `sighashType`). This method can be used to test
 * compatibility with those implementations.
 *
 * @param value - the number to encode
 */
exports.numberToBinInt32TwosCompliment = (value) => {
    const bytes = 4;
    const bitsInAByte = 8;
    const bin = new Uint8Array(bytes);
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let offset = 0; offset < bytes; offset++) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        bin[offset] = value;
        // eslint-disable-next-line functional/no-expression-statement, no-bitwise, no-param-reassign
        value >>>= bitsInAByte;
    }
    return bin;
};
/**
 * Decode a little-endian Uint8Array of any length into a number. For numbers
 * larger than `Number.MAX_SAFE_INTEGER`, use `binToBigIntUintLE`.
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * @privateRemarks
 * We avoid a bitwise strategy here because JavaScript uses 32-bit signed
 * integers for bitwise math, so larger numbers are converted incorrectly. E.g.
 * `2147483648 << 8` is `0`, while `2147483648n << 8n` is `549755813888n`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
exports.binToNumberUintLE = (bin, bytes = bin.length) => {
    const base = 2;
    const bitsInAByte = 8;
    // eslint-disable-next-line functional/no-conditional-statement
    if (bin.length !== bytes) {
        // eslint-disable-next-line functional/no-throw-statement
        throw new TypeError(`Bin length must be ${bytes}.`);
    }
    return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce((accumulated, byte, i) => accumulated + byte * base ** (bitsInAByte * i), 0);
};
/**
 * Decode a 2-byte Uint16LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 2 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
exports.binToNumberUint16LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getUint16(0, readAsLittleEndian);
};
/**
 * Decode a 4-byte Uint32LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 4 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
exports.binToNumberUint32LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getUint32(0, readAsLittleEndian);
};
/**
 * Decode a big-endian Uint8Array of any length into a BigInt. If starting from
 * a hex value, consider using the BigInt constructor instead:
 * ```
 * BigInt(`0x${hex}`)
 * ```
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
exports.binToBigIntUintBE = (bin, bytes = bin.length) => {
    const bitsInAByte = 8;
    const shift = BigInt(bitsInAByte);
    // eslint-disable-next-line functional/no-conditional-statement
    if (bin.length !== bytes) {
        // eslint-disable-next-line functional/no-throw-statement
        throw new TypeError(`Bin length must be ${bytes}.`);
    }
    return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce(
    // eslint-disable-next-line no-bitwise
    (accumulated, byte) => (accumulated << shift) | BigInt(byte), BigInt(0));
};
/**
 * Decode an unsigned, 32-byte big-endian Uint8Array into a BigInt. This can be
 * used to decode Uint8Array-encoded cryptographic primitives like private
 * keys, public keys, curve parameters, and signature points.
 *
 * If starting from a hex value, consider using the BigInt constructor instead:
 * ```
 * BigInt(`0x${hex}`)
 * ```
 * @param bin - the Uint8Array to decode
 */
exports.binToBigIntUint256BE = (bin) => {
    const uint256Bytes = 32;
    return exports.binToBigIntUintBE(bin, uint256Bytes);
};
/**
 * Encode a positive BigInt into an unsigned 32-byte big-endian Uint8Array. This
 * can be used to encoded numbers for cryptographic primitives like private
 * keys, public keys, curve parameters, and signature points.
 *
 * Negative values will return the same result as `0`, values higher than
 * 2^256-1 will return the maximum expressible unsigned 256-bit value
 * (`0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff`).
 *
 * @param value - the BigInt to encode
 */
exports.bigIntToBinUint256BEClamped = (value) => {
    const uint256Bytes = 32;
    return exports.binToFixedLength(exports.bigIntToBinUintLE(value), uint256Bytes).reverse();
};
/**
 * Decode a little-endian Uint8Array of any length into a BigInt.
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
exports.binToBigIntUintLE = (bin, bytes = bin.length) => {
    const bitsInAByte = 8;
    // eslint-disable-next-line functional/no-conditional-statement
    if (bin.length !== bytes) {
        // eslint-disable-next-line functional/no-throw-statement
        throw new TypeError(`Bin length must be ${bytes}.`);
    }
    return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduceRight(
    // eslint-disable-next-line no-bitwise
    (accumulated, byte) => (accumulated << BigInt(bitsInAByte)) | BigInt(byte), BigInt(0));
};
/**
 * Decode an 8-byte Uint64LE Uint8Array into a BigInt.
 *
 * Throws if `bin` is shorter than 8 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
exports.binToBigIntUint64LE = (bin) => {
    const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
    const readAsLittleEndian = true;
    return view.getBigUint64(0, readAsLittleEndian);
};
/**
 * Get the expected byte length of a Bitcoin VarInt given a first byte.
 *
 * @param firstByte - the first byte of the VarInt
 */
exports.varIntPrefixToSize = (firstByte) => {
    const uint8 = 1;
    const uint16 = 2;
    const uint32 = 4;
    const uint64 = 8;
    switch (firstByte) {
        default:
            return uint8;
        case 253 /* Uint16Prefix */:
            return uint16 + 1;
        case 254 /* Uint32Prefix */:
            return uint32 + 1;
        case 255 /* Uint64Prefix */:
            return uint64 + 1;
    }
};
/**
 * Read a Bitcoin VarInt (Variable-length integer) from a Uint8Array, returning
 * the `nextOffset` after the VarInt and the value as a BigInt.
 *
 * @param bin - the Uint8Array from which to read the VarInt
 * @param offset - the offset at which the VarInt begins
 */
exports.readBitcoinVarInt = (bin, offset = 0) => {
    const bytes = exports.varIntPrefixToSize(bin[offset]);
    const hasPrefix = bytes !== 1;
    return {
        nextOffset: offset + bytes,
        value: hasPrefix
            ? exports.binToBigIntUintLE(bin.subarray(offset + 1, offset + bytes), bytes - 1)
            : exports.binToBigIntUintLE(bin.subarray(offset, offset + bytes), 1),
    };
};
/**
 * Encode a positive BigInt as a Bitcoin VarInt (Variable-length integer).
 *
 * Note: the maximum value of a Bitcoin VarInt is `0xffff_ffff_ffff_ffff`. This
 * method will return an incorrect result for values outside of the range `0` to
 * `0xffff_ffff_ffff_ffff`.
 *
 * @param value - the BigInt to encode (no larger than `0xffff_ffff_ffff_ffff`)
 */
exports.bigIntToBitcoinVarInt = (value) => value <= BigInt(252 /* Uint8MaxValue */)
    ? Uint8Array.of(Number(value))
    : value <= BigInt(65535 /* Uint16MaxValue */)
        ? Uint8Array.from([
            253 /* Uint16Prefix */,
            ...exports.numberToBinUint16LE(Number(value)),
        ])
        : value <= BigInt(4294967295 /* Uint32MaxValue */)
            ? Uint8Array.from([
                254 /* Uint32Prefix */,
                ...exports.numberToBinUint32LE(Number(value)),
            ])
            : Uint8Array.from([255 /* Uint64Prefix */, ...exports.bigIntToBinUint64LE(value)]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtYmVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvZm9ybWF0L251bWJlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0dBTUc7QUFDVSxRQUFBLGlCQUFpQixHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7SUFDakQsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0lBQzNCLE1BQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztJQUM1Qiw2Q0FBNkM7SUFDN0MsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQ3RCLHdEQUF3RDtJQUN4RCxPQUFPLFNBQVMsSUFBSSxjQUFjLEVBQUU7UUFDbEMseUZBQXlGO1FBQ3pGLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLDhEQUE4RDtRQUM5RCxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsY0FBYyxDQUFDLENBQUM7S0FDcEQ7SUFDRCw4SEFBOEg7SUFDOUgsSUFBSSxTQUFTLEdBQUcsQ0FBQztRQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDMUMsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2pDLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLFFBQUEsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFlLEVBQUUsS0FBYSxFQUFFLEVBQUU7SUFDakUsTUFBTSxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekMsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDO0lBQ3JCLHdHQUF3RztJQUN4RyxHQUFHLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyRSxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDVSxRQUFBLDBCQUEwQixHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7SUFDMUQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLE9BQU8sd0JBQWdCLENBQUMseUJBQWlCLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDNUQsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ1UsUUFBQSwwQkFBMEIsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO0lBQzFELE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNqQixPQUFPLHdCQUFnQixDQUFDLHlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzVELENBQUMsQ0FBQztBQUVGOzs7Ozs7O0dBT0c7QUFDVSxRQUFBLG1CQUFtQixHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7SUFDbkQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLE1BQU0sR0FBRyxHQUFHLElBQUksVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxDQUFDO0lBQ2pDLE1BQU0sSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEUsOERBQThEO0lBQzlELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQzlDLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7R0FPRztBQUNVLFFBQUEsbUJBQW1CLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRTtJQUNuRCxNQUFNLFlBQVksR0FBRyxDQUFDLENBQUM7SUFDdkIsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDekMsTUFBTSxtQkFBbUIsR0FBRyxLQUFLLENBQUM7SUFDbEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN0RSw4REFBOEQ7SUFDOUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDOUMsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDLENBQUM7QUFFRjs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO0lBQ25ELE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBQztJQUN2QixNQUFNLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN6QyxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQztJQUNqQyxNQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RFLDhEQUE4RDtJQUM5RCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUM5QyxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMsQ0FBQztBQUVGOzs7Ozs7O0dBT0c7QUFDVSxRQUFBLG1CQUFtQixHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7SUFDbkQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLE1BQU0sR0FBRyxHQUFHLElBQUksVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sbUJBQW1CLEdBQUcsS0FBSyxDQUFDO0lBQ2xDLE1BQU0sSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEUsOERBQThEO0lBQzlELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQzlDLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDVSxRQUFBLGlCQUFpQixHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7SUFDakQsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0lBQzNCLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNwQyxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFDNUIsNkNBQTZDO0lBQzdDLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztJQUN0Qix3REFBd0Q7SUFDeEQsT0FBTyxTQUFTLElBQUksSUFBSSxFQUFFO1FBQ3hCLHlGQUF5RjtRQUN6RixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN0Qyw4REFBOEQ7UUFDOUQsU0FBUyxJQUFJLElBQUksQ0FBQztLQUNuQjtJQUNELDhIQUE4SDtJQUM5SCxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUUxRCxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLFFBQUEsMEJBQTBCLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRTtJQUMxRCxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDakIsT0FBTyx3QkFBZ0IsQ0FBQyx5QkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM1RCxDQUFDLENBQUM7QUFFRjs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO0lBQ25ELE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBQztJQUN2QixNQUFNLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN6QyxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQztJQUNqQyxNQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RFLDhEQUE4RDtJQUM5RCxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUNqRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7OztHQVdHO0FBQ1UsUUFBQSw4QkFBOEIsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO0lBQzlELE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUM7SUFDdEIsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEMsd0ZBQXdGO0lBQ3hGLEtBQUssSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDN0MseUZBQXlGO1FBQ3pGLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDcEIsNkZBQTZGO1FBQzdGLEtBQUssTUFBTSxXQUFXLENBQUM7S0FDeEI7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRyxDQUFDLEdBQWUsRUFBRSxLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFO0lBQ3ZFLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNmLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBQztJQUN0QiwrREFBK0Q7SUFDL0QsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEtBQUssRUFBRTtRQUN4Qix5REFBeUQ7UUFDekQsTUFBTSxJQUFJLFNBQVMsQ0FBQyxzQkFBc0IsS0FBSyxHQUFHLENBQUMsQ0FBQztLQUNyRDtJQUNELE9BQU8sSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQ2xFLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUN4RSxDQUFDLENBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLFFBQUEsbUJBQW1CLEdBQUcsQ0FBQyxHQUFlLEVBQUUsRUFBRTtJQUNyRCxNQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RFLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDO0lBQ2hDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztBQUMvQyxDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDVSxRQUFBLG1CQUFtQixHQUFHLENBQUMsR0FBZSxFQUFFLEVBQUU7SUFDckQsTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN0RSxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQztJQUNoQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLGtCQUFrQixDQUFDLENBQUM7QUFDL0MsQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7Ozs7OztHQVlHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRyxDQUFDLEdBQWUsRUFBRSxLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFO0lBQ3ZFLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBQztJQUN0QixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDbEMsK0RBQStEO0lBQy9ELElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxLQUFLLEVBQUU7UUFDeEIseURBQXlEO1FBQ3pELE1BQU0sSUFBSSxTQUFTLENBQUMsc0JBQXNCLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDckQ7SUFDRCxPQUFPLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTTtJQUNsRSxzQ0FBc0M7SUFDdEMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQzVELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FDVixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7Ozs7R0FVRztBQUNVLFFBQUEsb0JBQW9CLEdBQUcsQ0FBQyxHQUFlLEVBQUUsRUFBRTtJQUN0RCxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7SUFDeEIsT0FBTyx5QkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDOUMsQ0FBQyxDQUFDO0FBRUY7Ozs7Ozs7Ozs7R0FVRztBQUNVLFFBQUEsMkJBQTJCLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRTtJQUMzRCxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7SUFDeEIsT0FBTyx3QkFBZ0IsQ0FBQyx5QkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM1RSxDQUFDLENBQUM7QUFFRjs7Ozs7Ozs7R0FRRztBQUNVLFFBQUEsaUJBQWlCLEdBQUcsQ0FBQyxHQUFlLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBRTtJQUN2RSxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUM7SUFDdEIsK0RBQStEO0lBQy9ELElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxLQUFLLEVBQUU7UUFDeEIseURBQXlEO1FBQ3pELE1BQU0sSUFBSSxTQUFTLENBQUMsc0JBQXNCLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDckQ7SUFDRCxPQUFPLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVztJQUN2RSxzQ0FBc0M7SUFDdEMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQzFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FDVixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxDQUFDLEdBQWUsRUFBRSxFQUFFO0lBQ3JELE1BQU0sSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEUsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUM7SUFDaEMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2xELENBQUMsQ0FBQztBQVdGOzs7O0dBSUc7QUFDVSxRQUFBLGtCQUFrQixHQUFHLENBQUMsU0FBaUIsRUFBRSxFQUFFO0lBQ3RELE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDakIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNqQixRQUFRLFNBQVMsRUFBRTtRQUNqQjtZQUNFLE9BQU8sS0FBSyxDQUFDO1FBQ2Y7WUFDRSxPQUFPLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDcEI7WUFDRSxPQUFPLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDcEI7WUFDRSxPQUFPLE1BQU0sR0FBRyxDQUFDLENBQUM7S0FDckI7QUFDSCxDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDVSxRQUFBLGlCQUFpQixHQUFHLENBQUMsR0FBZSxFQUFFLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRTtJQUMvRCxNQUFNLEtBQUssR0FBRywwQkFBa0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM5QyxNQUFNLFNBQVMsR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDO0lBQzlCLE9BQU87UUFDTCxVQUFVLEVBQUUsTUFBTSxHQUFHLEtBQUs7UUFDMUIsS0FBSyxFQUFFLFNBQVM7WUFDZCxDQUFDLENBQUMseUJBQWlCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxLQUFLLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQ3hFLENBQUMsQ0FBQyx5QkFBaUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQy9ELENBQUM7QUFDSixDQUFDLENBQUM7QUFFRjs7Ozs7Ozs7R0FRRztBQUNVLFFBQUEscUJBQXFCLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUNyRCxLQUFLLElBQUksTUFBTSx5QkFBc0I7SUFDbkMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUMsQ0FBQyxLQUFLLElBQUksTUFBTSw0QkFBdUI7UUFDeEMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7O1lBRWQsR0FBRywyQkFBbUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEMsQ0FBQztRQUNKLENBQUMsQ0FBQyxLQUFLLElBQUksTUFBTSxpQ0FBdUI7WUFDeEMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7O2dCQUVkLEdBQUcsMkJBQW1CLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3RDLENBQUM7WUFDSixDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyx5QkFBc0IsR0FBRywyQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMifQ==
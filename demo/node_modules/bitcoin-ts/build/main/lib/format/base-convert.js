"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BaseConversionError;
(function (BaseConversionError) {
    BaseConversionError["tooLong"] = "An alphabet may be no longer than 254 characters.";
    BaseConversionError["ambiguousCharacter"] = "A character code may only appear once in a single alphabet.";
    BaseConversionError["unknownCharacter"] = "Encountered an unknown character for this alphabet.";
})(BaseConversionError = exports.BaseConversionError || (exports.BaseConversionError = {}));
/**
 * Create a `BaseConverter`, which exposes methods for encoding and decoding
 * `Uint8Array`s using bitcoin-style padding: each leading zero in the input is
 * replaced with the zero-index character of the `alphabet`, then the remainder
 * of the input is encoded as a large number in the specified alphabet.
 *
 * For example, using the alphabet `01`, the input `[0, 15]` is encoded `01111`
 * â€“ a single `0` represents the leading padding, followed by the base2 encoded
 * `0x1111` (15). With the same alphabet, the input `[0, 0, 255]` is encoded
 * `0011111111` - only two `0` characters are required to represent both
 * leading zeros, followed by the base2 encoded `0x11111111` (255).
 *
 * **This is not compatible with `RFC 3548`'s `Base16`, `Base32`, or `Base64`.**
 *
 * If the alphabet is malformed, this method returns the error as a `string`.
 *
 * @param alphabet - an ordered string which maps each index to a character,
 * e.g. `0123456789`.
 * @privateRemarks
 * Algorithm from the `base-x` implementation (which is derived from the
 * original Satoshi implementation): https://github.com/cryptocoinjs/base-x
 */
exports.createBaseConverter = (alphabet) => {
    const undefinedValue = 255;
    const Uint8ArrayBase = 256;
    if (alphabet.length >= undefinedValue)
        return BaseConversionError.tooLong;
    const alphabetMap = new Uint8Array(Uint8ArrayBase).fill(undefinedValue);
    // eslint-disable-next-line functional/no-loop-statement, functional/no-let, no-plusplus
    for (let index = 0; index < alphabet.length; index++) {
        const characterCode = alphabet.charCodeAt(index);
        if (alphabetMap[characterCode] !== undefinedValue) {
            return BaseConversionError.ambiguousCharacter;
        }
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        alphabetMap[characterCode] = index;
    }
    const base = alphabet.length;
    const paddingCharacter = alphabet.charAt(0);
    const factor = Math.log(base) / Math.log(Uint8ArrayBase);
    const inverseFactor = Math.log(Uint8ArrayBase) / Math.log(base);
    return {
        // eslint-disable-next-line complexity
        decode: (input) => {
            if (input.length === 0)
                return Uint8Array.of();
            const firstNonZeroIndex = input
                .split('')
                .findIndex((character) => character !== paddingCharacter);
            if (firstNonZeroIndex === -1) {
                return new Uint8Array(input.length);
            }
            const requiredLength = Math.floor((input.length - firstNonZeroIndex) * factor + 1);
            const decoded = new Uint8Array(requiredLength);
            /* eslint-disable functional/no-let, functional/no-expression-statement */
            let nextByte = firstNonZeroIndex;
            let remainingBytes = 0;
            // eslint-disable-next-line functional/no-loop-statement
            while (input[nextByte] !== undefined) {
                let carry = alphabetMap[input.charCodeAt(nextByte)];
                if (carry === undefinedValue)
                    return BaseConversionError.unknownCharacter;
                let digit = 0;
                // eslint-disable-next-line functional/no-loop-statement
                for (let steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1; 
                // eslint-disable-next-line no-plusplus
                steps--, digit++) {
                    carry += Math.floor(base * decoded[steps]);
                    // eslint-disable-next-line functional/immutable-data
                    decoded[steps] = Math.floor(carry % Uint8ArrayBase);
                    carry = Math.floor(carry / Uint8ArrayBase);
                }
                remainingBytes = digit;
                // eslint-disable-next-line no-plusplus
                nextByte++;
            }
            /* eslint-enable functional/no-let, functional/no-expression-statement */
            const firstNonZeroResultDigit = decoded.findIndex((value) => value !== 0);
            const bin = new Uint8Array(firstNonZeroIndex + (requiredLength - firstNonZeroResultDigit));
            // eslint-disable-next-line functional/no-expression-statement
            bin.set(decoded.slice(firstNonZeroResultDigit), firstNonZeroIndex);
            return bin;
        },
        // eslint-disable-next-line complexity
        encode: (input) => {
            if (input.length === 0)
                return '';
            const firstNonZeroIndex = input.findIndex((byte) => byte !== 0);
            if (firstNonZeroIndex === -1) {
                return paddingCharacter.repeat(input.length);
            }
            const requiredLength = Math.floor((input.length - firstNonZeroIndex) * inverseFactor + 1);
            const encoded = new Uint8Array(requiredLength);
            /* eslint-disable functional/no-let, functional/no-expression-statement */
            let nextByte = firstNonZeroIndex;
            let remainingBytes = 0;
            // eslint-disable-next-line functional/no-loop-statement
            while (nextByte !== input.length) {
                let carry = input[nextByte];
                let digit = 0;
                // eslint-disable-next-line functional/no-loop-statement
                for (let steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1; 
                // eslint-disable-next-line no-plusplus
                steps--, digit++) {
                    carry += Math.floor(Uint8ArrayBase * encoded[steps]);
                    // eslint-disable-next-line functional/immutable-data
                    encoded[steps] = Math.floor(carry % base);
                    carry = Math.floor(carry / base);
                }
                remainingBytes = digit;
                // eslint-disable-next-line no-plusplus
                nextByte++;
            }
            /* eslint-enable functional/no-let, functional/no-expression-statement */
            const firstNonZeroResultDigit = encoded.findIndex((value) => value !== 0);
            const padding = paddingCharacter.repeat(firstNonZeroIndex);
            return encoded
                .slice(firstNonZeroResultDigit)
                .reduce((all, digit) => all + alphabet.charAt(digit), padding);
        },
    };
};
exports.bitcoinBase58Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const base58 = exports.createBaseConverter(exports.bitcoinBase58Alphabet);
/**
 * Convert a bitcoin-style base58-encoded string to a Uint8Array.
 *
 * See `createBaseConverter` for format details.
 * @param input - a valid base58-encoded string to decode
 */
exports.base58ToBin = base58.decode;
/**
 * Convert a Uint8Array to a bitcoin-style base58-encoded string.
 *
 * See `createBaseConverter` for format details.
 * @param input - the Uint8Array to base58 encode
 */
exports.binToBase58 = base58.encode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1jb252ZXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9mb3JtYXQvYmFzZS1jb252ZXJ0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBWSxtQkFJWDtBQUpELFdBQVksbUJBQW1CO0lBQzdCLG9GQUE2RCxDQUFBO0lBQzdELHlHQUFrRixDQUFBO0lBQ2xGLCtGQUF3RSxDQUFBO0FBQzFFLENBQUMsRUFKVyxtQkFBbUIsR0FBbkIsMkJBQW1CLEtBQW5CLDJCQUFtQixRQUk5QjtBQU9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkc7QUFDVSxRQUFBLG1CQUFtQixHQUFHLENBQ2pDLFFBQWdCLEVBQ3FCLEVBQUU7SUFDdkMsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0lBQzNCLE1BQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQztJQUUzQixJQUFJLFFBQVEsQ0FBQyxNQUFNLElBQUksY0FBYztRQUFFLE9BQU8sbUJBQW1CLENBQUMsT0FBTyxDQUFDO0lBRTFFLE1BQU0sV0FBVyxHQUFHLElBQUksVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUV4RSx3RkFBd0Y7SUFDeEYsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDcEQsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqRCxJQUFJLFdBQVcsQ0FBQyxhQUFhLENBQUMsS0FBSyxjQUFjLEVBQUU7WUFDakQsT0FBTyxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQztTQUMvQztRQUNELHlGQUF5RjtRQUN6RixXQUFXLENBQUMsYUFBYSxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQ3BDO0lBRUQsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUM3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
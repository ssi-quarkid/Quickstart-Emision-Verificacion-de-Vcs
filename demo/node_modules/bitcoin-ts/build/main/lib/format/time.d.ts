/**
 * The minimum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
export declare const minimumLocktimeDate: Date;
/**
 * The maximum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
export declare const maximumLocktimeDate: Date;
export declare enum LocktimeError {
    outOfRange = "The provided Date is outside of the range which can be encoded in locktime.",
    incorrectLength = "The provided locktime is not the correct length (4 bytes)."
}
/**
 * Convert a Javascript `Date` object to its equivalent transaction `locktime`
 * representation. The `date` is rounded to the nearest second (the precision of
 * `locktime` Dates).
 *
 * Note: a block-based locktime can simply be encoded with `numberToBinUint32LE`
 * (provided it is no larger than the maximum, `499999999`).
 *
 * @param date - the Date to convert to a locktime Uint8Array
 */
export declare const dateToLocktime: (date: Date) => Uint8Array | LocktimeError.outOfRange;
/**
 * Parse a locktime, returning a `number` for block heights, a `Date` for block
 * times, or a string for parsing errors.
 *
 * @param bin - the 4-byte Uint8Array locktime to parse
 */
export declare const parseLocktime: (bin: Uint8Array) => number | Date | LocktimeError.incorrectLength;
//# sourceMappingURL=time.d.ts.map
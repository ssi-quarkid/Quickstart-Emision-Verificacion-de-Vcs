"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const numbers_1 = require("./numbers");
var Constants;
(function (Constants) {
    Constants[Constants["msPerLocktimeSecond"] = 1000] = "msPerLocktimeSecond";
    Constants[Constants["minimumTimestamp"] = 500000000] = "minimumTimestamp";
    Constants[Constants["maximumLocktime"] = 4294967295] = "maximumLocktime";
    Constants[Constants["byteLength"] = 4] = "byteLength";
})(Constants || (Constants = {}));
/**
 * The minimum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
exports.minimumLocktimeDate = new Date(Constants.minimumTimestamp * Constants.msPerLocktimeSecond);
/**
 * The maximum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
exports.maximumLocktimeDate = new Date(Constants.maximumLocktime * Constants.msPerLocktimeSecond);
var LocktimeError;
(function (LocktimeError) {
    LocktimeError["outOfRange"] = "The provided Date is outside of the range which can be encoded in locktime.";
    LocktimeError["incorrectLength"] = "The provided locktime is not the correct length (4 bytes).";
})(LocktimeError = exports.LocktimeError || (exports.LocktimeError = {}));
/**
 * Convert a Javascript `Date` object to its equivalent transaction `locktime`
 * representation. The `date` is rounded to the nearest second (the precision of
 * `locktime` Dates).
 *
 * Note: a block-based locktime can simply be encoded with `numberToBinUint32LE`
 * (provided it is no larger than the maximum, `499999999`).
 *
 * @param date - the Date to convert to a locktime Uint8Array
 */
exports.dateToLocktime = (date) => date < exports.minimumLocktimeDate || date > exports.maximumLocktimeDate
    ? LocktimeError.outOfRange
    : numbers_1.numberToBinUint32LE(Math.round(date.getTime() / Constants.msPerLocktimeSecond));
/**
 * Parse a locktime, returning a `number` for block heights, a `Date` for block
 * times, or a string for parsing errors.
 *
 * @param bin - the 4-byte Uint8Array locktime to parse
 */
exports.parseLocktime = (bin) => {
    if (bin.length !== Constants.byteLength)
        return LocktimeError.incorrectLength;
    const parsed = numbers_1.binToNumberUint32LE(bin);
    return parsed >= Constants.minimumTimestamp
        ? new Date(parsed * Constants.msPerLocktimeSecond)
        : parsed;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvZm9ybWF0L3RpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx1Q0FBcUU7QUFFckUsSUFBSyxTQUtKO0FBTEQsV0FBSyxTQUFTO0lBQ1osMEVBQTBCLENBQUE7SUFDMUIseUVBQTRCLENBQUE7SUFDNUIsd0VBQTRCLENBQUE7SUFDNUIscURBQWMsQ0FBQTtBQUNoQixDQUFDLEVBTEksU0FBUyxLQUFULFNBQVMsUUFLYjtBQUVEOzs7R0FHRztBQUNVLFFBQUEsbUJBQW1CLEdBQUcsSUFBSSxJQUFJLENBQ3pDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsbUJBQW1CLENBQzNELENBQUM7QUFFRjs7O0dBR0c7QUFDVSxRQUFBLG1CQUFtQixHQUFHLElBQUksSUFBSSxDQUN6QyxTQUFTLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQyxtQkFBbUIsQ0FDMUQsQ0FBQztBQUVGLElBQVksYUFHWDtBQUhELFdBQVksYUFBYTtJQUN2QiwyR0FBMEYsQ0FBQTtJQUMxRiwrRkFBOEUsQ0FBQTtBQUNoRixDQUFDLEVBSFcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFHeEI7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDVSxRQUFBLGNBQWMsR0FBRyxDQUFDLElBQVUsRUFBRSxFQUFFLENBQzNDLElBQUksR0FBRywyQkFBbUIsSUFBSSxJQUFJLEdBQUcsMkJBQW1CO0lBQ3RELENBQUMsQ0FBQyxhQUFhLENBQUMsVUFBVTtJQUMxQixDQUFDLENBQUMsNkJBQW1CLENBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUMzRCxDQUFDO0FBRVI7Ozs7O0dBS0c7QUFDVSxRQUFBLGFBQWEsR0FBRyxDQUFDLEdBQWUsRUFBRSxFQUFFO0lBQy9DLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxTQUFTLENBQUMsVUFBVTtRQUFFLE9BQU8sYUFBYSxDQUFDLGVBQWUsQ0FBQztJQUM5RSxNQUFNLE1BQU0sR0FBRyw2QkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QyxPQUFPLE1BQU0sSUFBSSxTQUFTLENBQUMsZ0JBQWdCO1FBQ3pDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLG1CQUFtQixDQUFDO1FBQ2xELENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDYixDQUFDLENBQUMifQ==
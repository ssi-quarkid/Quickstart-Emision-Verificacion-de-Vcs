"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns an array of incrementing values starting at `begin` and incrementing by one for `length`.
 *
 * E.g.: `range(3)` → `[0, 1, 2]` and `range(3, 1)` → `[1, 2, 3]`
 *
 * @param length - the number of elements in the array
 * @param begin - the index at which the range starts (default: `0`)
 */
exports.range = (length, begin = 0) => Array.from({ length }, (_, index) => begin + index);
/**
 * Split a string into an array of `chunkLength` strings. The final string may have a length between 1 and `chunkLength`.
 *
 * E.g.: `splitEvery('abcde', 2)` → `['ab', 'cd', 'e']`
 */
exports.splitEvery = (input, chunkLength) => exports.range(Math.ceil(input.length / chunkLength))
    .map((index) => index * chunkLength)
    .map((begin) => input.slice(begin, begin + chunkLength));
const hexByteWidth = 2;
const hexadecimal = 16;
/**
 * Decode a hexadecimal-encoded string into a Uint8Array.
 *
 * E.g.: `hexToBin('2a64ff')` → `new Uint8Array([42, 100, 255])`
 *
 * Note, this method always completes. If `validHex` is not divisible by 2,
 * the final byte will be parsed as if it were prepended with a `0` (e.g. `aaa`
 * is interpreted as `aa0a`). If `validHex` is potentially malformed, check
 * it with `isHex` before calling this method.
 *
 * @param validHex - a string of valid, hexadecimal-encoded data
 */
exports.hexToBin = (validHex) => Uint8Array.from(exports.splitEvery(validHex, hexByteWidth).map((byte) => parseInt(byte, hexadecimal)));
const hexByteLength = 2;
/**
 * For use before `hexToBin`. Returns true if the provided string is valid
 * hexadecimal (length is divisible by 2, only uses hexadecimal characters).
 * @param maybeHex - a string to test
 */
exports.isHex = (maybeHex) => maybeHex.length % hexByteLength === 0 && !/[^a-fA-F0-9]/u.test(maybeHex);
/**
 * Encode a Uint8Array into a hexadecimal-encoded string.
 *
 * E.g.: `binToHex(new Uint8Array([42, 100, 255]))` → `'2a64ff'`
 *
 * @param bytes - a Uint8Array to encode
 */
exports.binToHex = (bytes) => bytes.reduce((str, byte) => str + byte.toString(hexadecimal).padStart(hexByteWidth, '0'), '');
/**
 * Decode a hexadecimal-encoded string into bytes, reverse it, then re-encode.
 *
 * @param validHex - a string of valid, hexadecimal-encoded data. See
 * `hexToBin` for more information.
 */
exports.swapEndianness = (validHex) => exports.binToHex(exports.hexToBin(validHex).reverse());
/**
 * Reduce an array of `Uint8Array`s into a single `Uint8Array`.
 * @param array - the array of `Uint8Array`s to flatten
 */
exports.flattenBinArray = (array) => {
    const totalLength = array.reduce((total, bin) => total + bin.length, 0);
    const flattened = new Uint8Array(totalLength);
    // eslint-disable-next-line functional/no-expression-statement
    array.reduce((index, bin) => {
        // eslint-disable-next-line functional/no-expression-statement
        flattened.set(bin, index);
        return index + bin.length;
    }, 0);
    return flattened;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGV4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9mb3JtYXQvaGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7R0FPRztBQUNVLFFBQUEsS0FBSyxHQUFHLENBQUMsTUFBYyxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUNqRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFFdEQ7Ozs7R0FJRztBQUNVLFFBQUEsVUFBVSxHQUFHLENBQUMsS0FBYSxFQUFFLFdBQW1CLEVBQUUsRUFBRSxDQUMvRCxhQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQyxDQUFDO0tBQ3pDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQztLQUNuQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBRTdELE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBQztBQUN2QixNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFFdkI7Ozs7Ozs7Ozs7O0dBV0c7QUFDVSxRQUFBLFFBQVEsR0FBRyxDQUFDLFFBQWdCLEVBQUUsRUFBRSxDQUMzQyxVQUFVLENBQUMsSUFBSSxDQUNiLGtCQUFVLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQzlDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQzVCLENBQ0YsQ0FBQztBQUVKLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQztBQUV4Qjs7OztHQUlHO0FBQ1UsUUFBQSxLQUFLLEdBQUcsQ0FBQyxRQUFnQixFQUFFLEVBQUUsQ0FDeEMsUUFBUSxDQUFDLE1BQU0sR0FBRyxhQUFhLEtBQUssQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUUzRTs7Ozs7O0dBTUc7QUFDVSxRQUFBLFFBQVEsR0FBRyxDQUFDLEtBQWlCLEVBQUUsRUFBRSxDQUM1QyxLQUFLLENBQUMsTUFBTSxDQUNWLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsRUFDM0UsRUFBRSxDQUNILENBQUM7QUFFSjs7Ozs7R0FLRztBQUNVLFFBQUEsY0FBYyxHQUFHLENBQUMsUUFBZ0IsRUFBRSxFQUFFLENBQ2pELGdCQUFRLENBQUMsZ0JBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBRXpDOzs7R0FHRztBQUNVLFFBQUEsZUFBZSxHQUFHLENBQUMsS0FBNEIsRUFBRSxFQUFFO0lBQzlELE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RSxNQUFNLFNBQVMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5Qyw4REFBOEQ7SUFDOUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUMxQiw4REFBOEQ7UUFDOUQsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDMUIsT0FBTyxLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztJQUM1QixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDTixPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUMifQ==
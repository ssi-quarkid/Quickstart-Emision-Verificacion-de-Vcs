"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../crypto/crypto");
const hmac_1 = require("../crypto/hmac");
const format_1 = require("../format/format");
const utf8_1 = require("../format/utf8");
const key_utils_1 = require("./key-utils");
/**
 * Instantiate an object containing WASM implementations of each cryptographic
 * algorithm required by BIP32 utilities in this library.
 *
 * These WASM implementations provide optimal performance across every
 * JavaScript runtime, but depending on your application, you may prefer to
 * instantiate native implementations such as those provided by Node.js or the
 * `crypto.subtle` API (to reduce bundle size) or an external module (for
 * synchronous instantiation).
 */
exports.instantiateBIP32Crypto = async () => {
    const [ripemd160, secp256k1, sha256, sha512] = await Promise.all([
        crypto_1.instantiateRipemd160(),
        crypto_1.instantiateSecp256k1(),
        crypto_1.instantiateSha256(),
        crypto_1.instantiateSha512(),
    ]);
    return { ripemd160, secp256k1, sha256, sha512 };
};
const bip32HmacSha512Key = utf8_1.utf8ToBin('Bitcoin seed');
const halfHmacSha512Length = 32;
/**
 * Derive an `HdPrivateNode` from the provided seed following the BIP32
 * specification. A seed should include between 16 bytes and 64 bytes of
 * entropy (recommended: 32 bytes).
 *
 * @param crypto - an implementation of sha512
 * @param seed - the entropy from which to derive the `HdPrivateNode`
 * @param assumeValidity - if set, the derived private key will not be checked
 * for validity, and will be assumed valid if `true` or invalid if `false` (this
 * is useful for testing)
 */
exports.deriveHdPrivateNodeFromSeed = (crypto, seed, assumeValidity) => {
    const mac = hmac_1.hmacSha512(crypto.sha512, bip32HmacSha512Key, seed);
    const privateKey = mac.slice(0, halfHmacSha512Length);
    const chainCode = mac.slice(halfHmacSha512Length);
    const depth = 0;
    const childIndex = 0;
    const parentFingerprint = Uint8Array.from([0, 0, 0, 0]);
    const valid = assumeValidity !== null && assumeValidity !== void 0 ? assumeValidity : key_utils_1.validateSecp256k1PrivateKey(privateKey);
    return (valid
        ? { chainCode, childIndex, depth, parentFingerprint, privateKey, valid }
        : {
            chainCode,
            childIndex,
            depth,
            invalidPrivateKey: privateKey,
            parentFingerprint,
            valid,
        });
};
/**
 * Derive the public identifier for a given HD private node. This is used to
 * uniquely identify HD nodes in software. The first 4 bytes of this identifier
 * are considered its "fingerprint".
 *
 * @param crypto - implementations of sha256, ripemd160, and secp256k1
 * compressed public key derivation
 * @param hdPrivateNode - the HD private node from which to derive the public
 * identifier (not require to be valid)
 */
exports.deriveHdPrivateNodeIdentifier = (crypto, hdPrivateNode) => crypto.ripemd160.hash(crypto.sha256.hash(crypto.secp256k1.derivePublicKeyCompressed(hdPrivateNode.privateKey)));
/**
 * Derive the public identifier for a given `HdPublicNode`. This is used to
 * uniquely identify HD nodes in software. The first 4 bytes of this identifier
 * are considered its fingerprint.
 *
 * @param crypto - implementations of sha256 and ripemd160
 */
exports.deriveHdPublicNodeIdentifier = (crypto, node) => crypto.ripemd160.hash(crypto.sha256.hash(node.publicKey));
/**
 * The 4-byte version indicating the network and type of an `HdPrivateKey` or
 * `HdPublicKey`.
 */
var HdKeyVersion;
(function (HdKeyVersion) {
    /**
     * Version indicating the HD key is an `HdPrivateKey` intended for use on the
     * main network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `xprv`.
     *
     * Hex: `0x0488ade4`
     */
    HdKeyVersion[HdKeyVersion["mainnetPrivateKey"] = 76066276] = "mainnetPrivateKey";
    /**
     * Version indicating the HD key is an `HdPublicKey` intended for use on the
     * main network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `xpub`.
     *
     * Hex: `0x0488b21e`
     */
    HdKeyVersion[HdKeyVersion["mainnetPublicKey"] = 76067358] = "mainnetPublicKey";
    /**
     * Version indicating the HD key is an `HdPrivateKey` intended for use on the
     * test network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `tprv`.
     *
     * Hex: `0x04358394`
     */
    HdKeyVersion[HdKeyVersion["testnetPrivateKey"] = 70615956] = "testnetPrivateKey";
    /**
     * Version indicating the HD key is an `HdPublicKey` intended for use on the
     * test network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `tpub`.
     *
     * Hex: `0x043587cf`
     */
    HdKeyVersion[HdKeyVersion["testnetPublicKey"] = 70617039] = "testnetPublicKey";
})(HdKeyVersion = exports.HdKeyVersion || (exports.HdKeyVersion = {}));
/**
 * An error in the decoding of an HD public or private key.
 */
var HdKeyDecodingError;
(function (HdKeyDecodingError) {
    HdKeyDecodingError["incorrectLength"] = "HD key decoding error: length is incorrect (must encode 82 bytes).";
    HdKeyDecodingError["invalidChecksum"] = "HD key decoding error: checksum is invalid.";
    HdKeyDecodingError["invalidPrivateNode"] = "HD key decoding error: the key for this HD private node is not a valid Secp256k1 private key.";
    HdKeyDecodingError["missingPrivateKeyPaddingByte"] = "HD key decoding error: version indicates a private key, but the key data is missing a padding byte.";
    HdKeyDecodingError["privateKeyExpected"] = "HD key decoding error: expected an HD private key, but encountered an HD public key.";
    HdKeyDecodingError["publicKeyExpected"] = "HD key decoding error: expected an HD public key, but encountered an HD private key.";
    HdKeyDecodingError["unknownCharacter"] = "HD key decoding error: key includes a non-base58 character.";
    HdKeyDecodingError["unknownVersion"] = "HD key decoding error: key uses an unknown version.";
})(HdKeyDecodingError = exports.HdKeyDecodingError || (exports.HdKeyDecodingError = {}));
/**
 * Decode an HD private key as defined by BIP32, returning a `node` and a
 * `network`. Decoding errors are returned as strings.
 *
 * If the type of the key is known, use `decodeHdPrivateKey` or
 * `decodeHdPublicKey`.
 *
 * @param crypto - an implementation of sha256
 * @param hdKey - a BIP32 HD private key or HD public key
 */
// eslint-disable-next-line complexity
exports.decodeHdKey = (crypto, hdKey) => {
    const decoded = format_1.base58ToBin(hdKey);
    if (decoded === format_1.BaseConversionError.unknownCharacter)
        return HdKeyDecodingError.unknownCharacter;
    const expectedLength = 82;
    if (decoded.length !== expectedLength)
        return HdKeyDecodingError.incorrectLength;
    const checksumIndex = 78;
    const payload = decoded.slice(0, checksumIndex);
    const checksumBits = decoded.slice(checksumIndex);
    const checksum = crypto.sha256.hash(crypto.sha256.hash(payload));
    if (!checksumBits.every((value, i) => value === checksum[i])) {
        return HdKeyDecodingError.invalidChecksum;
    }
    const depthIndex = 4;
    const fingerprintIndex = 5;
    const childIndexIndex = 9;
    const chainCodeIndex = 13;
    const keyDataIndex = 45;
    const version = new DataView(decoded.buffer, decoded.byteOffset, depthIndex).getUint32(0);
    const depth = decoded[depthIndex];
    const parentFingerprint = decoded.slice(fingerprintIndex, childIndexIndex);
    const childIndex = new DataView(decoded.buffer, decoded.byteOffset + childIndexIndex, decoded.byteOffset + chainCodeIndex).getUint32(0);
    const chainCode = decoded.slice(chainCodeIndex, keyDataIndex);
    const keyData = decoded.slice(keyDataIndex, checksumIndex);
    const isPrivateKey = version === HdKeyVersion.mainnetPrivateKey ||
        version === HdKeyVersion.testnetPrivateKey;
    if (isPrivateKey && keyData[0] !== 0x00) {
        return HdKeyDecodingError.missingPrivateKeyPaddingByte;
    }
    if (isPrivateKey) {
        const privateKey = keyData.slice(1);
        const valid = key_utils_1.validateSecp256k1PrivateKey(privateKey);
        return {
            node: valid
                ? {
                    chainCode,
                    childIndex,
                    depth,
                    parentFingerprint,
                    privateKey,
                    valid: true,
                }
                : {
                    chainCode,
                    childIndex,
                    depth,
                    invalidPrivateKey: privateKey,
                    parentFingerprint,
                    valid: false,
                },
            version: version,
        };
    }
    const isPublicKey = version === HdKeyVersion.mainnetPublicKey ||
        version === HdKeyVersion.testnetPublicKey;
    if (!isPublicKey) {
        return HdKeyDecodingError.unknownVersion;
    }
    return {
        node: {
            chainCode,
            childIndex,
            depth,
            parentFingerprint,
            publicKey: keyData,
        },
        version: version,
    };
};
/**
 * Decode an HD private key as defined by BIP32.
 *
 * This method is similar to `decodeHdKey` but ensures that the result is a
 * valid HD private node. Decoding error messages are returned as strings.
 *
 * @param crypto - an implementation of sha256
 * @param hdPrivateKey - a BIP32 HD private key
 */
exports.decodeHdPrivateKey = (crypto, hdPrivateKey) => {
    const decoded = exports.decodeHdKey(crypto, hdPrivateKey);
    if (typeof decoded === 'string')
        return decoded;
    if ('publicKey' in decoded.node) {
        return HdKeyDecodingError.privateKeyExpected;
    }
    if (!decoded.node.valid) {
        return HdKeyDecodingError.invalidPrivateNode;
    }
    if (decoded.version === HdKeyVersion.mainnetPrivateKey) {
        return {
            network: 'mainnet',
            node: decoded.node,
        };
    }
    return {
        network: 'testnet',
        node: decoded.node,
    };
};
/**
 * Decode an HD public key as defined by BIP32.
 *
 * This method is similar to `decodeHdKey` but ensures that the result is an
 * HD public node. Decoding error messages are returned as strings.
 *
 * @param crypto - an implementation of sha256
 * @param hdPublicKey - a BIP32 HD public key
 */
exports.decodeHdPublicKey = (crypto, hdPublicKey) => {
    const decoded = exports.decodeHdKey(crypto, hdPublicKey);
    if (typeof decoded === 'string')
        return decoded;
    if (decoded.version === HdKeyVersion.mainnetPublicKey) {
        return {
            network: 'mainnet',
            node: decoded.node,
        };
    }
    if (decoded.version === HdKeyVersion.testnetPublicKey) {
        return {
            network: 'testnet',
            node: decoded.node,
        };
    }
    return HdKeyDecodingError.publicKeyExpected;
};
/**
 * Encode an HD private key (as defined by BIP32) given an HD private node.
 *
 * @param crypto - an implementation of sha256
 * @param keyParameters - a valid HD private node and the network for which to
 * encode the key
 */
exports.encodeHdPrivateKey = (crypto, keyParameters) => {
    const version = format_1.numberToBinUint32BE(keyParameters.network === 'mainnet'
        ? HdKeyVersion.mainnetPrivateKey
        : HdKeyVersion.testnetPrivateKey);
    const depth = Uint8Array.of(keyParameters.node.depth);
    const childIndex = format_1.numberToBinUint32BE(keyParameters.node.childIndex);
    const isPrivateKey = Uint8Array.of(0x00);
    const payload = format_1.flattenBinArray([
        version,
        depth,
        keyParameters.node.parentFingerprint,
        childIndex,
        keyParameters.node.chainCode,
        isPrivateKey,
        keyParameters.node.privateKey,
    ]);
    const checksumLength = 4;
    const checksum = crypto.sha256
        .hash(crypto.sha256.hash(payload))
        .slice(0, checksumLength);
    return format_1.binToBase58(format_1.flattenBinArray([payload, checksum]));
};
/**
 * Encode an HD public key (as defined by BIP32) given an HD public node.
 *
 * @param crypto - an implementation of sha256
 * @param keyParameters - an HD public node and the network for which to encode
 * the key
 */
exports.encodeHdPublicKey = (crypto, keyParameters) => {
    const version = format_1.numberToBinUint32BE(keyParameters.network === 'mainnet'
        ? HdKeyVersion.mainnetPublicKey
        : HdKeyVersion.testnetPublicKey);
    const depth = Uint8Array.of(keyParameters.node.depth);
    const childIndex = format_1.numberToBinUint32BE(keyParameters.node.childIndex);
    const payload = format_1.flattenBinArray([
        version,
        depth,
        keyParameters.node.parentFingerprint,
        childIndex,
        keyParameters.node.chainCode,
        keyParameters.node.publicKey,
    ]);
    const checksumLength = 4;
    const checksum = crypto.sha256
        .hash(crypto.sha256.hash(payload))
        .slice(0, checksumLength);
    return format_1.binToBase58(format_1.flattenBinArray([payload, checksum]));
};
/**
 * Derive the HD public node of an HD private node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See `crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode` for
 * details.
 *
 * @param crypto - an implementation of secp256k1 compressed public key
 * derivation (e.g. `instantiateSecp256k1`)
 * @param node - a valid HD private node
 */
exports.deriveHdPublicNode = (crypto, node) => {
    return Object.assign(Object.assign({ chainCode: node.chainCode, childIndex: node.childIndex, depth: node.depth, parentFingerprint: node.parentFingerprint }, (node.parentIdentifier === undefined
        ? {}
        : { parentIdentifier: node.parentIdentifier })), { publicKey: crypto.secp256k1.derivePublicKeyCompressed(node.privateKey) });
};
/**
 * An error in the derivation of child HD public or private nodes.
 */
var HdNodeDerivationError;
(function (HdNodeDerivationError) {
    HdNodeDerivationError["childIndexExceedsMaximum"] = "HD key derivation error: child index exceeds maximum (4294967295).";
    HdNodeDerivationError["nextChildIndexRequiresHardenedAlgorithm"] = "HD key derivation error: an incredibly rare HMAC-SHA512 result occurred, and incrementing the child index would require switching to the hardened algorithm.";
    HdNodeDerivationError["hardenedDerivationRequiresPrivateNode"] = "HD key derivation error: derivation for hardened child indexes (indexes greater than or equal to 2147483648) requires an HD private node.";
    HdNodeDerivationError["invalidDerivationPath"] = "HD key derivation error: invalid derivation path \u2013 paths must begin with \"m\" or \"M\" and contain only forward slashes (\"/\"), apostrophes (\"'\"), child index numbers.";
    HdNodeDerivationError["invalidPrivateDerivationPrefix"] = "HD key derivation error: private derivation paths must begin with \"m\".";
    HdNodeDerivationError["invalidPublicDerivationPrefix"] = "HD key derivation error: public derivation paths must begin with \"M\".";
})(HdNodeDerivationError = exports.HdNodeDerivationError || (exports.HdNodeDerivationError = {}));
/**
 * Derive a child HD private node from an HD private node.
 *
 * To derive a child HD public node, use `deriveHdPublicNode` on the result of
 * this method. If the child uses a non-hardened index, it's also possible to
 * use `deriveHdPublicNodeChild`.
 *
 * @privateRemarks
 * The `Secp256k1.addTweakPrivateKey` method throws if the tweak is out of range
 * or if the resulting private key would be invalid. The procedure to handle
 * this error is standardized by BIP32: return the HD node at the next child
 * index. (Regardless, this scenario is incredibly unlikely without a weakness
 * in HMAC-SHA512.)
 *
 * @param crypto - implementations of sha256, ripemd160, secp256k1 compressed
 * public key derivation, and secp256k1 private key "tweak addition"
 * (application of the EC group operation) – these are available via
 * `instantiateBIP32Crypto`
 * @param node - the valid HD private node from which to derive the child node
 * @param index - the index at which to derive the child node - indexes greater
 * than or equal to the hardened index offset (`0x80000000`/`2147483648`) are
 * derived using the "hardened" derivation algorithm
 */
// eslint-disable-next-line complexity
exports.deriveHdPrivateNodeChild = (crypto, node, index) => {
    const maximumIndex = 0xffffffff;
    if (index > maximumIndex) {
        return HdNodeDerivationError.childIndexExceedsMaximum;
    }
    const hardenedIndexOffset = 0x80000000;
    const useHardenedAlgorithm = index >= hardenedIndexOffset;
    const keyMaterial = useHardenedAlgorithm
        ? node.privateKey
        : crypto.secp256k1.derivePublicKeyCompressed(node.privateKey);
    const serialization = Uint8Array.from([
        ...(useHardenedAlgorithm ? [0x00] : []),
        ...keyMaterial,
        ...format_1.numberToBinUint32BE(index),
    ]);
    const derivation = hmac_1.hmacSha512(crypto.sha512, node.chainCode, serialization);
    const tweakValueLength = 32;
    const tweakValue = derivation.slice(0, tweakValueLength);
    const nextChainCode = derivation.slice(tweakValueLength);
    // eslint-disable-next-line functional/no-try-statement
    try {
        const nextPrivateKey = crypto.secp256k1.addTweakPrivateKey(node.privateKey, tweakValue);
        const parentIdentifier = exports.deriveHdPrivateNodeIdentifier(crypto, node);
        const parentFingerprintLength = 4;
        return {
            chainCode: nextChainCode,
            childIndex: index,
            depth: node.depth + 1,
            parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
            parentIdentifier,
            privateKey: nextPrivateKey,
            valid: true,
        };
    }
    catch (error) /* istanbul ignore next - testing requires >2^127 brute force */ {
        if (index === hardenedIndexOffset - 1) {
            return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
        }
        return exports.deriveHdPrivateNodeChild(crypto, node, index + 1);
    }
};
/**
 * Derive a non-hardened child HD public node from an HD public node.
 *
 * Because hardened derivation also requires knowledge of the parent private
 * node, it's not possible to use an HD public node to derive a hardened child
 * HD public node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See `crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode` for
 * details.
 *
 * @privateRemarks
 * The `Secp256k1.addTweakPublicKeyCompressed` method throws if the tweak is out
 * of range or if the resulting public key would be invalid. The procedure to
 * handle this error is standardized by BIP32: return the HD node at the next
 * child index. (Regardless, this scenario is incredibly unlikely without a
 * weakness in HMAC-SHA512.)
 *
 * @param crypto - implementations of sha256, sha512, ripemd160, and secp256k1
 * compressed public key "tweak addition" (application of the EC group
 * operation) – these are available via `instantiateBIP32Crypto`
 * @param node - the HD public node from which to derive the child public node
 * @param index - the index at which to derive the child node
 */
exports.deriveHdPublicNodeChild = (crypto, node, index) => {
    const hardenedIndexOffset = 0x80000000;
    if (index >= hardenedIndexOffset) {
        return HdNodeDerivationError.hardenedDerivationRequiresPrivateNode;
    }
    const serialization = Uint8Array.from([
        ...node.publicKey,
        ...format_1.numberToBinUint32BE(index),
    ]);
    const derivation = hmac_1.hmacSha512(crypto.sha512, node.chainCode, serialization);
    const tweakValueLength = 32;
    const tweakValue = derivation.slice(0, tweakValueLength);
    const nextChainCode = derivation.slice(tweakValueLength);
    // eslint-disable-next-line functional/no-try-statement
    try {
        const nextPublicKey = crypto.secp256k1.addTweakPublicKeyCompressed(node.publicKey, tweakValue);
        const parentIdentifier = exports.deriveHdPublicNodeIdentifier(crypto, node);
        const parentFingerprintLength = 4;
        return {
            chainCode: nextChainCode,
            childIndex: index,
            depth: node.depth + 1,
            parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
            parentIdentifier,
            publicKey: nextPublicKey,
        };
    }
    catch (error) /* istanbul ignore next - testing requires >2^127 brute force */ {
        if (index === hardenedIndexOffset - 1) {
            return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
        }
        return exports.deriveHdPublicNodeChild(crypto, node, index + 1);
    }
};
/**
 * Derive a child HD node from a parent node given a derivation path. The
 * resulting node is the same type as the parent node (private nodes return
 * private nodes, public nodes return public nodes).
 *
 * @remarks
 * The derivation path uses the notation specified in BIP32:
 *
 * The first character must be either `m` for private derivation or `M` for
 * public derivation, followed by sets of `/` and a number representing the
 * child index used in the derivation at that depth. Hardened derivation is
 * represented by a trailing `'`, and may only appear in private derivation
 * paths (hardened derivation requires knowledge of the private key). Hardened
 * child indexes are represented with the hardened index offset (`2147483648`)
 * subtracted.
 *
 * For example, `m/0/1'/2` uses private derivation (`m`), with child indexes in
 * the following order:
 *
 * `derivePrivate(derivePrivate(derivePrivate(node, 0), 2147483648 + 1), 2)`
 *
 * Likewise, `M/3/4/5` uses public derivation (`M`), with child indexes in the
 * following order:
 *
 * `derivePublic(derivePublic(derivePublic(node, 3), 4), 5)`
 *
 * Because hardened derivation requires a private node, paths which specify
 * public derivation (`M`) using hardened derivation (`'`) will return an error.
 * To derive the public node associated with a child private node which requires
 * hardened derivation, begin with private derivation, then provide the result
 * to `deriveHdPublicNode`.
 *
 * @param crypto - implementations of sha256, sha512, ripemd160, and secp256k1
 * derivation functions – these are available via `instantiateBIP32Crypto`
 * @param node - the HD node from which to begin the derivation (for paths
 * beginning with `m`, an `HdPrivateNodeValid`; for paths beginning with `M`, an
 * `HdPublicNode`)
 * @param path - the BIP32 derivation path, e.g. `m/0/1'/2` or `M/3/4/5`
 */
// eslint-disable-next-line complexity
exports.deriveHdPath = (crypto, node, path) => {
    const validDerivationPath = /^[mM](?:\/[0-9]+'?)*$/u;
    if (!validDerivationPath.test(path)) {
        return HdNodeDerivationError.invalidDerivationPath;
    }
    const parsed = path.split('/');
    const isPrivateDerivation = 'privateKey' in node;
    if (isPrivateDerivation && parsed[0] !== 'm') {
        return HdNodeDerivationError.invalidPrivateDerivationPrefix;
    }
    if (!isPrivateDerivation && parsed[0] !== 'M') {
        return HdNodeDerivationError.invalidPublicDerivationPrefix;
    }
    const base = 10;
    const hardenedIndexOffset = 0x80000000;
    const indexes = parsed
        .slice(1)
        .map((index) => index.endsWith("'")
        ? parseInt(index.slice(0, -1), base) + hardenedIndexOffset
        : parseInt(index, base));
    return (isPrivateDerivation
        ? indexes.reduce((result, nextIndex) => typeof result === 'string'
            ? result
            : exports.deriveHdPrivateNodeChild(crypto, result, nextIndex), node)
        : indexes.reduce((result, nextIndex) => typeof result === 'string'
            ? result
            : exports.deriveHdPublicNodeChild(crypto, result, nextIndex), node));
};
var HdNodeCrackingError;
(function (HdNodeCrackingError) {
    HdNodeCrackingError["cannotCrackHardenedDerivation"] = "HD node cracking error: cannot crack an HD parent node using hardened child node.";
})(HdNodeCrackingError = exports.HdNodeCrackingError || (exports.HdNodeCrackingError = {}));
/**
 * Derive the HD private node from a HD public node, given any non-hardened
 * child private node.
 *
 * @remarks
 * This exploits the "non-hardened" BIP32 derivation algorithm. Because
 * non-hardened derivation only requires knowledge of the "chain code" (rather
 * than requiring knowledge of the parent private key) it's possible to
 * calculate the value by which the parent private key is "tweaked" to arrive at
 * the child private key. Since we have the child private key, we simply
 * subtract this "tweaked" amount to get back to the parent private key.
 *
 * The BIP32 "hardened" derivation algorithm is designed to address this
 * weakness. Using hardened derivation, child private nodes can be shared
 * without risk of leaking the parent private node, but this comes at the cost
 * of public node derivation. Given only a parent public node, it is not
 * possible to derive hardened child public keys, so applications must choose
 * between support for HD public node derivation or support for sharing child
 * private nodes.
 *
 * @param crypto - an implementation of sha512
 * @param parentPublicNode - the parent HD public node for which to derive a
 * private node
 * @param childPrivateNode - any non-hardened child private node of the parent
 * node
 */
exports.crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode = (crypto, parentPublicNode, childPrivateNode) => {
    const hardenedIndexOffset = 0x80000000;
    if (childPrivateNode.childIndex >= hardenedIndexOffset) {
        return HdNodeCrackingError.cannotCrackHardenedDerivation;
    }
    const serialization = Uint8Array.from([
        ...parentPublicNode.publicKey,
        ...format_1.numberToBinUint32BE(childPrivateNode.childIndex),
    ]);
    const derivation = hmac_1.hmacSha512(crypto.sha512, parentPublicNode.chainCode, serialization);
    const tweakValueLength = 32;
    const tweakValue = format_1.binToBigIntUint256BE(derivation.slice(0, tweakValueLength));
    const childPrivateValue = format_1.binToBigIntUint256BE(childPrivateNode.privateKey);
    const secp256k1OrderN = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    const trueMod = (n, m) => ((n % m) + m) % m;
    const parentPrivateValue = trueMod(childPrivateValue - tweakValue, secp256k1OrderN);
    const privateKey = format_1.bigIntToBinUint256BEClamped(parentPrivateValue);
    return Object.assign(Object.assign({ chainCode: parentPublicNode.chainCode, childIndex: parentPublicNode.childIndex, depth: parentPublicNode.depth, parentFingerprint: parentPublicNode.parentFingerprint }, (parentPublicNode.parentIdentifier === undefined
        ? {}
        : { parentIdentifier: parentPublicNode.parentIdentifier })), { privateKey, valid: true });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGQta2V5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9rZXkvaGQta2V5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsNkNBUzBCO0FBQzFCLHlDQUE0QztBQUM1Qyw2Q0FRMEI7QUFDMUIseUNBQTJDO0FBRTNDLDJDQUEwRDtBQWtJMUQ7Ozs7Ozs7OztHQVNHO0FBQ1UsUUFBQSxzQkFBc0IsR0FBRyxLQUFLLElBQUksRUFBRTtJQUMvQyxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQy9ELDZCQUFvQixFQUFFO1FBQ3RCLDZCQUFvQixFQUFFO1FBQ3RCLDBCQUFpQixFQUFFO1FBQ25CLDBCQUFpQixFQUFFO0tBQ3BCLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQztBQUNsRCxDQUFDLENBQUM7QUFFRixNQUFNLGtCQUFrQixHQUFHLGdCQUFTLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDckQsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUM7QUFDaEM7Ozs7Ozs7Ozs7R0FVRztBQUNVLFFBQUEsMkJBQTJCLEdBQUcsQ0FHekMsTUFBNEMsRUFDNUMsSUFBZ0IsRUFDaEIsY0FBZ0MsRUFDaEMsRUFBRTtJQUNGLE1BQU0sR0FBRyxHQUFHLGlCQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNoRSxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3RELE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUNsRCxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUM7SUFD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
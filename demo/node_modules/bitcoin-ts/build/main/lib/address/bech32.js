"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The list of 32 symbols used in Bech32 encoding.
 */
// cspell: disable-next-line
exports.bech32CharacterSet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
// prettier-ignore
exports.bech32CharacterSetIndex = { q: 0, p: 1, z: 2, r: 3, y: 4, '9': 5, x: 6, '8': 7, g: 8, f: 9, '2': 10, t: 11, v: 12, d: 13, w: 14, '0': 15, s: 16, '3': 17, j: 18, n: 19, '5': 20, '4': 21, k: 22, h: 23, c: 24, e: 25, '6': 26, m: 27, u: 28, a: 29, '7': 30, l: 31 }; // eslint-disable-line sort-keys
var BitRegroupingError;
(function (BitRegroupingError) {
    BitRegroupingError["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
    BitRegroupingError["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
    BitRegroupingError["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError = exports.BitRegroupingError || (exports.BitRegroupingError = {}));
/* eslint-disable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
// cSpell:ignore Pieter, Wuille
/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 *
 * @privateRemarks
 * Derived from: https://github.com/sipa/bech32
 * Copyright (c) 2017 Pieter Wuille, MIT License
 */
exports.regroupBits = ({ bin, sourceWordLength, resultWordLength, padding = true, }) => {
    let accumulator = 0;
    let bits = 0;
    const result = [];
    const maxResultInt = (1 << resultWordLength) - 1;
    // eslint-disable-next-line functional/no-loop-statement, @typescript-eslint/prefer-for-of, no-plusplus
    for (let p = 0; p < bin.length; ++p) {
        const value = bin[p];
        if (value < 0 || value >> sourceWordLength !== 0) {
            return BitRegroupingError.integerOutOfRange;
        }
        accumulator = (accumulator << sourceWordLength) | value;
        bits += sourceWordLength;
        // eslint-disable-next-line functional/no-loop-statement
        while (bits >= resultWordLength) {
            bits -= resultWordLength;
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator >> bits) & maxResultInt);
        }
    }
    if (padding) {
        if (bits > 0) {
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator << (resultWordLength - bits)) & maxResultInt);
        }
    }
    else if (bits >= sourceWordLength) {
        return BitRegroupingError.hasDisallowedPadding;
    }
    else if (((accumulator << (resultWordLength - bits)) & maxResultInt) >
        0) {
        return BitRegroupingError.requiresDisallowedPadding;
    }
    return result;
};
/* eslint-enable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`.
 *
 * @param base32IntegerArray - the array of 5-bit integers to encode
 */
exports.encodeBech32 = (base32IntegerArray) => {
    // eslint-disable-next-line functional/no-let
    let result = '';
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < base32IntegerArray.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement
        result += exports.bech32CharacterSet[base32IntegerArray[i]];
    }
    return result;
};
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with `isBech32` before calling this method.
 *
 * @param validBech32 - the bech32-encoded string to decode
 */
exports.decodeBech32 = (validBech32) => {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < validBech32.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        result.push(exports.bech32CharacterSetIndex[validBech32[i]]);
    }
    return result;
};
const nonBech32Characters = new RegExp(`[^${exports.bech32CharacterSet}]`, 'u');
const base32WordLength = 5;
const base256WordLength = 8;
const zero = 0;
/**
 * Validate that a string is bech32 encoded (without a checksum). The string
 * must use only the bech32 character set, and it must be padded correctly, i.e.
 * it must encode a multiple of 8 bits.
 *
 * @param maybeBech32 - a string to test for valid Bech32 encoding
 */
exports.isBech32 = (maybeBech32) => {
    const expectedPadding = (maybeBech32.length * base32WordLength) % base256WordLength;
    const last5Bits = exports.bech32CharacterSetIndex[maybeBech32[maybeBech32.length]];
    const onlyBech32Characters = !nonBech32Characters.test(maybeBech32);
    const noExcessivePadding = expectedPadding < base32WordLength;
    // eslint-disable-next-line no-bitwise
    const mask = (1 << expectedPadding) - 1;
    // eslint-disable-next-line no-bitwise
    const expectedPaddingIsZeroFilled = (Number(last5Bits) & mask) === zero;
    return (onlyBech32Characters && noExcessivePadding && expectedPaddingIsZeroFilled);
};
var Bech32DecodingError;
(function (Bech32DecodingError) {
    Bech32DecodingError["notBech32Padded"] = "Bech32 decoding error: input is not in Bech32 padded format.";
})(Bech32DecodingError = exports.Bech32DecodingError || (exports.Bech32DecodingError = {}));
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * This method is the reverse of `binToBech32Padded`.
 *
 * @param bech32Padded - the padded bech32-encoded string to decode
 */
exports.bech32PaddedToBin = (bech32Padded) => {
    const result = exports.isBech32(bech32Padded)
        ? exports.regroupBits({
            bin: exports.decodeBech32(bech32Padded),
            padding: false,
            resultWordLength: base256WordLength,
            sourceWordLength: base32WordLength,
        })
        : Bech32DecodingError.notBech32Padded;
    return typeof result === 'string' ? result : Uint8Array.from(result);
};
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * This method is the reverse of `bech32PaddedToBin`.
 *
 * @param bytes - the Uint8Array to bech32 encode
 */
exports.binToBech32Padded = (bytes) => exports.encodeBech32(exports.regroupBits({
    bin: bytes,
    resultWordLength: base32WordLength,
    sourceWordLength: base256WordLength,
}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVjaDMyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9hZGRyZXNzL2JlY2gzMi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBOztHQUVHO0FBQ0gsNEJBQTRCO0FBQ2YsUUFBQSxrQkFBa0IsR0FBRyxrQ0FBa0MsQ0FBQztBQUVyRTs7R0FFRztBQUNILGtCQUFrQjtBQUNMLFFBQUEsdUJBQXVCLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQVcsQ0FBQyxDQUFDLGdDQUFnQztBQUU1VCxJQUFZ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
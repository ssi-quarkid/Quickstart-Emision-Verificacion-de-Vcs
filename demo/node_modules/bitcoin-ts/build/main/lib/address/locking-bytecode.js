"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const opcodes_1 = require("../auth/instruction-sets/common/opcodes");
const base58_address_1 = require("./base58-address");
const cash_address_1 = require("./cash-address");
/**
 * The most common address types used on bitcoin and bitcoin-like networks. Each
 * address type represents a commonly used locking bytecode pattern.
 *
 * @remarks
 * Addresses are strings which encode information about the network and
 * `lockingBytecode` to which a transaction output can pay.
 *
 * Several address formats exist â€“ `Base58Address` was the format used by the
 * original satoshi client, and is still in use on several active chains (see
 * `encodeBase58Address`). On Bitcoin Cash, the `CashAddress` standard is most
 * common (See `encodeCashAddress`).
 */
var AddressType;
(function (AddressType) {
    /**
     * Pay to Public Key (P2PK). This address type is uncommon, and primarily
     * occurs in early blocks because the original satoshi implementation mined
     * rewards to P2PK addresses.
     *
     * There are no standardized address formats for representing a P2PK address.
     * Instead, most applications use the `AddressType.p2pkh` format.
     */
    AddressType["p2pk"] = "P2PK";
    /**
     * Pay to Public Key Hash (P2PKH). The most common address type. P2PKH
     * addresses lock funds using a single private key.
     */
    AddressType["p2pkh"] = "P2PKH";
    /**
     * Pay to Script Hash (P2SH). An address type which locks funds to the hash of
     * a script provided in the spending transaction. See BIP13 for details.
     */
    AddressType["p2sh"] = "P2SH";
    /**
     * This `AddressType` represents an address using an unknown or uncommon
     * locking bytecode pattern for which no standardized address formats exist.
     */
    AddressType["unknown"] = "unknown";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Attempt to match a lockingBytecode to a standard address type for use in
 * address encoding. (See `AddressType` for details.)
 *
 * For a locking bytecode matching the Pay to Public Key Hash (P2PKH) pattern,
 * the returned `type` is `AddressType.p2pkh` and `payload` is the `HASH160` of
 * the public key.
 *
 * For a locking bytecode matching the Pay to Script Hash (P2SH) pattern, the
 * returned `type` is `AddressType.p2sh` and `payload` is the `HASH160` of the
 * redeeming bytecode, A.K.A. "redeem script hash".
 *
 * For a locking bytecode matching the Pay to Public Key (P2PK) pattern, the
 * returned `type` is `AddressType.p2pk` and `payload` is the full public key.
 *
 * Any other locking bytecode will return a `type` of `AddressType.unknown` and
 * a payload of the unmodified `bytecode`.
 *
 * @param bytecode - the locking bytecode to match
 */
// eslint-disable-next-line complexity
exports.lockingBytecodeToAddressContents = (bytecode) => {
    const p2pkhLength = 25;
    if (bytecode.length === p2pkhLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_DUP &&
        bytecode[1] === opcodes_1.OpcodesCommon.OP_HASH160 &&
        bytecode[2] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_20 &&
        bytecode[23] === opcodes_1.OpcodesCommon.OP_EQUALVERIFY &&
        bytecode[24] === opcodes_1.OpcodesCommon.OP_CHECKSIG) {
        const start = 3;
        const end = 23;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pkh };
    }
    const p2shLength = 23;
    if (bytecode.length === p2shLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_HASH160 &&
        bytecode[1] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_20 &&
        bytecode[22] === opcodes_1.OpcodesCommon.OP_EQUAL) {
        const start = 2;
        const end = 22;
        return { payload: bytecode.slice(start, end), type: AddressType.p2sh };
    }
    const p2pkUncompressedLength = 67;
    if (bytecode.length === p2pkUncompressedLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_65 &&
        bytecode[66] === opcodes_1.OpcodesCommon.OP_CHECKSIG) {
        const start = 1;
        const end = 66;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pk };
    }
    const p2pkCompressedLength = 35;
    if (bytecode.length === p2pkCompressedLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_33 &&
        bytecode[34] === opcodes_1.OpcodesCommon.OP_CHECKSIG) {
        const start = 1;
        const end = 34;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pk };
    }
    return {
        payload: bytecode.slice(),
        type: AddressType.unknown,
    };
};
/**
 * Get the locking bytecode for a valid `AddressContents` object. See
 * `lockingBytecodeToAddressContents` for details.
 *
 * For `AddressContents` of `type` `AddressType.unknown`, this method returns
 * the `payload` without modification.
 *
 * @param addressContents - the `AddressContents` to encode
 */
exports.addressContentsToLockingBytecode = (addressContents) => {
    if (addressContents.type === AddressType.p2pkh) {
        return Uint8Array.from([
            opcodes_1.OpcodesCommon.OP_DUP,
            opcodes_1.OpcodesCommon.OP_HASH160,
            opcodes_1.OpcodesCommon.OP_PUSHBYTES_20,
            ...addressContents.payload,
            opcodes_1.OpcodesCommon.OP_EQUALVERIFY,
            opcodes_1.OpcodesCommon.OP_CHECKSIG,
        ]);
    }
    if (addressContents.type === AddressType.p2sh) {
        return Uint8Array.from([
            opcodes_1.OpcodesCommon.OP_HASH160,
            opcodes_1.OpcodesCommon.OP_PUSHBYTES_20,
            ...addressContents.payload,
            opcodes_1.OpcodesCommon.OP_EQUAL,
        ]);
    }
    if (addressContents.type === AddressType.p2pk) {
        const compressedPublicKeyLength = 33;
        return addressContents.payload.length === compressedPublicKeyLength
            ? Uint8Array.from([
                opcodes_1.OpcodesCommon.OP_PUSHBYTES_33,
                ...addressContents.payload,
                opcodes_1.OpcodesCommon.OP_CHECKSIG,
            ])
            : Uint8Array.from([
                opcodes_1.OpcodesCommon.OP_PUSHBYTES_65,
                ...addressContents.payload,
                opcodes_1.OpcodesCommon.OP_CHECKSIG,
            ]);
    }
    return addressContents.payload;
};
/**
 * Encode a locking bytecode as a CashAddress given a network prefix.
 *
 * If `bytecode` matches either the P2PKH or P2SH pattern, it is encoded using
 * the proper address type and returned as a valid CashAddress (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting `AddressContents` is returned.
 *
 * @param bytecode - the locking bytecode to encode
 * @param prefix - the network prefix to use, e.g. `bitcoincash`, `bchtest`, or
 * `bchreg`
 */
exports.lockingBytecodeToCashAddress = (bytecode, prefix) => {
    const contents = exports.lockingBytecodeToAddressContents(bytecode);
    if (contents.type === AddressType.p2pkh) {
        return cash_address_1.encodeCashAddress(prefix, cash_address_1.CashAddressType.P2PKH, contents.payload);
    }
    if (contents.type === AddressType.p2sh) {
        return cash_address_1.encodeCashAddress(prefix, cash_address_1.CashAddressType.P2SH, contents.payload);
    }
    return contents;
};
var LockingBytecodeEncodingError;
(function (LockingBytecodeEncodingError) {
    LockingBytecodeEncodingError["unknownCashAddressType"] = "This CashAddress uses an unknown address type.";
})(LockingBytecodeEncodingError = exports.LockingBytecodeEncodingError || (exports.LockingBytecodeEncodingError = {}));
/**
 * Convert a CashAddress to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network prefix. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
exports.cashAddressToLockingBytecode = (address) => {
    const decoded = cash_address_1.decodeCashAddress(address);
    if (typeof decoded === 'string')
        return decoded;
    if (decoded.type === cash_address_1.CashAddressType.P2PKH) {
        return {
            bytecode: exports.addressContentsToLockingBytecode({
                payload: decoded.hash,
                type: AddressType.p2pkh,
            }),
            prefix: decoded.prefix,
        };
    }
    if (decoded.type === cash_address_1.CashAddressType.P2SH) {
        return {
            bytecode: exports.addressContentsToLockingBytecode({
                payload: decoded.hash,
                type: AddressType.p2sh,
            }),
            prefix: decoded.prefix,
        };
    }
    return LockingBytecodeEncodingError.unknownCashAddressType;
};
/**
 * Encode a locking bytecode as a Base58Address for a given network.
 *
 * If `bytecode` matches either the P2PKH or P2SH pattern, it is encoded using
 * the proper address type and returned as a valid Base58Address (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting `AddressContents` is returned.
 *
 * @param sha256 - an implementation of sha256 (a universal implementation is
 * available via `instantiateSha256`)
 * @param bytecode - the locking bytecode to encode
 * @param network - the network for which to encode the address (`mainnet` or
 * `testnet`)
 */
exports.lockingBytecodeToBase58Address = (sha256, bytecode, network) => {
    const contents = exports.lockingBytecodeToAddressContents(bytecode);
    if (contents.type === AddressType.p2pkh) {
        return base58_address_1.encodeBase58AddressFormat(sha256, {
            'copay-bch': base58_address_1.Base58AddressFormatVersion.p2pkhCopayBCH,
            mainnet: base58_address_1.Base58AddressFormatVersion.p2pkh,
            testnet: base58_address_1.Base58AddressFormatVersion.p2pkhTestnet,
        }[network], contents.payload);
    }
    if (contents.type === AddressType.p2sh) {
        return base58_address_1.encodeBase58AddressFormat(sha256, {
            'copay-bch': base58_address_1.Base58AddressFormatVersion.p2shCopayBCH,
            mainnet: base58_address_1.Base58AddressFormatVersion.p2sh,
            testnet: base58_address_1.Base58AddressFormatVersion.p2shTestnet,
        }[network], contents.payload);
    }
    return contents;
};
/**
 * Convert a Base58Address to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network version. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
exports.base58AddressToLockingBytecode = (sha256, address) => {
    const decoded = base58_address_1.decodeBase58Address(sha256, address);
    if (typeof decoded === 'string')
        return decoded;
    return {
        bytecode: exports.addressContentsToLockingBytecode({
            payload: decoded.payload,
            type: [
                base58_address_1.Base58AddressFormatVersion.p2pkh,
                base58_address_1.Base58AddressFormatVersion.p2pkhCopayBCH,
                base58_address_1.Base58AddressFormatVersion.p2pkhTestnet,
            ].includes(decoded.version)
                ? AddressType.p2pkh
                : AddressType.p2sh,
        }),
        version: decoded.version,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ja2luZy1ieXRlY29kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvYWRkcmVzcy9sb2NraW5nLWJ5dGVjb2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEscUVBQXdFO0FBR3hFLHFEQUswQjtBQUMxQixpREFLd0I7QUFFeEI7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsSUFBWSxXQXlCWDtBQXpCRCxXQUFZLFdBQVc7SUFDckI7Ozs7Ozs7T0FPRztJQUNILDRCQUFhLENBQUE7SUFDYjs7O09BR0c7SUFDSCw4QkFBZSxDQUFBO0lBQ2Y7OztPQUdHO0lBQ0gsNEJBQWEsQ0FBQTtJQUNiOzs7T0FHRztJQUNILGtDQUFtQixDQUFBO0FBQ3JCLENBQUMsRUF6QlcsV0FBVyxHQUFYLG1CQUFXLEtBQVgsbUJBQVcsUUF5QnRCO0FBYUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxzQ0FBc0M7QUFDekIsUUFBQSxnQ0FBZ0MsR0FBRyxDQUM5QyxRQUFvQixFQUNILEVBQUU7SUFDbkIsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQ3ZCLElBQ0UsUUFBUSxDQUFDLE1BQU0sS0FBSyxXQUFXO1FBQy9CLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyx1QkFBYSxDQUFDLE1BQU07UUFDcEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLHVCQUFhLENBQUMsVUFBVTtRQUN4QyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssdUJBQWEsQ0FBQyxlQUFlO1FBQzdDLFFBQVEsQ0FBQyxFQUFFLENBQUMsS0FBSyx1QkFBYSxDQUFDLGNBQWM7UUFDN0MsUUFBUSxDQUFDLEVBQUUsQ0FBQyxLQUFLLHVCQUFhLENBQUMsV0FBVyxFQUMxQztRQUNBLE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNoQixNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDZixPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxLQUFL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
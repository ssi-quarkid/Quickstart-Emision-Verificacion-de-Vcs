import { Secp256k1, Sha256 } from '../../../crypto/crypto';
import { AuthenticationInstruction } from '../../instruction-sets/instruction-sets-types';
import { AuthenticationVirtualMachine } from '../../virtual-machine';
import { AuthenticationTemplateVariable } from '../types';
import { CompilationResultSuccess } from './compile';
import { BtlScriptSegment } from './parse';
export interface Range {
    endColumn: number;
    endLineNumber: number;
    startColumn: number;
    startLineNumber: number;
}
interface ResolvedSegmentBase {
    range: Range;
    type: string;
}
export interface ResolvedSegmentPush<T> extends ResolvedSegmentBase {
    type: 'push';
    value: T;
}
export interface ResolvedSegmentEvaluation<T> extends ResolvedSegmentBase {
    type: 'evaluation';
    value: T;
}
export interface ResolvedSegmentVariableBytecode extends ResolvedSegmentBase {
    type: 'bytecode';
    value: Uint8Array;
    variable: string;
}
export interface ResolvedSegmentScriptBytecode extends ResolvedSegmentBase {
    script: string;
    source: ResolvedScript;
    type: 'bytecode';
    value: Uint8Array;
}
export interface ResolvedSegmentOpcodeBytecode extends ResolvedSegmentBase {
    opcode: string;
    type: 'bytecode';
    value: Uint8Array;
}
export interface ResolvedSegmentLiteralBytecode extends ResolvedSegmentBase {
    literalType: 'BigIntLiteral' | 'HexLiteral' | 'UTF8Literal';
    type: 'bytecode';
    value: Uint8Array;
}
export declare type ResolvedSegmentBytecode = ResolvedSegmentLiteralBytecode | ResolvedSegmentOpcodeBytecode | ResolvedSegmentScriptBytecode | ResolvedSegmentVariableBytecode;
export interface ResolvedSegmentComment extends ResolvedSegmentBase {
    type: 'comment';
    value: string;
}
export interface ResolvedSegmentError extends ResolvedSegmentBase {
    type: 'error';
    value: string;
}
export declare type ResolvedSegment = ResolvedSegmentPush<ResolvedScript> | ResolvedSegmentEvaluation<ResolvedScript> | ResolvedSegmentBytecode | ResolvedSegmentComment | ResolvedSegmentError;
export interface ResolvedScript extends Array<ResolvedSegment> {
}
export declare enum IdentifierResolutionType {
    opcode = "opcode",
    variable = "variable",
    script = "script"
}
export declare type IdentifierResolutionFunction = (identifier: string) => {
    bytecode: Uint8Array;
    status: true;
    type: IdentifierResolutionType.opcode | IdentifierResolutionType.variable;
} | {
    bytecode: Uint8Array;
    source: ResolvedScript;
    status: true;
    type: IdentifierResolutionType.script;
} | {
    error: string;
    status: false;
};
export declare const resolveScriptSegment: (segment: BtlScriptSegment, resolveIdentifiers: IdentifierResolutionFunction) => ResolvedScript;
export declare type CompilerOperationTypes = AuthenticationTemplateVariable['type'] | 'SigningSerialization';
/**
 * Returns the bytecode result on success or an error message on failure.
 */
export declare type CompilerOperation<CompilerOperationData = {}, Checked extends CompilerOperationTypes | undefined = undefined> = (identifier: string, compilationData: Checked extends 'Key' ? Required<Pick<CompilationData<CompilerOperationData>, 'keys'>> & CompilationData<CompilerOperationData> : Checked extends 'HDKey' ? Required<Pick<CompilationData<CompilerOperationData>, 'hdKeys'>> & CompilationData<CompilerOperationData> : Checked extends 'WalletData' ? Required<Pick<CompilationData<CompilerOperationData>, 'walletData'>> & CompilationData<CompilerOperationData> : Checked extends 'AddressData' ? Required<Pick<CompilationData<CompilerOperationData>, 'addressData'>> & CompilationData<CompilerOperationData> : CompilationData<CompilerOperationData>, compilationEnvironment: CompilationEnvironment<CompilerOperationData>) => Uint8Array | string;
export declare type CompilerOperationsMinimal = 'public_key' | 'signature';
/**
 * The full context required to compile a given Bitauth Template script –
 * everything required for the compiler to understand the CompilationData and
 * generate the compiled bytecode (targeting a specific
 * `AuthenticationVirtualMachine`).
 *
 * A `CompilationEnvironment` must include a subset of the script's
 * `AuthenticationTemplate` – all the variables and scripts referenced
 * (including children of children) by the script in question.
 *
 * The context must also include an object mapping of opcode identifiers to the
 * bytecode they generate.
 *
 * If keys are used, an implementation of `sha256` and `secp256k1` is
 * required. If the script requires evaluations during compilation, the
 * evaluating `AuthenticationVirtualMachine` must also be included.
 */
export interface CompilationEnvironment<CompilerOperationData = {}, CompilerOperations extends string = CompilerOperationsMinimal> {
    /**
     * A method which accepts an array of `AuthenticationInstruction`s, and
     * returns a ProgramState. This method will be used to generate the initial
     * ProgramState for `evaluation`s.
     */
    createState?: (instructions: AuthenticationInstruction<any>[]) => any;
    /**
     * An object mapping opcode identifiers to the bytecode they generate.
     */
    opcodes?: {
        [opcodeIdentifier: string]: Uint8Array;
    };
    /**
     * An object specifying the operations made available by this
     * CompilationEnvironment for each variable type, e.g. keys may support public
     * key derivation and multiple signature types.
     */
    operations?: {
        [key in CompilerOperationTypes]?: {
            [operationId in CompilerOperations]?: CompilerOperation<CompilerOperationData, key>;
        };
    };
    /**
     * An object mapping script identifiers to the text of script in Bitauth
     * Templating Language.
     *
     * To avoid compilation errors, this object must contain all scripts
     * referenced by the script being compiled (including children of children).
     */
    scripts: {
        [scriptId: string]: string;
    };
    /**
     * An implementation of secp256k1 is required for any scripts which include
     * signatures. This can be instantiated with `instantiateSecp256k1`.
     */
    secp256k1?: {
        derivePublicKeyCompressed: Secp256k1['derivePublicKeyCompressed'];
        signMessageHashSchnorr: Secp256k1['signMessageHashSchnorr'];
        signMessageHashDER: Secp256k1['signMessageHashDER'];
    };
    /**
     * An implementation of sha256 is required for any scripts which include
     * signatures. This can be instantiated with `instantiateSha256`.
     */
    sha256?: {
        hash: Sha256['hash'];
    };
    /**
     * The "breadcrumb" path of script IDs currently being resolved. (E.g.
     * `["grandparentId", "parentId"]`) BTL identifier resolution must be acyclic.
     *
     * To prevent an infinite loop, `IdentifierResolutionFunction`s must abort
     * resolution if they encounter their own `id` while resolving another
     * identifier. Likewise, child scripts being resolved by a parent script
     * may not reference any script which is already in the process of being
     * resolved.
     */
    sourceScriptIds?: string[];
    /**
     * An object mapping Bitauth variable identifiers to the
     * `AuthenticationTemplateVariable` describing them.
     *
     * To avoid compilation errors, this object must contain all variables
     * referenced by the script being compiled (including in child scripts).
     */
    variables?: {
        [variableId: string]: AuthenticationTemplateVariable;
    };
    /**
     * The AuthenticationVirtualMachine on which BTL `evaluation` results will be
     * computed.
     */
    vm?: AuthenticationVirtualMachine<any, any>;
}
/**
 * Data required at compilation time to generate the bytecode for a particular
 * Bitauth Template script.
 */
export interface CompilationData<CompilerOperationData> {
    /**
     * A map of `AddressData` variable IDs and their values for this compilation.
     */
    addressData?: {
        [id: string]: Uint8Array;
    };
    /**
     * The current block height at compile time.
     */
    currentBlockHeight?: number;
    /**
     * The current block time at compile time. Note: this is not a current
     * timestamp, but the median timestamp of the last 11 blocks.
     *
     * This value only changes when a new block is found. See BIP113 for details.
     */
    currentBlockTime?: Date;
    /**
     * TODO: implement `HDKey` support
     *
     * An object describing the settings used for `HDKey` variables in this
     * compilation.
     */
    hdKeys?: {
        /**
         * A map of `HDKey` variable IDs to the extended public keys provided to us
         * by other entities for this compilation.
         *
         * Specifically, these keys use the derivation path:
         * `m/templateDerivationIndex`, where `templateDerivationHardened` is
         * `true`.
         *
         * With the `scriptDerivationIndex`, these extended public keys are used to
         * derive the precise public key used for the variable in this compilation.
         */
        extendedPublicKeys?: {
            [id: string]: Uint8Array;
        };
        /**
         * A map of `HDKey` variable IDs to the public keys provided to us by other
         * entities for this compilation.
         *
         * Specifically, these keys use the derivation path:
         * `m / templateDerivationIndex`, where `templateDerivationHardened` is
         * `false`.
         *
         * Since we're not able to derive these public keys ourselves, they must
         * send us the derived public keys to include in the proper places.
         */
        publicKeys?: {
            [id: string]: Uint8Array;
        };
        /**
         * A map of entity IDs to their root private keys for this compilation.
         */
        rootPrivateKeys: {
            [entityId: string]: Uint8Array;
        };
        /**
         * The current index to use in this `HDKey`s script-level derivation.
         * Typically, this value is incremented for each address generated.
         */
        scriptDerivationIndex: number;
        /**
         * Signatures provided to us by other entities. Since we can't have their
         * private key, they must send us valid signatures to include in the proper
         * places. The provided `fullIdentifier` should match the complete
         * identifier for the signature, e.g. `variable.signature.all_outputs`.
         */
        signatures?: {
            [fullIdentifier: string]: Uint8Array;
        };
    };
    /**
     * An object describing the settings used for `Key` variables in this
     * compilation.
     */
    keys?: {
        /**
         * A map of entity IDs to their private keys for this compilation.
         */
        privateKeys?: {
            [id: string]: Uint8Array;
        };
        /**
         * A map of entity IDs to their public keys for this compilation.
         */
        publicKeys?: {
            [id: string]: Uint8Array;
        };
        /**
         * Signatures provided to us by other entities. Since we can't have their
         * private key, they must send us valid signatures to include in the proper
         * places. The provided `fullIdentifier` should match the complete
         * identifier for the signature, e.g. `variable.signature.all_outputs`.
         */
        signatures?: {
            [fullIdentifier: string]: Uint8Array;
        };
    };
    /**
     * The `CompilerOperationData` expected by this particular compiler for any
     * operations used in the compilation.
     */
    operationData?: CompilerOperationData;
    /**
     * A map of `WalletData` variable IDs and their values for this compilation.
     */
    walletData?: {
        [id: string]: Uint8Array;
    };
}
export declare enum BuiltInVariables {
    currentBlockTime = "current_block_time",
    currentBlockHeight = "current_block_height",
    signingSerialization = "signing_serialization"
}
/**
 * If the identifer can be successfully resolved as a variable, the result is
 * returned as a Uint8Array. If the identifier references a known variable, but
 * an error occurs in resolving it, the error is returned as a string.
 * Otherwise, the identifier is not recognized as a variable, and this method
 * simply returns `false`.
 */
export declare const resolveAuthenticationTemplateVariable: <CompilerOperationData>(identifier: string, environment: CompilationEnvironment<CompilerOperationData, CompilerOperationsMinimal>, data: CompilationData<CompilerOperationData>) => string | false | Uint8Array;
/**
 * Compile an internal script identifier.
 *
 * @remarks
 * If the identifer can be successfully resolved as a script, the script is
 * compiled and returned as a CompilationResultSuccess. If an error occurs in
 * compiling it, the error is returned as a string.
 *
 * Otherwise, the identifier is not recognized as a script, and this method
 * simply returns `false`.
 *
 * @param identifier - the identifier of the script to be resolved
 * @param data - the provided CompilationData
 * @param environment - the provided CompilationEnvironment
 * @param parentIdentifier - the identifier of the script which references the
 * script being resolved (for detecting circular dependencies)
 */
export declare const resolveScriptIdentifier: <CompilerOperationData, ProgramState>({ data, environment, identifier, parentIdentifier, }: {
    identifier: string;
    data: CompilationData<CompilerOperationData>;
    environment: CompilationEnvironment<CompilerOperationData, CompilerOperationsMinimal>;
    parentIdentifier?: string | undefined;
}) => string | false | CompilationResultSuccess<ProgramState>;
/**
 * Return an `IdentifierResolutionFunction` for use in `resolveScriptSegment`.
 *
 * @param scriptId - the `id` of the script for which the resulting
 * `IdentifierResolutionFunction` will be used.
 * @param environment - a snapshot of the context around `scriptId`. See
 * `CompilationEnvironment` for details.
 * @param data - the actual variable values (private keys, shared wallet data,
 * shared address data, etc.) to use in resolving variables.
 */
export declare const createIdentifierResolver: <CompilerOperationData>(scriptId: string | undefined, data: CompilationData<CompilerOperationData>, environment: CompilationEnvironment<CompilerOperationData, CompilerOperationsMinimal>) => IdentifierResolutionFunction;
export {};
//# sourceMappingURL=resolve.d.ts.map
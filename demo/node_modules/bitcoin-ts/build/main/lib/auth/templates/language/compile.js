"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const parse_1 = require("./parse");
const reduce_1 = require("./reduce");
const resolve_1 = require("./resolve");
var Formatting;
(function (Formatting) {
    Formatting[Formatting["requiresCommas"] = 3] = "requiresCommas";
    Formatting[Formatting["requiresOr"] = 2] = "requiresOr";
})(Formatting || (Formatting = {}));
/**
 * The constant used by the parser to denote the end of the input
 */
const EOF = 'EOF';
/**
 * A text-formatting method to pretty-print the list of expected inputs
 * (`Encountered unexpected input while parsing script. Expected ...`). If
 * present, the `EOF` expectation is always moved to the end of the list.
 * @param expectedArray - the alphabetized list of expected inputs produced by
 * `parseScript`
 */
const describeExpectedInput = (expectedArray) => {
    const newArray = expectedArray.filter((value) => value !== EOF);
    // eslint-disable-next-line functional/no-conditional-statement
    if (newArray.length !== expectedArray.length) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        newArray.push('the end of the script');
    }
    const withoutLastElement = newArray.slice(0, newArray.length - 1);
    const lastElement = newArray[newArray.length - 1];
    return `Encountered unexpected input while parsing script. Expected ${newArray.length >= Formatting.requiresCommas
        ? withoutLastElement.join(', ').concat(`, or ${lastElement}`)
        : newArray.length === Formatting.requiresOr
            ? newArray.join(' or ')
            : lastElement}.`;
};
/**
 * Note, `compileScript` is the recommended API for using this method.
 */
exports.compileScriptText = ({ data, environment, script, scriptId, }) => {
    const parseResult = parse_1.parseScript(script);
    if (!parseResult.status) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: describeExpectedInput(parseResult.expected),
                    range: {
                        endColumn: parseResult.index.column,
                        endLineNumber: parseResult.index.line,
                        startColumn: parseResult.index.column,
                        startLineNumber: parseResult.index.line,
                    },
                },
            ],
            success: false,
        };
    }
    const resolver = resolve_1.createIdentifierResolver(scriptId, data, environment);
    const resolvedScript = resolve_1.resolveScriptSegment(parseResult.value, resolver);
    const resolutionErrors = errors_1.getResolutionErrors(resolvedScript);
    if (resolutionErrors.length !== 0) {
        return {
            errorType: 'resolve',
            errors: resolutionErrors,
            parse: parseResult.value,
            resolve: resolvedScript,
            success: false,
        };
    }
    const reduction = reduce_1.reduceScript(resolvedScript, environment.vm, environment.createState);
    return Object.assign(Object.assign({}, (reduction.errors === undefined
        ? { bytecode: reduction.bytecode, success: true }
        : { errorType: 'reduce', errors: reduction.errors, success: false })), { parse: parseResult.value, reduce: reduction, resolve: resolvedScript });
};
/**
 * Parse, resolve, and reduce the provided BTL script using the provided `data`
 * and `environment`.
 */
exports.compileScript = (scriptId, data, environment) => {
    const script = environment.scripts[scriptId];
    if (script === undefined) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `No script with an ID of '${scriptId}' was provided in the compilation environment.`,
                    range: {
                        endColumn: 0,
                        endLineNumber: 0,
                        startColumn: 0,
                        startLineNumber: 0,
                    },
                },
            ],
            success: false,
        };
    }
    return exports.compileScriptText({
        data,
        environment,
        script,
        scriptId,
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvYXV0aC90ZW1wbGF0ZXMvbGFuZ3VhZ2UvY29tcGlsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLHFDQUErQztBQUMvQyxtQ0FBd0Q7QUFDeEQscUNBQTJFO0FBQzNFLHVDQU9tQjtBQTREbkIsSUFBSyxVQUdKO0FBSEQsV0FBSyxVQUFVO0lBQ2IsK0RBQWtCLENBQUE7SUFDbEIsdURBQWMsQ0FBQTtBQUNoQixDQUFDLEVBSEksVUFBVSxLQUFWLFVBQVUsUUFHZDtBQUVEOztHQUVHO0FBQ0gsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ2xCOzs7Ozs7R0FNRztBQUNILE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxhQUF1QixFQUFFLEVBQUU7SUFDeEQsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2hFLCtEQUErRDtJQUMvRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssYUFBYSxDQUFDLE1BQU0sRUFBRTtRQUM1Qyx5RkFBeUY7UUFDekYsUUFBUSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsTUFBTSxrQkFBa0IsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELE9BQU8sK0RBQ0wsUUFBUSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsY0FBYztRQUMxQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLFdBQVcsRUFB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
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../crypto/crypto");
const format_1 = require("../../format/format");
const signing_serialization_1 = require("../instruction-sets/common/signing-serialization");
const instruction_sets_1 = require("../instruction-sets/instruction-sets");
const compile_1 = require("./language/compile");
const resolve_1 = require("./language/resolve");
/* eslint-disable camelcase */
var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs"] = "all_outputs";
    /**
     * A.K.A. `SIGHASH_ALL|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs_single_input"] = "all_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output"] = "corresponding_output";
    /**
     * A.K.A. `SIGHASH_SINGLE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output_single_input"] = "corresponding_output_single_input";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs"] = "no_outputs";
    /**
     * A.K.A `SIGHASH_NONE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs_single_input"] = "no_outputs_single_input";
})(SigningSerializationAlgorithmIdentifier = exports.SigningSerializationAlgorithmIdentifier || (exports.SigningSerializationAlgorithmIdentifier = {}));
var ScriptGenerationError;
(function (ScriptGenerationError) {
    ScriptGenerationError["missingVm"] = "An evaluation is required, but no VM was provided.";
    ScriptGenerationError["missingSha256"] = "Sha256 is required, but no implementation was provided.";
    ScriptGenerationError["missingSecp256k1"] = "Secp256k1 is required, but no implementation was provided.";
})(ScriptGenerationError || (ScriptGenerationError = {}));
// eslint-disable-next-line complexity
const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
    switch (algorithmIdentifier) {
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.all_outputs | signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.all_outputs |
                signing_serialization_1.SigningSerializationFlag.single_input |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.corresponding_output |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.corresponding_output |
                signing_serialization_1.SigningSerializationFlag.single_input |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.no_outputs | signing_serialization_1.SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.no_outputs |
                signing_serialization_1.SigningSerializationFlag.single_input |
                signing_serialization_1.SigningSerializationFlag.fork_id);
        default:
            return undefined;
    }
};
var SignatureIdentifierConstants;
(function (SignatureIdentifierConstants) {
    SignatureIdentifierConstants[SignatureIdentifierConstants["variableIdIndex"] = 0] = "variableIdIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["signingTargetIndex"] = 2] = "signingTargetIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["expectedSegments"] = 3] = "expectedSegments";
})(SignatureIdentifierConstants || (SignatureIdentifierConstants = {}));
exports.compilerOperationBCHGenerateSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid signature identifier. Signatures must be of the form: "[variable_id].${name}.[signing_serialization_type]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const algorithm = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingSerializationType = getSigningSerializationType(algorithm);
    if (signingSerializationType === undefined) {
        return `Unknown signing serialization algorithm, "${algorithm}".`;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { operationData } = data;
        if (operationData === undefined) {
            return `Could not construct the signature "${identifier}", signing serialization data was not provided in the compilation data.`;
        }
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const serialization = signing_serialization_1.generateSigningSerializationBCH({
            correspondingOutput: operationData.correspondingOutput,
            coveredBytecode: operationData.coveredBytecode,
            locktime: operationData.locktime,
            outpointIndex: operationData.outpointIndex,
            outpointTransactionHash: operationData.outpointTransactionHash,
            outputValue: operationData.outputValue,
            sequenceNumber: operationData.sequenceNumber,
            sha256,
            signingSerializationType,
            transactionOutpoints: operationData.transactionOutpoints,
            transactionOutputs: operationData.transactionOutputs,
            transactionSequenceNumbers: operationData.transactionSequenceNumbers,
            version: operationData.version,
        });
        const digest = sha256.hash(sha256.hash(serialization));
        const bitcoinEncodedSignature = Uint8Array.from([
            ...signingAlgorithm(secp256k1)(privateKey, digest),
            ...signingSerializationType,
        ]);
        return bitcoinEncodedSignature;
    }
    return `Identifier "${identifier}" refers to a signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
exports.compilerOperationBCHGenerateDataSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${name}.[target_script_id]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const scriptId = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingTarget = environment.scripts[scriptId];
    const compiledTarget = resolve_1.resolveScriptIdentifier({
        data,
        environment,
        identifier: scriptId,
    });
    if (signingTarget === undefined || compiledTarget === false) {
        return `Data signature tried to sign an unknown target script, "${scriptId}".`;
    }
    if (typeof compiledTarget === 'string') {
        return compiledTarget;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const digest = sha256.hash(compiledTarget.bytecode);
        return signingAlgorithm(secp256k1)(privateKey, digest);
    }
    return `Identifier "${identifier}" refers to a data signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
var SigningSerializationIdentifierConstants;
(function (SigningSerializationIdentifierConstants) {
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["operationIndex"] = 1] = "operationIndex";
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["expectedSegments"] = 2] = "expectedSegments";
})(SigningSerializationIdentifierConstants || (SigningSerializationIdentifierConstants = {}));
// eslint-disable-next-line complexity
exports.compilerOperationBCHGenerateSigningSerialization = (identifier, data, environment) => {
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !==
        SigningSerializationIdentifierConstants.expectedSegments) {
        return `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version" or "signing_serialization.all_outputs".`;
    }
    const algorithmOrComponent = identifierSegments[SigningSerializationIdentifierConstants.operationIndex];
    const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
    const { operationData } = data;
    if (operationData === undefined) {
        return `Could not construct the signing serialization "${identifier}", signing serialization data was not provided in the compilation data.`;
    }
    const { sha256 } = environment;
    if (sha256 === undefined) {
        return ScriptGenerationError.missingSha256;
    }
    // eslint-disable-next-line functional/no-conditional-statement
    if (signingSerializationType === undefined) {
        switch (algorithmOrComponent) {
            case 'corresponding_output':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : operationData.correspondingOutput;
            case 'corresponding_output_hash':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : sha256.hash(sha256.hash(operationData.correspondingOutput));
            case 'covered_bytecode_length':
                return format_1.bigIntToBitcoinVarInt(BigInt(operationData.coveredBytecode.length));
            case 'covered_bytecode':
                return operationData.coveredBytecode;
            case 'locktime':
                return format_1.numberToBinUint32LE(operationData.locktime);
            case 'outpoint_index':
                return format_1.numberToBinUint32LE(operationData.outpointIndex);
            case 'outpoint_transaction_hash':
                return operationData.outpointTransactionHash;
            case 'output_value':
                return format_1.bigIntToBinUint64LE(BigInt(operationData.outputValue));
            case 'sequence_number':
                return format_1.numberToBinUint32LE(operationData.sequenceNumber);
            case 'transaction_outpoints':
                return operationData.transactionOutpoints;
            case 'transaction_outpoints_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutpoints));
            case 'transaction_outputs':
                return operationData.transactionOutputs;
            case 'transaction_outputs_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutputs));
            case 'transaction_sequence_numbers':
                return operationData.transactionSequenceNumbers;
            case 'transaction_sequence_numbers_hash':
                return sha256.hash(sha256.hash(operationData.transactionSequenceNumbers));
            case 'version':
                return format_1.numberToBinUint32LE(operationData.version);
            default:
                return `Unknown signing serialization algorithm or component, "${algorithmOrComponent}".`;
        }
    }
    return signing_serialization_1.generateSigningSerializationBCH({
        correspondingOutput: operationData.correspondingOutput,
        coveredBytecode: operationData.coveredBytecode,
        locktime: operationData.locktime,
        outpointIndex: operationData.outpointIndex,
        outpointTransactionHash: operationData.outpointTransactionHash,
        outputValue: operationData.outputValue,
        sequenceNumber: operationData.sequenceNumber,
        sha256,
        signingSerializationType,
        transactionOutpoints: operationData.transactionOutpoints,
        transactionOutputs: operationData.transactionOutputs,
        transactionSequenceNumbers: operationData.transactionSequenceNumbers,
        version: operationData.version,
    });
};
/* eslint-disable camelcase */
exports.getCompilerOperationsBCH = () => ({
    Key: {
        data_signature: exports.compilerOperationBCHGenerateDataSignature('data_signature', (secp256k1) => secp256k1.signMessageHashDER),
        // eslint-disable-next-line complexity
        public_key: (identifier, data, environment) => {
            const { keys } = data;
            const { publicKeys, privateKeys } = keys;
            const [variableId] = identifier.split('.');
            if (publicKeys !== undefined &&
                publicKeys[variableId] !== undefined) {
                return publicKeys[variableId];
            }
            if (privateKeys !== undefined &&
                privateKeys[variableId] !== undefined) {
                const { secp256k1 } = environment;
                return secp256k1 === undefined
                    ? ScriptGenerationError.missingSecp256k1
                    : secp256k1.derivePublicKeyCompressed(privateKeys[variableId]);
            }
            return `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`;
        },
        schnorr_data_signature: exports.compilerOperationBCHGenerateDataSignature('schnorr_data_signature', (secp256k1) => secp256k1.signMessageHashSchnorr),
        schnorr_signature: exports.compilerOperationBCHGenerateSignature('schnorr_signature', (secp256k1) => secp256k1.signMessageHashSchnorr),
        signature: exports.compilerOperationBCHGenerateSignature('signature', (secp256k1) => secp256k1.signMessageHashDER),
    },
    SigningSerialization: {
        corresponding_output: exports.compilerOperationBCHGenerateSigningSerialization,
        corresponding_output_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode: exports.compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode_length: exports.compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs: exports.compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs_single_input: exports.compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output: exports.compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output_single_input: exports.compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs: exports.compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs_single_input: exports.compilerOperationBCHGenerateSigningSerialization,
        locktime: exports.compilerOperationBCHGenerateSigningSerialization,
        outpoint_index: exports.compilerOperationBCHGenerateSigningSerialization,
        outpoint_transaction_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        output_value: exports.compilerOperationBCHGenerateSigningSerialization,
        sequence_number: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers: exports.compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers_hash: exports.compilerOperationBCHGenerateSigningSerialization,
        version: exports.compilerOperationBCHGenerateSigningSerialization,
    },
});
/**
 * Create a `Compiler` from the provided compilation environment. This method
 * requires a full `CompilationEnvironment` and does not instantiate any new
 * crypto or VM implementations.
 *
 * @param compilationEnvironment - the environment from which to create the
 * compiler
 */
exports.createCompiler = (compilationEnvironment) => ({
    generateBytecode: (script, data, 
    // TODO: TS bug?
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    debug = false
    // TODO: is there a way to avoid this `any`?
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) => {
        const result = compile_1.compileScript(script, data, compilationEnvironment);
        return debug
            ? result
            : result.success
                ? { bytecode: result.bytecode, success: true }
                : { errorType: result.errorType, errors: result.errors, success: false };
    },
});
/**
 * A common `createState` implementation for most compilers.
 *
 * @param instructions - the list of instructions to incorporate in the created
 * state.
 */
exports.compilerCreateStateCommon = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
instructions) => instruction_sets_1.createAuthenticationProgramStateCommon(instructions, [], instruction_sets_1.createAuthenticationProgramExternalStateCommonEmpty());
/**
 * Create a compiler using the default BCH environment.
 *
 * Internally instantiates the necessary crypto and VM implementations – use
 * `createCompiler` for more control.
 *
 * @param overrides - a compilation environment from which properties will be used
 * to override properties of the default BCH environment
 */
exports.createCompilerBCH = async (overrides) => {
    const [sha256, secp256k1, vm] = await Promise.all([
        crypto_1.instantiateSha256(),
        crypto_1.instantiateSecp256k1(),
        instruction_sets_1.instantiateVirtualMachineBCH(instruction_sets_1.instructionSetBCHCurrentStrict),
    ]);
    return exports.createCompiler(Object.assign({
        createState: exports.compilerCreateStateCommon,
        opcodes: instruction_sets_1.generateBytecodeMap(instruction_sets_1.OpcodesBCH),
        operations: exports.getCompilerOperationsBCH(),
        secp256k1,
        sha256,
        vm,
    }, overrides));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvdGVtcGxhdGVzL2NvbXBpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsZ0RBSTZCO0FBQzdCLGdEQUk2QjtBQUM3Qiw0RkFHMEQ7QUFDMUQsMkVBUThDO0FBSTlDLGdEQUk0QjtBQUM1QixnREFJNEI7QUF1QjVCLDhCQUE4QjtBQUM5QixJQUFZLHVDQXlCWDtBQXpCRCxXQUFZLHVDQUF1QztJQUNqRDs7T0FFRztJQUNILHNFQUEyQixDQUFBO0lBQzNCOztPQUVHO0lBQ0gsZ0dBQXFELENBQUE7SUFDckQ7O09BRUc7SUFDSCx3RkFBNkMsQ0FBQTtJQUM3Qzs7T0FFRztJQUNILGtIQUF1RSxDQUFBO0lBQ3ZFOztPQUVHO0lBQ0gsb0VBQXlCLENBQUE7SUFDekI7O09BRUc7SUFDSCw4RkFBbUQsQ0FBQTtBQUNyRCxDQUFDLEVBekJXLHVDQUF1QyxHQUF2QywrQ0FBdUMsS0FBdkMsK0NBQXVDLFFBeUJsRDtBQXFDRCxJQUFLLHFCQUlKO0FBSkQsV0FBSyxxQkFBcUI7SUFDeEIseUZBQWdFLENBQUE7SUFDaEUsa0dBQXlFLENBQUE7SUFDekUsd0dBQStFLENBQUE7QUFDakYsQ0FBQyxFQUpJLHFCQUFxQixLQUFyQixxQkFBcUIsUUFJekI7QUFFRCxzQ0FBc0M7QUFDdEMsTUFBTSwyQkFBMkIsR0FBRyxDQUNsQyxtQkFBMkIsRUFDM0IsTUFBTSxHQUFHLEVBQUUsRUFDWCxFQUFFO0lBQ0YsUUFBUSxtQkFBbUIsRUFBRTtRQUMzQixLQUFLLEdBQUcsTUFBTSxHQUFHLHVDQUF1QyxDQUFDLFdBQVcsRUFBRTtZQUNwRSxPQUFPLFVBQVUsQ0FBQyxFQUFFO1lBQ2xCLHNDQUFzQztZQUN0QyxnREFBd0IsQ0FBQyxXQUFXLEdBQUcsZ0RBQXdCLENBQUMsT0FBTyxDQUN4RSxDQUFDO1FBQ0osS0FBSyxHQUFHLE1BQU0sR0FBRyx1Q0FB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
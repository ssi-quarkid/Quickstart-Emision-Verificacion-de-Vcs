"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const combinators_1 = require("../common/combinators");
const common_1 = require("../common/common");
const instruction_sets_utils_1 = require("../instruction-sets-utils");
const bch_errors_1 = require("./bch-errors");
const bch_opcodes_1 = require("./bch-opcodes");
exports.OpcodesBCH = bch_opcodes_1.OpcodesBCH;
const bch_operations_1 = require("./bch-operations");
exports.isPayToScriptHash = (verificationInstructions) => verificationInstructions.length === 3 /* length */ &&
    verificationInstructions[0].opcode ===
        bch_opcodes_1.OpcodesBCH.OP_HASH160 &&
    verificationInstructions[1].opcode ===
        bch_opcodes_1.OpcodesBCH.OP_PUSHBYTES_20 &&
    verificationInstructions[2 /* lastElement */]
        .opcode === bch_opcodes_1.OpcodesBCH.OP_EQUAL;
/**
 * Test a stack item for the SegWit Recovery Rules activated in `BCH_2019_05`.
 *
 * @param bytecode - the stack item to test
 */
// eslint-disable-next-line complexity
exports.isWitnessProgram = (bytecode) => {
    const correctLength = bytecode.length >= 4 /* minimumLength */ &&
        bytecode.length <= 42 /* maximumLength */;
    const validVersionPush = bytecode[0] === 0 /* OP_0 */ ||
        (bytecode[0] >= 81 /* OP_1 */ && bytecode[0] <= 96 /* OP_16 */);
    const correctLengthByte = bytecode[1] + 2 /* versionAndLengthBytes */ === bytecode.length;
    return correctLength && validVersionPush && correctLengthByte;
};
/**
 * From C++ implementation:
 * Note that IsPushOnly() *does* consider OP_RESERVED to be a push-type
 * opcode, however execution of OP_RESERVED fails, so it's not relevant to
 * P2SH/BIP62 as the scriptSig would fail prior to the P2SH special
 * validation code being executed.
 */
const isPushOperation = (opcode) => opcode < bch_opcodes_1.OpcodesBCH.OP_16;
/**
 * This library's supported versions of the BCH virtual machine. "Strict"
 * versions (A.K.A. `isStandard` from the C++ implementations) enable additional
 * validation which is commonly used on the P2P network before relaying
 * transactions. Transactions which fail these rules are often called
 * "non-standard" â€“ the transactions can technically be included by miners in
 * valid blocks, but most network nodes will refuse to relay them.
 */
var InstructionSetBCH;
(function (InstructionSetBCH) {
    InstructionSetBCH["BCH_2019_05"] = "BCH_2019_05";
    InstructionSetBCH["BCH_2019_05_STRICT"] = "BCH_2019_05_STRICT";
    InstructionSetBCH["BCH_2019_11_SPEC"] = "BCH_2019_11";
    InstructionSetBCH["BCH_2019_11_STRICT_SPEC"] = "BCH_2019_11_STRICT";
})(InstructionSetBCH = exports.InstructionSetBCH || (exports.InstructionSetBCH = {}));
exports.instructionSetBCHCurrentStrict = InstructionSetBCH.BCH_2019_05_STRICT;
exports.getFlagsForInstructionSetBCH = (instructionSet) => {
    switch (instructionSet) {
        case InstructionSetBCH.BCH_2019_05:
            return {
                disallowUpgradableNops: false,
                requireBugValueZero: false,
                requireMinimalEncoding: false,
                requireNullSignatureFailures: true,
            };
        case InstructionSetBCH.BCH_2019_05_STRICT:
            return {
                disallowUpgradableNops: true,
                requireBugValueZero: false,
                requireMinimalEncoding: true,
                requireNullSignatureFailures: true,
            };
        case InstructionSetBCH.BCH_2019_11_SPEC:
            return {
                disallowUpgradableNops: false,
                requireBugValueZero: true,
                requireMinimalEncoding: true,
                requireNullSignatureFailures: true,
            };
        case InstructionSetBCH.BCH_2019_11_STRICT_SPEC:
            return {
                disallowUpgradableNops: true,
                requireBugValueZero: true,
                requireMinimalEncoding: true,
                requireNullSignatureFailures: true,
            };
        default:
            return new Error(`${instructionSet} is not an instruction set.`);
    }
};
/**
 * Initialize a new instruction set for the BCH virtual machine.
 *
 * @param flags - an object configuring the flags for this vm (see
 * `getFlagsForInstructionSetBCH`)
 * @param sha1 - a Sha1 implementation
 * @param sha256 - a Sha256 implementation
 * @param ripemd160 - a Ripemd160 implementation
 * @param secp256k1 - a Secp256k1 implementation
 */
exports.createInstructionSetBCH = ({ flags, ripemd160, secp256k1, sha1, sha256, }) => (Object.assign(Object.assign({ clone: common_1.cloneAuthenticationProgramStateCommon, continue: (state) => state.error === undefined && state.ip < state.instructions.length, 
    // eslint-disable-next-line complexity
    evaluate: (program, stateEvaluate) => {
        var _a;
        const { unlockingBytecode } = program.spendingTransaction.inputs[program.inputIndex];
        const { lockingBytecode } = program.sourceOutput;
        const unlockingInstructions = instruction_sets_utils_1.parseBytecode(unlockingBytecode);
        const lockingInstructions = instruction_sets_utils_1.parseBytecode(lockingBytecode);
        const externalState = common_1.createAuthenticationProgramExternalStateCommon(program);
        const initialState = common_1.createAuthenticationProgramStateCommon(unlockingInstructions, [], externalState);
        const unlockingResult = unlockingBytecode.length > common_1.ConsensusCommon.maximumBytecodeLength
            ? common_1.applyError(common_1.AuthenticationErrorCommon.exceededMaximumBytecodeLengthUnlocking, initialState)
            : instruction_sets_utils_1.authenticationInstructionsAreMalformed(unlockingInstructions)
                ? common_1.applyError(common_1.AuthenticationErrorCommon.malformedUnlockingBytecode, initialState)
                : lockingBytecode.length > common_1.ConsensusCommon.maximumBytecodeLength
                    ? common_1.applyError(common_1.AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking, initialState)
                    : instruction_sets_utils_1.authenticationInstructionsAreMalformed(lockingInstructions)
                        ? common_1.applyError(common_1.AuthenticationErrorCommon.malformedLockingBytecode, initialState)
                        : initialState.instructions.every((instruction) => isPushOperation(instruction.opcode))
                            ? stateEvaluate(initialState)
                            : common_1.applyError(bch_errors_1.AuthenticationErrorBCH.requiresPushOnly, initialState);
        if (unlockingResult.error !== undefined) {
            return unlockingResult;
        }
        const lockingResult = stateEvaluate(common_1.createAuthenticationProgramStateCommon(lockingInstructions, unlockingResult.stack, externalState));
        if (!exports.isPayToScriptHash(lockingInstructions)) {
            return lockingResult;
        }
        const p2shStack = common_1.cloneStack(unlockingResult.stack);
        // eslint-disable-next-line functional/immutable-data
        const p2shScript = (_a = p2shStack.pop()) !== null && _a !== void 0 ? _a : Uint8Array.of();
        if (p2shStack.length === 0 && exports.isWitnessProgram(p2shScript)) {
            return lockingResult;
        }
        const p2shInstructions = instruction_sets_utils_1.parseBytecode(p2shScript);
        return instruction_sets_utils_1.authenticationInstructionsAreMalformed(p2shInstructions)
            ? Object.assign(Object.assign({}, lockingResult), { error: bch_errors_1.AuthenticationErrorBCH.malformedP2shBytecode }) : stateEvaluate(common_1.createAuthenticationProgramStateCommon(p2shInstructions, p2shStack, externalState));
    }, operations: Object.assign(Object.assign({}, common_1.commonOperations({ flags, ripemd160, secp256k1, sha1, sha256 })), combinators_1.mapOverOperations(bch_operations_1.bitcoinCashOperations({
        flags,
        secp256k1,
        sha256,
    }), combinators_1.conditionallyEvaluate, combinators_1.incrementOperationCount, common_1.checkLimitsCommon)) }, common_1.undefinedOperation()), { verify: (state) => state.error === undefined &&
        state.executionStack.length === 0 &&
        state.stack.length === 1 &&
        common_1.stackItemIsTruthy(state.stack[0]) }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmNoLWluc3RydWN0aW9uLXNldHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvaW5zdHJ1Y3Rpb24tc2V0cy9iY2gvYmNoLWluc3RydWN0aW9uLXNldHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQSx1REFJK0I7QUFDL0IsNkNBWTBCO0FBRTFCLHNFQUdtQztBQUVuQyw2Q0FBc0Q7QUFDdEQsK0NBQTJDO0FBT2xDLHFCQVBBLHdCQUFVLENBT0E7QUFObkIscURBQXlEO0FBYTVDLFFBQUEsaUJBQWlCLEdBQUcsQ0FDL0Isd0JBQXVFLEVBQ3ZFLEVBQUUsQ0FDRix3QkFBd0IsQ0FBQyxNQUFNLG1CQUEyQjtJQUN4RCx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUE2QjtRQUN6RCx3QkFBVSxDQUFDLFVBQVU7SUFDckIsd0JBQXdCLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBNkI7UUFDekQsd0JBQVUsQ0FBQyxlQUFlO0lBQzFCLHdCQUF3QixxQkFBNkI7U0FDcEQsTUFBNkIsS0FBSyx3QkFBVSxDQUFDLFFBQVEsQ0FBQztBQVczRDs7OztHQUlHO0FBQ0gsc0NBQXNDO0FBQ3pCLFFBQUEsZ0JBQWdCLEdBQUcsQ0FBQyxRQUFvQixFQUFFLEVBQUU7SUFDdkQsTUFBTSxhQUFhLEdBQ2pCLFFBQVEsQ0FBQyxNQUFNLHlCQUF3QjtRQUN2QyxRQUFRLENBQUMsTUFBTSwwQkFBd0IsQ0FBQztJQUMxQyxNQUFNLGdCQUFnQixHQUNwQixRQUFRLENBQUMsQ0FBQyxDQUFDLGlCQUFnQjtRQUMzQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsaUJBQWUsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLGtCQUFnQixDQUFDLENBQUM7SUFDOUQsTUFBTSxpQkFBaUIsR0FDckIsUUFBUSxDQUFDLENBQUMsQ0FBQyxnQ0FBK0IsS0FBSyxRQUFRLENBQUMsTUFBTSxDQUFDO0lBQ2pFLE9BQU8sYUFB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
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ScriptNumberError;
(function (ScriptNumberError) {
    ScriptNumberError["outOfRange"] = "Failed to parse Script Number: overflows Script Number range.";
    ScriptNumberError["requiresMinimal"] = "Failed to parse Script Number: the number is not minimally-encoded.";
})(ScriptNumberError = exports.ScriptNumberError || (exports.ScriptNumberError = {}));
exports.isScriptNumberError = (value) => value === ScriptNumberError.outOfRange ||
    value === ScriptNumberError.requiresMinimal;
const normalMaximumScriptNumberByteLength = 4;
/**
 * This method attempts to parse a "Script Number", a format with which numeric
 * values are represented on the stack. (The Satoshi implementation calls this
 * `CScriptNum`.)
 *
 * If `bytes` is a valid Script Number, this method returns the represented
 * number in BigInt format. If `bytes` is not valid, a `ScriptNumberError` is
 * returned.
 *
 * All common operations accepting numeric parameters or pushing numeric values
 * to the stack currently use the Script Number format. The binary format of
 * numbers wouldn't be important if they could only be operated on by arithmetic
 * operators, but since the results of these operations may become input to
 * other operations (e.g. hashing), the specific representation is consensus-
 * critical.
 *
 * Parsing of Script Numbers is limited to 4 bytes (with the exception of
 * OP_CHECKLOCKTIMEVERIFY and OP_CHECKSEQUENCEVERIFY, which read up to 5-bytes).
 * The bytes are read as a signed integer (for 32-bits: inclusive range from
 * -2^31 + 1 to 2^31 - 1) in little-endian byte order. Script Numbers must
 * further be encoded as minimally as possible (no zero-padding). See code/tests
 * for details.
 *
 * @remarks
 * Operators may push numeric results to the stack which exceed the current
 * 4-byte length limit of Script Numbers. While these stack elements would
 * otherwise be valid Script Numbers, because of the 4-byte length limit, they
 * can only be used as non-numeric values in later operations.
 *
 * Most other implementations currently parse Script Numbers into 64-bit
 * integers to operate on them (rather than integers of arbitrary size like
 * BigInt). Currently, no operators are at risk of overflowing 64-bit integers
 * given 32-bit integer inputs, but future operators may require additional
 * refactoring in those implementations.
 *
 * @param bytes - a Uint8Array from the stack
 * @param requireMinimalEncoding - if true, this method returns an error when
 * parsing non-minimally encoded Script Numbers
 * @param maximumScriptNumberByteLength - the maximum valid number of bytes
 */
// eslint-disable-next-line complexity
exports.parseBytesAsScriptNumber = (bytes, requireMinimalEncoding = true, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength) => {
    if (bytes.length === 0) {
        return BigInt(0);
    }
    if (bytes.length > maximumScriptNumberByteLength) {
        return ScriptNumberError.outOfRange;
    }
    const mostSignificantByte = bytes[bytes.length - 1];
    const secondMostSignificantByte = bytes[bytes.length - 1 - 1];
    const allButTheSignBit = 127;
    const justTheSignBit = 128;
    if (requireMinimalEncoding &&
        // eslint-disable-next-line no-bitwise
        (mostSignificantByte & allButTheSignBit) === 0 &&
        // eslint-disable-next-line no-bitwise
        (bytes.length <= 1 || (secondMostSignificantByte & justTheSignBit) === 0)) {
        return ScriptNumberError.requiresMinimal;
    }
    const bitsPerByte = 8;
    const signFlippingByte = 0x80;
    // eslint-disable-next-line functional/no-let
    let result = BigInt(0);
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let byte = 0; byte < bytes.length; byte++) {
        // eslint-disable-next-line functional/no-expression-statement,  no-bitwise
        result |= BigInt(bytes[byte]) << BigInt(byte * bitsPerByte);
    }
    /* eslint-disable no-bitwise */
    const isNegative = (bytes[bytes.length - 1] & signFlippingByte) !== 0;
    return isNegative
        ? -(result &
            ~(BigInt(signFlippingByte) << BigInt(bitsPerByte * (bytes.length - 1))))
        : result;
    /* eslint-enable no-bitwise */
};
/**
 * Convert a BigInt into the "Script Number" format. See
 * `parseBytesAsScriptNumber` for more information.
 *
 * @param integer - the BigInt to encode as a Script Number
 */
// eslint-disable-next-line complexity
exports.bigIntToScriptNumber = (integer) => {
    if (integer === BigInt(0)) {
        return new Uint8Array();
    }
    const bytes = [];
    const isNegative = integer < 0;
    const byteStates = 0xff;
    const bitsPerByte = 8;
    // eslint-disable-next-line functional/no-let
    let remaining = isNegative ? -integer : integer;
    // eslint-disable-next-line functional/no-loop-statement
    while (remaining > 0) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data, no-bitwise
        bytes.push(Number(remaining & BigInt(byteStates)));
        // eslint-disable-next-line functional/no-expression-statement, no-bitwise
        remaining >>= BigInt(bitsPerByte);
    }
    const signFlippingByte = 0x80;
    // eslint-disable-next-line no-bitwise, functional/no-conditional-statement
    if ((bytes[bytes.length - 1] & signFlippingByte) > 0) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        bytes.push(isNegative ? signFlippingByte : 0x00);
        // eslint-disable-next-line functional/no-conditional-statement
    }
    else if (isNegative) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data, no-bitwise
        bytes[bytes.length - 1] |= signFlippingByte;
    }
    return new Uint8Array(bytes);
};
/**
 * Returns true if the provided stack item is "truthy" in the sense required
 * by several operations (anything but zero and "negative zero").
 *
 * The Satoshi implementation calls this method `CastToBool`.
 *
 * @param item - the stack item to check for truthiness
 */
exports.stackItemIsTruthy = (item) => {
    const signFlippingByte = 0x80;
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < item.length; i++) {
        if (item[i] !== 0) {
            if (i === item.length - 1 && item[i] === signFlippingByte) {
                return false;
            }
            return true;
        }
    }
    return false;
};
/**
 * Convert a boolean into Script Number format (the type used to express
 * boolean values emitted by several operations).
 *
 * @param value - the boolean value to convert
 */
exports.booleanToScriptNumber = (value) => value ? exports.bigIntToScriptNumber(BigInt(1)) : exports.bigIntToScriptNumber(BigInt(0));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvaW5zdHJ1Y3Rpb24tc2V0cy9jb21tb24vdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFZLGlCQUdYO0FBSEQsV0FBWSxpQkFBaUI7SUFDM0IsaUdBQTRFLENBQUE7SUFDNUUsNEdBQXVGLENBQUE7QUFDekYsQ0FBQyxFQUhXLGlCQUFpQixHQUFqQix5QkFBaUIsS0FBakIseUJBQWlCLFFBRzVCO0FBRVksUUFBQSxtQkFBbUIsR0FBRyxDQUNqQyxLQUFpQyxFQUNMLEVBQUUsQ0FDOUIsS0FBSyxLQUFLLGlCQUFpQixDQUFDLFVBQVU7SUFDdEMsS0FBSyxLQUFLLGlCQUFpQixDQUFDLGVBQWUsQ0FBQztBQUU5QyxNQUFNLG1DQUFtQyxHQUFHLENBQUMsQ0FBQztBQUU5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUNHO0FBQ0gsc0NBQXNDO0FBQ3pCLFFBQUEsd0JBQXdCLEdBQUcsQ0FDdEMsS0FBaUIsRUFDakIsc0JBQXNCLEdBQUcsSUFBSSxFQUM3Qiw2QkFBNkIsR0FBRyxtQ0FBbUMsRUFDdkMsRUFBRTtJQUM5QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLDZCQUE2QixFQUFFO1FBQ2hELE9BQU8saUJBQWlCLENBQUMsVUFBVSxDQUFDO0tBQ3JDO0lBQ0QsTUFBTSxtQkFBbUIsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwRCxNQUFNLHlCQUF5QixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5RCxNQUFNLGdC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
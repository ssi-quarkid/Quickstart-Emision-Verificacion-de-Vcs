"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bch_1 = require("../bch/bch");
const signing_serialization_1 = require("./signing-serialization");
exports.isValidUncompressedPublicKeyEncoding = (publicKey) => publicKey.length === 65 /* uncompressedByteLength */ &&
    publicKey[0] === 4 /* uncompressedHeaderByte */;
exports.isValidCompressedPublicKeyEncoding = (publicKey) => publicKey.length === 33 /* compressedByteLength */ &&
    (publicKey[0] === 2 /* compressedHeaderByteEven */ ||
        publicKey[0] === 3 /* compressedHeaderByteOdd */);
exports.isValidPublicKeyEncoding = (publicKey) => exports.isValidCompressedPublicKeyEncoding(publicKey) ||
    exports.isValidUncompressedPublicKeyEncoding(publicKey);
const isNegative = (value) => 
// eslint-disable-next-line no-bitwise
(value & 128 /* negative */) !== 0;
const hasUnnecessaryPadding = (length, firstByte, secondByte) => length > 1 && firstByte === 0 && !isNegative(secondByte);
const isValidInteger = (signature, tagIndex, length, valueIndex
// eslint-disable-next-line max-params
) => signature[tagIndex] === 2 /* integerTagType */ &&
    length !== 0 &&
    !isNegative(signature[valueIndex]) &&
    !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
/**
 * Validate a DER-encoded signature.
 *
 * @remarks
 * This function is consensus-critical since BIP66, but differs from the BIP66
 * specification in that it does not validate the existence of a signing
 * serialization type byte at the end of the signature (to support
 * OP_CHECKDATASIG). To validate a bitcoin-encoded signature (including null
 * signatures), use `isValidSignatureEncodingBCH`.
 *
 * @privateRemarks
 * From the Bitcoin ABC C++ implementation:
 *
 * Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
 * total-length: 1-byte length descriptor of everything that follows,
 * excluding the sighash byte.
 * R-length: 1-byte length descriptor of the R value that follows.
 * R: arbitrary-length big-endian encoded R value. It must use the
 * shortest possible encoding for a positive integers (which means no null
 * bytes at the start, except a single one when the next byte has its highest
 * bit set).
 * S-length: 1-byte length descriptor of the S value that follows.
 * S: arbitrary-length big-endian encoded S value. The same rules apply.
 */
// eslint-disable-next-line complexity
exports.isValidSignatureEncodingDER = (signature) => {
    const correctLengthRange = signature.length > 8 /* minimumLength */ &&
        signature.length < 72 /* maximumLength */;
    const correctSequenceTagType = signature[0 /* sequenceTagIndex */] === 48 /* sequenceTagType */;
    const correctSequenceLength = signature[1 /* sequenceLengthIndex */] ===
        signature.length - 2 /* sequenceMetadataBytes */;
    const rLength = signature[3 /* rLengthIndex */];
    if (rLength === undefined) {
        return false;
    }
    const consistentRLength = rLength <= signature.length - 7 /* minimumNonRValueBytes */;
    const rIsValid = isValidInteger(signature, 2 /* rTagIndex */, rLength, 4 /* rValueIndex */);
    const sTagIndex = 4 /* rValueIndex */ + rLength; // eslint-disable-line @typescript-eslint/restrict-plus-operands
    const sLengthIndex = sTagIndex + 1;
    const sLength = signature[sLengthIndex];
    if (sLength === undefined) {
        return false;
    }
    const sValueIndex = sLengthIndex + 1;
    const consistentSLength = sValueIndex + sLength === signature.length;
    const sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
    return (correctLengthRange &&
        correctSequenceTagType &&
        correctSequenceLength &&
        consistentRLength &&
        rIsValid &&
        consistentSLength &&
        sIsValid);
};
/**
 * Validate the encoding of a transaction signature, including a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param transactionSignature - the full transaction signature
 */
exports.isValidSignatureEncodingBCHTransaction = (transactionSignature) => transactionSignature.length === 0 ||
    transactionSignature.length === bch_1.ConsensusBCH.schnorrSignatureLength + 1 ||
    (signing_serialization_1.isDefinedSigningSerializationType(transactionSignature[transactionSignature.length - 1]) &&
        exports.isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1)));
/**
 * Split a bitcoin-encoded signature into a signature and signing serialization
 * type.
 *
 * While a bitcoin-encoded signature only includes a single byte to encode the
 * signing serialization type, a 3-byte forkId can be appended to the signing
 * serialization to provide replay-protection between different forks. (See
 * Bitcoin Cash's Replay Protected Sighash spec for details.)
 *
 * @param signature - a signature which passes `isValidSignatureEncoding`
 */
exports.decodeBitcoinSignature = (encodedSignature) => ({
    signature: encodedSignature.slice(0, encodedSignature.length - 1),
    signingSerializationType: new Uint8Array([
        encodedSignature[encodedSignature.length - 1],
    ]),
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2RpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvaW5zdHJ1Y3Rpb24tc2V0cy9jb21tb24vZW5jb2RpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxvQ0FBMEM7QUFFMUMsbUVBQTRFO0FBVS9ELFFBQUEsb0NBQW9DLEdBQUcsQ0FBQyxTQUFxQixFQUFFLEVBQUUsQ0FDNUUsU0FBUyxDQUFDLE1BQU0sb0NBQXFDO0lBQ3JELFNBQVMsQ0FBQyxDQUFDLENBQUMsbUNBQXFDLENBQUM7QUFFdkMsUUFBQSxrQ0FBa0MsR0FBRyxDQUFDLFNBQXFCLEVBQUUsRUFBRSxDQUMxRSxTQUFTLENBQUMsTUFBTSxrQ0FBbUM7SUFDbkQsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLHFDQUF1QztRQUNsRCxTQUFTLENBQUMsQ0FBQyxDQUFDLG9DQUFzQyxDQUFDLENBQUM7QUFFM0MsUUFBQSx3QkFBd0IsR0FBRyxDQUFDLFNBQXFCLEVBQUUsRUFBRSxDQUNoRSwwQ0FBa0MsQ0FBQyxTQUFTLENBQUM7SUFDN0MsNENBQW9DLENBQUMsU0FBUyxDQUFDLENBQUM7QUFxQ2xELE1BQU0sVUFBVSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7QUFDbkMsc0NBQXNDO0FBQ3RDLENBQUMsS0FBSyxxQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUVoQyxNQUFNLHFCQUFxQixHQUFHLENBQzVCLE1BQWMsRUFDZCxTQUFpQixFQUNqQixVQUFrQixFQUNsQixFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxTQUFTLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBRTlELE1BQU0sY0FBYyxHQUFHLENBQ3JCLFNBQXFCLEVBQ3JCLFFBQWdCLEVBQ2hCLE1BQWMsRUFDZCxVQUFrQjtBQUNsQixzQ0FBc0M7RUFDdEMsRUFBRSxDQUNGLFNBQVMsQ0FBQyxRQUFR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
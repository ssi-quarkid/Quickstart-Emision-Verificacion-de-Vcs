"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("../../../format/format");
/* eslint-disable camelcase */
/**
 * A.K.A. `sighash` flags
 */
var SigningSerializationFlag;
(function (SigningSerializationFlag) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationFlag[SigningSerializationFlag["all_outputs"] = 1] = "all_outputs";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationFlag[SigningSerializationFlag["no_outputs"] = 2] = "no_outputs";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationFlag[SigningSerializationFlag["corresponding_output"] = 3] = "corresponding_output";
    SigningSerializationFlag[SigningSerializationFlag["fork_id"] = 64] = "fork_id";
    /**
     * A.K.A `ANYONE_CAN_PAY`
     */
    SigningSerializationFlag[SigningSerializationFlag["single_input"] = 128] = "single_input";
})(SigningSerializationFlag = exports.SigningSerializationFlag || (exports.SigningSerializationFlag = {}));
exports.isDefinedSigningSerializationType = (byte) => {
    const baseType = 
    // eslint-disable-next-line no-bitwise
    byte &
        // eslint-disable-next-line no-bitwise
        ~(SigningSerializationFlag.fork_id | SigningSerializationFlag.single_input);
    return (baseType >= SigningSerializationFlag.all_outputs &&
        baseType <= SigningSerializationFlag.corresponding_output);
};
const match = (type, flag) => 
// eslint-disable-next-line no-bitwise
(type[0] & flag) !== 0;
const equals = (type, flag
// eslint-disable-next-line no-bitwise
) => (type[0] & 31 /* mask5Bits */) === flag;
const shouldSerializeSingleInput = (type) => match(type, SigningSerializationFlag.single_input);
const shouldSerializeCorrespondingOutput = (type) => equals(type, SigningSerializationFlag.corresponding_output);
const shouldSerializeNoOutputs = (type) => equals(type, SigningSerializationFlag.no_outputs);
const emptyHash = () => new Uint8Array(32 /* sha256HashByteLength */).fill(0);
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionOutpoints - see `generateSigningSerializationBCH`
 */
exports.hashPrevouts = ({ sha256, signingSerializationType, transactionOutpoints, }) => shouldSerializeSingleInput(signingSerializationType)
    ? emptyHash()
    : sha256.hash(sha256.hash(transactionOutpoints));
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionSequenceNumbers - see
 * `generateSigningSerializationBCH`
 */
exports.hashSequence = ({ sha256, signingSerializationType, transactionSequenceNumbers, }) => !shouldSerializeSingleInput(signingSerializationType) &&
    !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionSequenceNumbers))
    : emptyHash();
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionOutputs - see `generateSigningSerializationBCH`
 * @param correspondingOutput - see `generateSigningSerializationBCH`
 */
exports.hashOutputs = ({ correspondingOutput, sha256, signingSerializationType, transactionOutputs, }) => !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionOutputs))
    : shouldSerializeCorrespondingOutput(signingSerializationType)
        ? correspondingOutput === undefined
            ? emptyHash()
            : sha256.hash(sha256.hash(correspondingOutput))
        : emptyHash();
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 */
exports.generateSigningSerializationBCH = ({ correspondingOutput, coveredBytecode, forkId = new Uint8Array([0, 0, 0]), locktime, outpointIndex, outpointTransactionHash, outputValue, sequenceNumber, sha256, signingSerializationType, transactionOutpoints, transactionOutputs, transactionSequenceNumbers, version, }) => new Uint8Array([
    ...format_1.numberToBinUint32LE(version),
    ...exports.hashPrevouts({ sha256, signingSerializationType, transactionOutpoints }),
    ...exports.hashSequence({
        sha256,
        signingSerializationType,
        transactionSequenceNumbers,
    }),
    ...outpointTransactionHash.slice().reverse(),
    ...format_1.numberToBinUint32LE(outpointIndex),
    ...Uint8Array.from([
        ...format_1.bigIntToBitcoinVarInt(BigInt(coveredBytecode.length)),
        ...coveredBytecode,
    ]),
    ...format_1.bigIntToBinUint64LE(BigInt(outputValue)),
    ...format_1.numberToBinUint32LE(sequenceNumber),
    ...exports.hashOutputs({
        correspondingOutput,
        sha256,
        signingSerializationType,
        transactionOutputs,
    }),
    ...format_1.numberToBinUint32LE(locktime),
    ...signingSerializationType,
    ...forkId,
]);
/**
 * @param signingSerializationType - the 32-bit number indicating the signing
 * serialization algorithm to use
 */
exports.isLegacySigningSerialization = (signingSerializationType) => {
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const forkValue = signingSerializationType >> 8;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const newForkValue = (forkValue ^ 0xdead) | 0xff0000;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const sighashType = (newForkValue << 8) | (signingSerializationType & 0xff);
    // eslint-disable-next-line no-bitwise
    return (sighashType & SigningSerializationFlag.fork_id) === 0;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmluZy1zZXJpYWxpemF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9hdXRoL2luc3RydWN0aW9uLXNldHMvY29tbW9uL3NpZ25pbmctc2VyaWFsaXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG1EQUlnQztBQUVoQyw4QkFBOEI7QUFDOUI7O0dBRUc7QUFDSCxJQUFZLHdCQWtCWDtBQWxCRCxXQUFZLHdCQUF3QjtJQUNsQzs7T0FFRztJQUNILHFGQUFrQixDQUFBO0lBQ2xCOztPQUVHO0lBQ0gsbUZBQWlCLENBQUE7SUFDakI7O09BRUc7SUFDSCx1R0FBMkIsQ0FBQTtJQUMzQiw4RUFBYyxDQUFBO0lBQ2Q7O09BRUc7SUFDSCx5RkFBbUIsQ0FBQTtBQUNyQixDQUFDLEVBbEJXLHdCQUF3QixHQUF4QixnQ0FBd0IsS0FBeEIsZ0NBQXdCLFFBa0JuQztBQVFZLFFBQUEsaUNBQWlDLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRTtJQUNoRSxNQUFNLFFBQVE7SUFDWixzQ0FBc0M7SUFDdEMsSUFBSTtRQUNKLHNDQUFzQztRQUN0QyxDQUFDLENBQUMsd0JBQXdCLENBQUMsT0FBTyxHQUFHLHdCQUF3QixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlFLE9BQU8sQ0FDTCxRQUFRLElBQUksd0JBQXdCLENBQUMsV0FBVztRQUNoRCxRQUFRLElBQUksd0JBQXdCLENBQUMsb0JBQW9CLENBQzFELENBQUM7QUFDSixDQUFDLENBQUM7QUFFRixNQUFNLEtBQUssR0FBRyxDQUFDLElBQWdCLEVBQUUsSUFBOEIsRUFBRSxFQUFFO0FBQ2pFLHNDQUFzQztBQUN0QyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFekIsTUFBTSxNQUFNLEdBQUcsQ0FDYixJQUFnQixFQUNoQixJQUE4QjtBQUM5QixzQ0FBc0M7RUFDdEMsRUFBRSxD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
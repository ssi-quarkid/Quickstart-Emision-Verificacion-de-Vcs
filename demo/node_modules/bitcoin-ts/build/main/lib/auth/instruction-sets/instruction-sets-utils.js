"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("../../format/format");
const bch_1 = require("./bch/bch");
const btc_1 = require("./btc/btc");
exports.authenticationInstructionIsMalformed = (instruction) => instruction.malformed;
exports.authenticationInstructionsAreMalformed = (instructions) => instructions.length > 0 &&
    exports.authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
exports.authenticationInstructionsAreNotMalformed = (instructions) => !exports.authenticationInstructionsAreMalformed(instructions);
var CommonPushOpcodes;
(function (CommonPushOpcodes) {
    CommonPushOpcodes[CommonPushOpcodes["OP_0"] = 0] = "OP_0";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
})(CommonPushOpcodes || (CommonPushOpcodes = {}));
var Bytes;
(function (Bytes) {
    Bytes[Bytes["Uint8"] = 1] = "Uint8";
    Bytes[Bytes["Uint16"] = 2] = "Uint16";
    Bytes[Bytes["Uint32"] = 4] = "Uint32";
})(Bytes || (Bytes = {}));
const readLittleEndianNumber = (script, index, length) => {
    const view = new DataView(script.buffer, index, length);
    const readAsLittleEndian = true;
    return length === Bytes.Uint8
        ? view.getUint8(0)
        : length === Bytes.Uint16
            ? view.getUint16(0, readAsLittleEndian)
            : view.getUint32(0, readAsLittleEndian);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode - an opcode between 0x00 and 0x4e
 */
exports.lengthBytesForPushOpcode = (opcode) => opcode < CommonPushOpcodes.OP_PUSHDATA_1
    ? 0
    : opcode === CommonPushOpcodes.OP_PUSHDATA_1
        ? Bytes.Uint8
        : opcode === CommonPushOpcodes.OP_PUSHDATA_2
            ? Bytes.Uint16
            : Bytes.Uint32;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script - the script from which to read the next instruction
 * @param index - the offset from which to begin reading
 */
// eslint-disable-next-line complexity
exports.readAuthenticationInstruction = (script, index) => {
    const opcode = script[index];
    if (opcode > CommonPushOpcodes.OP_PUSHDATA_4) {
        return {
            instruction: {
                opcode: opcode,
            },
            nextIndex: index + 1,
        };
    }
    const lengthBytes = exports.lengthBytesForPushOpcode(opcode);
    const pushBytes = lengthBytes === 0;
    if (!pushBytes && index + lengthBytes >= script.length) {
        const sliceStart = index + 1;
        const sliceEnd = sliceStart + lengthBytes;
        return {
            instruction: {
                expectedLengthBytes: lengthBytes,
                length: script.slice(sliceStart, sliceEnd),
                malformed: true,
                opcode: opcode,
            },
            nextIndex: sliceEnd,
        };
    }
    const dataBytes = pushBytes
        ? opcode
        : readLittleEndianNumber(script, index + 1, lengthBytes);
    const dataStart = index + 1 + lengthBytes;
    const dataEnd = dataStart + dataBytes;
    return {
        instruction: Object.assign(Object.assign({ data: script.slice(dataStart, dataEnd) }, (dataEnd > script.length
            ? {
                expectedDataBytes: dataEnd - dataStart,
                malformed: true,
            }
            : undefined)), { opcode: opcode }),
        nextIndex: dataEnd,
    };
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script - the serialized script to parse
 */
exports.parseBytecode = (script) => {
    const instructions = [];
    // eslint-disable-next-line functional/no-let
    let i = 0;
    // eslint-disable-next-line functional/no-loop-statement
    while (i < script.length) {
        const { instruction, nextIndex } = exports.readAuthenticationInstruction(script, i);
        // eslint-disable-next-line functional/no-expression-statement
        i = nextIndex;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        instructions.push(instruction);
    }
    return instructions;
};
const isPush = (instruction) => instruction.data !== undefined;
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */
const isMultiWordPush = (opcode) => opcode !== CommonPushOpcodes.OP_0;
const formatAsmPushHex = (data) => data.length > 0 ? `0x${format_1.binToHex(data)}` : '';
const formatMissingBytesAsm = (missing) => `[missing ${missing} byte${missing === 1 ? '' : 's'}]`;
const hasMalformedLength = (instruction) => instruction
    .length !== undefined;
const isPushData = (pushOpcode) => pushOpcode >= CommonPushOpcodes.OP_PUSHDATA_1;
exports.disassembleParsedAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode]} ${hasMalformedLength(instruction)
    ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}`
    : `${isPushData(instruction.opcode)
        ? `${instruction.expectedDataBytes} `
        : ''}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
exports.disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode]}${isPush(instruction) &&
    isMultiWordPush(instruction.opcode)
    ? ` ${isPushData(instruction.opcode)
        ? `${instruction.data.length} `
        : ''}${formatAsmPushHex(instruction.data)}`
    : ''}`;
exports.disassembleParsedAuthenticationInstruction = (opcodes, instruction) => exports.authenticationInstructionIsMalformed(instruction)
    ? exports.disassembleParsedAuthenticationInstructionMalformed(opcodes, instruction)
    : exports.disassembleAuthenticationInstruction(opcodes, instruction);
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script - the array of instructions to disassemble
 */
exports.disassembleParsedAuthenticationInstructions = (opcodes, instructions) => instructions
    .map((instruction) => exports.disassembleParsedAuthenticationInstruction(opcodes, instruction))
    .join(' ');
/**
 * Disassemble authentication bytecode into a lossless ASM representation.
 *
 * TODO: a similar method which re-formats ASM strings, converting HexLiterals to Script Numbers or UTF8Literals.
 *
 * @param opcodes - the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode - the authentication bytecode to disassemble
 */
exports.disassembleBytecode = (opcodes, bytecode) => exports.disassembleParsedAuthenticationInstructions(opcodes, exports.parseBytecode(bytecode));
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode - the authentication bytecode to disassemble
 */
exports.disassembleBytecodeBCH = (bytecode) => exports.disassembleParsedAuthenticationInstructions(bch_1.OpcodesBCH, exports.parseBytecode(bytecode));
// TODO: assembleBytecodeBCH â€“ instantiate synchronous compiler, throw any errors
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode - the authentication bytecode to disassemble
 */
exports.disassembleBytecodeBTC = (bytecode) => exports.disassembleParsedAuthenticationInstructions(btc_1.OpcodesBTC, exports.parseBytecode(bytecode));
// TODO: assembleBytecodeBTC
const getInstructionLengthBytes = (instruction) => {
    const opcode = instruction.opcode;
    const expectedLength = exports.lengthBytesForPushOpcode(opcode);
    return expectedLength === Bytes.Uint8
        ? Uint8Array.of(instruction.data.length)
        : expectedLength === Bytes.Uint16
            ? format_1.numberToBinUint16LE(instruction.data.length)
            : format_1.numberToBinUint32LE(instruction.data.length);
};
exports.serializeAuthenticationInstruction = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...(isPush(instruction)
        ? [
            ...(isPushData(instruction.opcode)
                ? getInstructionLengthBytes(instruction)
                : []),
            ...instruction.data,
        ]
        : []),
]);
exports.serializeParsedAuthenticationInstructionMalformed = (instruction) => {
    const opcode = instruction.opcode;
    if (hasMalformedLength(instruction)) {
        return Uint8Array.from([opcode, ...instruction.length]);
    }
    if (isPushData(opcode)) {
        return Uint8Array.from([
            opcode,
            ...(opcode === CommonPushOpcodes.OP_PUSHDATA_1
                ? Uint8Array.of(instruction.expectedDataBytes)
                : opcode === CommonPushOpcodes.OP_PUSHDATA_2
                    ? format_1.numberToBinUint16LE(instruction.expectedDataBytes)
                    : format_1.numberToBinUint32LE(instruction.expectedDataBytes)),
            ...instruction.data,
        ]);
    }
    return Uint8Array.from([opcode, ...instruction.data]);
};
exports.serializeParsedAuthenticationInstruction = (instruction) => exports.authenticationInstructionIsMalformed(instruction)
    ? exports.serializeParsedAuthenticationInstructionMalformed(instruction)
    : exports.serializeAuthenticationInstruction(instruction);
exports.serializeAuthenticationInstructions = (instructions) => format_1.flattenBinArray(instructions.map(exports.serializeAuthenticationInstruction));
exports.serializeParsedAuthenticationInstructions = (instructions) => format_1.flattenBinArray(instructions.map(exports.serializeParsedAuthenticationInstruction));
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes - An opcode enum, e.g. `OpcodesBCH`
 */
exports.generateBytecodeMap = (opcodes) => Object.entries(opcodes)
    .filter((entry) => typeof entry[1] === 'number')
    .reduce((identifiers, pair) => (Object.assign(Object.assign({}, identifiers), { [pair[0]]: Uint8Array.of(pair[1]) })), {});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdHJ1Y3Rpb24tc2V0cy11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvYXV0aC9pbnN0cnVjdGlvbi1zZXRzL2luc3RydWN0aW9uLXNldHMtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxnREFLNkI7QUFFN0IsbUNBQXVDO0FBQ3ZDLG1DQUF1QztBQVUxQixRQUFBLG9DQUFvQyxHQUFHLENBQ2xELFdBQXFELEVBQ2EsRUFBRSxDQUNuRSxXQUFpRSxDQUFDLFNBQVMsQ0FBQztBQUVsRSxRQUFBLHNDQUFzQyxHQUFHLENBQ3BELFlBQXVELEVBQ2MsRUFBRSxDQUN2RSxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUM7SUFDdkIsNENBQW9DLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUVqRSxRQUFBLHlDQUF5QyxHQUFHLENBQ3ZELFlBQXVELEVBQ0QsRUFBRSxDQUN4RCxDQUFDLDhDQUFzQyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBRXhELElBQUssaUJBS0o7QUFMRCxXQUFLLGlCQUFpQjtJQUNwQix5REFBVyxDQUFBO0lBQ1gsNEVBQW9CLENBQUE7SUFDcEIsNEVBQW9CLENBQUE7SUFDcEIsNEVBQW9CLENBQUE7QUFDdEIsQ0FBQyxFQUxJLGlCQUFpQixLQUFqQixpQkFBaUIsUUFLckI7QUFFRCxJQUFLLEtBSUo7QUFKRCxXQUFLLEtBQUs7SUFDUixtQ0FBUyxDQUFBO0lBQ1QscUNBQVUsQ0FBQTtJQUNWLHFDQUFVLENBQUE7QUFDWixDQUFDLEVBSkksS0FBSyxLQUFMLEtBQUssUUFJVDtBQUVELE1BQU0sc0JBQXNCLEdBQUcsQ0FDN0IsTUFBa0IsRUFDbEIsS0FBYSxFQUNiLE1BQWEsRUFDYixFQUFFO0lBQ0YsTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUs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
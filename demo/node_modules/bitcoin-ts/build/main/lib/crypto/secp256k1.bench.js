"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable functional/no-expression-statement, functional/no-let, init-declarations */
const crypto_1 = require("crypto");
const ava_1 = __importDefault(require("ava"));
const chuhai_1 = __importDefault(require("chuhai"));
const elliptic = __importStar(require("elliptic"));
const secp256k1Node = __importStar(require("secp256k1"));
const lib_1 = require("../lib");
const secp256k1Promise = lib_1.instantiateSecp256k1();
const privateKeyLength = 32;
const secureRandom = () => crypto_1.randomBytes(privateKeyLength);
const setup = async () => ({
    ellipticEc: new elliptic.ec('secp256k1'),
    secp256k1: await secp256k1Promise,
});
/**
 * Note: elliptic doesn't document an equivalent to verifySignatureDERLowS, so
 * these benchmarks slightly overestimate elliptic's performance in applications
 * where Low-S verification is required (i.e. Bitcoin).
 *
 * We also help secp256k1-node a bit by converting each of it's inputs into
 * Node.js `Buffer` objects. So its performance here is a best case.
 */
ava_1.default('bench: secp256k1: verify signature Low-S, uncompressed pubkey', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await chuhai_1.default(t.title, (s) => {
        let messageHash;
        let pubkeyUncompressed;
        let sigDER;
        let result;
        let ellipticPublicKey;
        const nextCycle = () => {
            const privKey = lib_1.generatePrivateKey(secureRandom);
            messageHash = crypto_1.randomBytes(privateKeyLength);
            pubkeyUncompressed = secp256k1.derivePublicKeyUncompressed(privKey);
            ellipticPublicKey = ellipticEc.keyFromPublic(lib_1.binToHex(pubkeyUncompressed), 'hex');
            sigDER = secp256k1.signMessageHashDER(privKey, messageHash);
            result = false;
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            result = secp256k1.verifySignatureDERLowS(sigDER, pubkeyUncompressed, messageHash);
        });
        s.bench('elliptic', () => {
            result = ellipticEc
                .keyFromPublic(ellipticPublicKey)
                .verify(messageHash, sigDER);
        });
        s.bench('secp256k1-node', () => {
            result = secp256k1Node.ecdsaVerify(secp256k1Node.signatureImport(sigDER), messageHash, pubkeyUncompressed);
        });
        s.cycle(() => {
            t.true(result);
            nextCycle();
        });
    });
});
ava_1.default('bench: secp256k1: verify signature Low-S, compressed pubkey', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await chuhai_1.default(t.title, (s) => {
        let messageHash;
        let pubkeyCompressed;
        let sigDER;
        let result;
        let ellipticPublicKey;
        const nextCycle = () => {
            const privKey = lib_1.generatePrivateKey(secureRandom);
            messageHash = crypto_1.randomBytes(privateKeyLength);
            pubkeyCompressed = secp256k1.derivePublicKeyCompressed(privKey);
            ellipticPublicKey = ellipticEc.keyFromPublic(lib_1.binToHex(pubkeyCompressed), 'hex');
            sigDER = secp256k1.signMessageHashDER(privKey, messageHash);
            result = false;
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            result = secp256k1.verifySignatureDERLowS(sigDER, pubkeyCompressed, messageHash);
        });
        s.bench('elliptic', () => {
            result = ellipticEc
                .keyFromPublic(ellipticPublicKey)
                .verify(messageHash, sigDER);
        });
        s.bench('secp256k1-node', () => {
            result = secp256k1Node.ecdsaVerify(secp256k1Node.signatureImport(sigDER), messageHash, pubkeyCompressed);
        });
        s.cycle(() => {
            t.true(result);
            nextCycle();
        });
    });
});
ava_1.default('bench: secp256k1: derive compressed pubkey', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await chuhai_1.default(t.title, (s) => {
        let privKey;
        let pubkeyCompressedExpected;
        let pubkeyCompressedBenchmark;
        const nextCycle = () => {
            privKey = lib_1.generatePrivateKey(secureRandom);
            pubkeyCompressedExpected = secp256k1.derivePublicKeyCompressed(privKey);
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            pubkeyCompressedBenchmark = secp256k1.derivePublicKeyCompressed(privKey);
        });
        s.bench('elliptic', () => {
            pubkeyCompressedBenchmark = Uint8Array.from(ellipticEc.keyFromPrivate(privKey).getPublic().encodeCompressed());
        });
        s.bench('secp256k1-node', () => {
            pubkeyCompressedBenchmark = secp256k1Node.publicKeyCreate(privKey, true);
        });
        s.cycle(() => {
            t.deepEqual(pubkeyCompressedExpected, pubkeyCompressedBenchmark);
            nextCycle();
        });
    });
});
ava_1.default('bench: secp256k1: create DER Low-S signature', async (t) => {
    const { ellipticEc, secp256k1 } = await setup();
    await chuhai_1.default(t.title, (s) => {
        let privKey;
        let messageHash;
        let sigDERExpected;
        let sigDERBenchmark;
        const nextCycle = () => {
            privKey = lib_1.generatePrivateKey(secureRandom);
            messageHash = crypto_1.randomBytes(privateKeyLength);
            sigDERExpected = secp256k1.signMessageHashDER(privKey, messageHash);
        };
        nextCycle();
        s.bench('bitcoin-ts', () => {
            sigDERBenchmark = secp256k1.signMessageHashDER(privKey, messageHash);
        });
        s.bench('elliptic', () => {
            sigDERBenchmark = ellipticEc
                .keyFromPrivate(privKey)
                .sign(messageHash)
                .toDER();
        });
        s.bench('secp256k1-node', () => {
            sigDERBenchmark = secp256k1Node.signatureExport(secp256k1Node.ecdsaSign(messageHash, privKey).signature);
        });
        s.cycle(() => {
            /**
             * Since Elliptic doesn't document a way to create Low-S signatures, we
             * normalize the results to validate them. This may overestimate
             * Elliptic's performance slightly.
             */
            t.deepEqual(sigDERExpected, secp256k1.normalizeSignatureDER(new Uint8Array(sigDERBenchmark)));
            nextCycle();
        });
    });
});
ava_1.default('bench: secp256k1: sign: Schnorr vs. ECDSA', async (t) => {
    const { secp256k1 } = await setup();
    await chuhai_1.default(t.title, (s) => {
        let privKey;
        let messageHash;
        let sigDERExpected;
        let sigDERBenchmark;
        let sigSchnorrExpected;
        let sigSchnorrBenchmark;
        let isSchnorr;
        const nextCycle = () => {
            privKey = lib_1.generatePrivateKey(secureRandom);
            messageHash = crypto_1.randomBytes(privateKeyLength);
            sigDERExpected = secp256k1.signMessageHashDER(privKey, messageHash);
            sigSchnorrExpected = secp256k1.signMessageHashSchnorr(privKey, messageHash);
        };
        nextCycle();
        s.bench('secp256k1.signMessageHashDER', () => {
            isSchnorr = false;
            sigDERBenchmark = secp256k1.signMessageHashDER(privKey, messageHash);
        });
        s.bench('secp256k1.signMessageHashSchnorr', () => {
            isSchnorr = true;
            sigSchnorrBenchmark = secp256k1.signMessageHashSchnorr(privKey, messageHash);
        });
        s.cycle(() => {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            isSchnorr
                ? t.deepEqual(sigSchnorrExpected, sigSchnorrBenchmark)
                : t.deepEqual(sigDERExpected, sigDERBenchmark);
            nextCycle();
        });
    });
});
ava_1.default('bench: secp256k1: verify: Schnorr vs. ECDSA', async (t) => {
    const { secp256k1 } = await setup();
    await chuhai_1.default(t.title, (s) => {
        let messageHash;
        let pubkeyCompressed;
        let sigDER;
        let sigSchnorr;
        let result;
        const nextCycle = () => {
            const privKey = lib_1.generatePrivateKey(secureRandom);
            messageHash = crypto_1.randomBytes(privateKeyLength);
            pubkeyCompressed = secp256k1.derivePublicKeyCompressed(privKey);
            sigDER = secp256k1.signMessageHashDER(privKey, messageHash);
            sigSchnorr = secp256k1.signMessageHashSchnorr(privKey, messageHash);
            result = false;
        };
        nextCycle();
        s.bench('secp256k1.verifySignatureDERLowS (ECDSA, pubkey compressed)', () => {
            result = secp256k1.verifySignatureDERLowS(sigDER, pubkeyCompressed, messageHash);
        });
        s.bench('secp256k1.verifySignatureSchnorr (Schnorr, pubkey compressed)', () => {
            result = secp256k1.verifySignatureSchnorr(sigSchnorr, pubkeyCompressed, messageHash);
        });
        s.cycle(() => {
            t.true(result);
            nextCycle();
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmJlbmNoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jcnlwdG8vc2VjcDI1NmsxLmJlbmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLDZGQUE2RjtBQUM3RixtQ0FBcUM7QUFFckMsOENBQXVCO0FBQ3ZCLG9EQUEyQjtBQUMzQixtREFBcUM7QUFDckMseURBQTJDO0FBRTNDLGdDQUE0RTtBQUU1RSxNQUFNLGdCQUFnQixHQUFHLDBCQUFvQixFQUFFLENBQUM7QUFFaEQsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7QUFDNUIsTUFBTSxZQUFZLEdBQUcsR0FBRyxFQUFFLENBQUMsb0JBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBRXpELE1BQU0sS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN6QixVQUFVLEVBQUUsSUFBSSxRQUFRLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxTQUFTLEVBQUUsTUFBTSxnQkFBZ0I7Q0FDbEMsQ0FBQyxDQUFDO0FBRUg7Ozs7Ozs7R0FPRztBQUNILGFBQUksQ0FBQywrREFBK0QsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDaEYsTUFBTSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsR0FBRyxNQUFNLEtBQUssRUFBRSxDQUFDO0lBQ2hELE1BQU0sZ0JBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDekIsSUFBSSxXQUF1QixDQUFDO1FBQzVCLElBQUksa0JBQThCLENBQUM7UUFDbkMsSUFBSSxNQUFrQixDQUFDO1FBQ3ZCLElBQUksTUFBZSxDQUFDO1FBQ3BCLElBQUksaUJBQXNDLENBQUM7UUFDM0MsTUFBTSxTQUFTLEdBQUcsR0FBRyxFQUFFO1lBQ3JCLE1BQU0sT0FBTyxHQUFHLHdCQUFrQixDQUFDLFlBQVksQ0FBQyxDQUFD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
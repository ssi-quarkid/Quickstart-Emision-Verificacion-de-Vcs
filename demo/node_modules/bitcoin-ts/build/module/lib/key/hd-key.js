import { instantiateRipemd160, instantiateSecp256k1, instantiateSha256, instantiateSha512, } from '../crypto/crypto';
import { hmacSha512 } from '../crypto/hmac';
import { base58ToBin, BaseConversionError, bigIntToBinUint256BEClamped, binToBase58, binToBigIntUint256BE, flattenBinArray, numberToBinUint32BE, } from '../format/format';
import { utf8ToBin } from '../format/utf8';
import { validateSecp256k1PrivateKey } from './key-utils';
/**
 * Instantiate an object containing WASM implementations of each cryptographic
 * algorithm required by BIP32 utilities in this library.
 *
 * These WASM implementations provide optimal performance across every
 * JavaScript runtime, but depending on your application, you may prefer to
 * instantiate native implementations such as those provided by Node.js or the
 * `crypto.subtle` API (to reduce bundle size) or an external module (for
 * synchronous instantiation).
 */
export const instantiateBIP32Crypto = async () => {
    const [ripemd160, secp256k1, sha256, sha512] = await Promise.all([
        instantiateRipemd160(),
        instantiateSecp256k1(),
        instantiateSha256(),
        instantiateSha512(),
    ]);
    return { ripemd160, secp256k1, sha256, sha512 };
};
const bip32HmacSha512Key = utf8ToBin('Bitcoin seed');
const halfHmacSha512Length = 32;
/**
 * Derive an `HdPrivateNode` from the provided seed following the BIP32
 * specification. A seed should include between 16 bytes and 64 bytes of
 * entropy (recommended: 32 bytes).
 *
 * @param crypto - an implementation of sha512
 * @param seed - the entropy from which to derive the `HdPrivateNode`
 * @param assumeValidity - if set, the derived private key will not be checked
 * for validity, and will be assumed valid if `true` or invalid if `false` (this
 * is useful for testing)
 */
export const deriveHdPrivateNodeFromSeed = (crypto, seed, assumeValidity) => {
    const mac = hmacSha512(crypto.sha512, bip32HmacSha512Key, seed);
    const privateKey = mac.slice(0, halfHmacSha512Length);
    const chainCode = mac.slice(halfHmacSha512Length);
    const depth = 0;
    const childIndex = 0;
    const parentFingerprint = Uint8Array.from([0, 0, 0, 0]);
    const valid = assumeValidity ?? validateSecp256k1PrivateKey(privateKey);
    return (valid
        ? { chainCode, childIndex, depth, parentFingerprint, privateKey, valid }
        : {
            chainCode,
            childIndex,
            depth,
            invalidPrivateKey: privateKey,
            parentFingerprint,
            valid,
        });
};
/**
 * Derive the public identifier for a given HD private node. This is used to
 * uniquely identify HD nodes in software. The first 4 bytes of this identifier
 * are considered its "fingerprint".
 *
 * @param crypto - implementations of sha256, ripemd160, and secp256k1
 * compressed public key derivation
 * @param hdPrivateNode - the HD private node from which to derive the public
 * identifier (not require to be valid)
 */
export const deriveHdPrivateNodeIdentifier = (crypto, hdPrivateNode) => crypto.ripemd160.hash(crypto.sha256.hash(crypto.secp256k1.derivePublicKeyCompressed(hdPrivateNode.privateKey)));
/**
 * Derive the public identifier for a given `HdPublicNode`. This is used to
 * uniquely identify HD nodes in software. The first 4 bytes of this identifier
 * are considered its fingerprint.
 *
 * @param crypto - implementations of sha256 and ripemd160
 */
export const deriveHdPublicNodeIdentifier = (crypto, node) => crypto.ripemd160.hash(crypto.sha256.hash(node.publicKey));
/**
 * The 4-byte version indicating the network and type of an `HdPrivateKey` or
 * `HdPublicKey`.
 */
export var HdKeyVersion;
(function (HdKeyVersion) {
    /**
     * Version indicating the HD key is an `HdPrivateKey` intended for use on the
     * main network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `xprv`.
     *
     * Hex: `0x0488ade4`
     */
    HdKeyVersion[HdKeyVersion["mainnetPrivateKey"] = 76066276] = "mainnetPrivateKey";
    /**
     * Version indicating the HD key is an `HdPublicKey` intended for use on the
     * main network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `xpub`.
     *
     * Hex: `0x0488b21e`
     */
    HdKeyVersion[HdKeyVersion["mainnetPublicKey"] = 76067358] = "mainnetPublicKey";
    /**
     * Version indicating the HD key is an `HdPrivateKey` intended for use on the
     * test network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `tprv`.
     *
     * Hex: `0x04358394`
     */
    HdKeyVersion[HdKeyVersion["testnetPrivateKey"] = 70615956] = "testnetPrivateKey";
    /**
     * Version indicating the HD key is an `HdPublicKey` intended for use on the
     * test network. Base58 encoding at the expected length of an HD key results
     * in a prefix of `tpub`.
     *
     * Hex: `0x043587cf`
     */
    HdKeyVersion[HdKeyVersion["testnetPublicKey"] = 70617039] = "testnetPublicKey";
})(HdKeyVersion || (HdKeyVersion = {}));
/**
 * An error in the decoding of an HD public or private key.
 */
export var HdKeyDecodingError;
(function (HdKeyDecodingError) {
    HdKeyDecodingError["incorrectLength"] = "HD key decoding error: length is incorrect (must encode 82 bytes).";
    HdKeyDecodingError["invalidChecksum"] = "HD key decoding error: checksum is invalid.";
    HdKeyDecodingError["invalidPrivateNode"] = "HD key decoding error: the key for this HD private node is not a valid Secp256k1 private key.";
    HdKeyDecodingError["missingPrivateKeyPaddingByte"] = "HD key decoding error: version indicates a private key, but the key data is missing a padding byte.";
    HdKeyDecodingError["privateKeyExpected"] = "HD key decoding error: expected an HD private key, but encountered an HD public key.";
    HdKeyDecodingError["publicKeyExpected"] = "HD key decoding error: expected an HD public key, but encountered an HD private key.";
    HdKeyDecodingError["unknownCharacter"] = "HD key decoding error: key includes a non-base58 character.";
    HdKeyDecodingError["unknownVersion"] = "HD key decoding error: key uses an unknown version.";
})(HdKeyDecodingError || (HdKeyDecodingError = {}));
/**
 * Decode an HD private key as defined by BIP32, returning a `node` and a
 * `network`. Decoding errors are returned as strings.
 *
 * If the type of the key is known, use `decodeHdPrivateKey` or
 * `decodeHdPublicKey`.
 *
 * @param crypto - an implementation of sha256
 * @param hdKey - a BIP32 HD private key or HD public key
 */
// eslint-disable-next-line complexity
export const decodeHdKey = (crypto, hdKey) => {
    const decoded = base58ToBin(hdKey);
    if (decoded === BaseConversionError.unknownCharacter)
        return HdKeyDecodingError.unknownCharacter;
    const expectedLength = 82;
    if (decoded.length !== expectedLength)
        return HdKeyDecodingError.incorrectLength;
    const checksumIndex = 78;
    const payload = decoded.slice(0, checksumIndex);
    const checksumBits = decoded.slice(checksumIndex);
    const checksum = crypto.sha256.hash(crypto.sha256.hash(payload));
    if (!checksumBits.every((value, i) => value === checksum[i])) {
        return HdKeyDecodingError.invalidChecksum;
    }
    const depthIndex = 4;
    const fingerprintIndex = 5;
    const childIndexIndex = 9;
    const chainCodeIndex = 13;
    const keyDataIndex = 45;
    const version = new DataView(decoded.buffer, decoded.byteOffset, depthIndex).getUint32(0);
    const depth = decoded[depthIndex];
    const parentFingerprint = decoded.slice(fingerprintIndex, childIndexIndex);
    const childIndex = new DataView(decoded.buffer, decoded.byteOffset + childIndexIndex, decoded.byteOffset + chainCodeIndex).getUint32(0);
    const chainCode = decoded.slice(chainCodeIndex, keyDataIndex);
    const keyData = decoded.slice(keyDataIndex, checksumIndex);
    const isPrivateKey = version === HdKeyVersion.mainnetPrivateKey ||
        version === HdKeyVersion.testnetPrivateKey;
    if (isPrivateKey && keyData[0] !== 0x00) {
        return HdKeyDecodingError.missingPrivateKeyPaddingByte;
    }
    if (isPrivateKey) {
        const privateKey = keyData.slice(1);
        const valid = validateSecp256k1PrivateKey(privateKey);
        return {
            node: valid
                ? {
                    chainCode,
                    childIndex,
                    depth,
                    parentFingerprint,
                    privateKey,
                    valid: true,
                }
                : {
                    chainCode,
                    childIndex,
                    depth,
                    invalidPrivateKey: privateKey,
                    parentFingerprint,
                    valid: false,
                },
            version: version,
        };
    }
    const isPublicKey = version === HdKeyVersion.mainnetPublicKey ||
        version === HdKeyVersion.testnetPublicKey;
    if (!isPublicKey) {
        return HdKeyDecodingError.unknownVersion;
    }
    return {
        node: {
            chainCode,
            childIndex,
            depth,
            parentFingerprint,
            publicKey: keyData,
        },
        version: version,
    };
};
/**
 * Decode an HD private key as defined by BIP32.
 *
 * This method is similar to `decodeHdKey` but ensures that the result is a
 * valid HD private node. Decoding error messages are returned as strings.
 *
 * @param crypto - an implementation of sha256
 * @param hdPrivateKey - a BIP32 HD private key
 */
export const decodeHdPrivateKey = (crypto, hdPrivateKey) => {
    const decoded = decodeHdKey(crypto, hdPrivateKey);
    if (typeof decoded === 'string')
        return decoded;
    if ('publicKey' in decoded.node) {
        return HdKeyDecodingError.privateKeyExpected;
    }
    if (!decoded.node.valid) {
        return HdKeyDecodingError.invalidPrivateNode;
    }
    if (decoded.version === HdKeyVersion.mainnetPrivateKey) {
        return {
            network: 'mainnet',
            node: decoded.node,
        };
    }
    return {
        network: 'testnet',
        node: decoded.node,
    };
};
/**
 * Decode an HD public key as defined by BIP32.
 *
 * This method is similar to `decodeHdKey` but ensures that the result is an
 * HD public node. Decoding error messages are returned as strings.
 *
 * @param crypto - an implementation of sha256
 * @param hdPublicKey - a BIP32 HD public key
 */
export const decodeHdPublicKey = (crypto, hdPublicKey) => {
    const decoded = decodeHdKey(crypto, hdPublicKey);
    if (typeof decoded === 'string')
        return decoded;
    if (decoded.version === HdKeyVersion.mainnetPublicKey) {
        return {
            network: 'mainnet',
            node: decoded.node,
        };
    }
    if (decoded.version === HdKeyVersion.testnetPublicKey) {
        return {
            network: 'testnet',
            node: decoded.node,
        };
    }
    return HdKeyDecodingError.publicKeyExpected;
};
/**
 * Encode an HD private key (as defined by BIP32) given an HD private node.
 *
 * @param crypto - an implementation of sha256
 * @param keyParameters - a valid HD private node and the network for which to
 * encode the key
 */
export const encodeHdPrivateKey = (crypto, keyParameters) => {
    const version = numberToBinUint32BE(keyParameters.network === 'mainnet'
        ? HdKeyVersion.mainnetPrivateKey
        : HdKeyVersion.testnetPrivateKey);
    const depth = Uint8Array.of(keyParameters.node.depth);
    const childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
    const isPrivateKey = Uint8Array.of(0x00);
    const payload = flattenBinArray([
        version,
        depth,
        keyParameters.node.parentFingerprint,
        childIndex,
        keyParameters.node.chainCode,
        isPrivateKey,
        keyParameters.node.privateKey,
    ]);
    const checksumLength = 4;
    const checksum = crypto.sha256
        .hash(crypto.sha256.hash(payload))
        .slice(0, checksumLength);
    return binToBase58(flattenBinArray([payload, checksum]));
};
/**
 * Encode an HD public key (as defined by BIP32) given an HD public node.
 *
 * @param crypto - an implementation of sha256
 * @param keyParameters - an HD public node and the network for which to encode
 * the key
 */
export const encodeHdPublicKey = (crypto, keyParameters) => {
    const version = numberToBinUint32BE(keyParameters.network === 'mainnet'
        ? HdKeyVersion.mainnetPublicKey
        : HdKeyVersion.testnetPublicKey);
    const depth = Uint8Array.of(keyParameters.node.depth);
    const childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
    const payload = flattenBinArray([
        version,
        depth,
        keyParameters.node.parentFingerprint,
        childIndex,
        keyParameters.node.chainCode,
        keyParameters.node.publicKey,
    ]);
    const checksumLength = 4;
    const checksum = crypto.sha256
        .hash(crypto.sha256.hash(payload))
        .slice(0, checksumLength);
    return binToBase58(flattenBinArray([payload, checksum]));
};
/**
 * Derive the HD public node of an HD private node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See `crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode` for
 * details.
 *
 * @param crypto - an implementation of secp256k1 compressed public key
 * derivation (e.g. `instantiateSecp256k1`)
 * @param node - a valid HD private node
 */
export const deriveHdPublicNode = (crypto, node) => {
    return {
        chainCode: node.chainCode,
        childIndex: node.childIndex,
        depth: node.depth,
        parentFingerprint: node.parentFingerprint,
        ...(node.parentIdentifier === undefined
            ? {}
            : { parentIdentifier: node.parentIdentifier }),
        publicKey: crypto.secp256k1.derivePublicKeyCompressed(node.privateKey),
    };
};
/**
 * An error in the derivation of child HD public or private nodes.
 */
export var HdNodeDerivationError;
(function (HdNodeDerivationError) {
    HdNodeDerivationError["childIndexExceedsMaximum"] = "HD key derivation error: child index exceeds maximum (4294967295).";
    HdNodeDerivationError["nextChildIndexRequiresHardenedAlgorithm"] = "HD key derivation error: an incredibly rare HMAC-SHA512 result occurred, and incrementing the child index would require switching to the hardened algorithm.";
    HdNodeDerivationError["hardenedDerivationRequiresPrivateNode"] = "HD key derivation error: derivation for hardened child indexes (indexes greater than or equal to 2147483648) requires an HD private node.";
    HdNodeDerivationError["invalidDerivationPath"] = "HD key derivation error: invalid derivation path \u2013 paths must begin with \"m\" or \"M\" and contain only forward slashes (\"/\"), apostrophes (\"'\"), child index numbers.";
    HdNodeDerivationError["invalidPrivateDerivationPrefix"] = "HD key derivation error: private derivation paths must begin with \"m\".";
    HdNodeDerivationError["invalidPublicDerivationPrefix"] = "HD key derivation error: public derivation paths must begin with \"M\".";
})(HdNodeDerivationError || (HdNodeDerivationError = {}));
/**
 * Derive a child HD private node from an HD private node.
 *
 * To derive a child HD public node, use `deriveHdPublicNode` on the result of
 * this method. If the child uses a non-hardened index, it's also possible to
 * use `deriveHdPublicNodeChild`.
 *
 * @privateRemarks
 * The `Secp256k1.addTweakPrivateKey` method throws if the tweak is out of range
 * or if the resulting private key would be invalid. The procedure to handle
 * this error is standardized by BIP32: return the HD node at the next child
 * index. (Regardless, this scenario is incredibly unlikely without a weakness
 * in HMAC-SHA512.)
 *
 * @param crypto - implementations of sha256, ripemd160, secp256k1 compressed
 * public key derivation, and secp256k1 private key "tweak addition"
 * (application of the EC group operation) – these are available via
 * `instantiateBIP32Crypto`
 * @param node - the valid HD private node from which to derive the child node
 * @param index - the index at which to derive the child node - indexes greater
 * than or equal to the hardened index offset (`0x80000000`/`2147483648`) are
 * derived using the "hardened" derivation algorithm
 */
// eslint-disable-next-line complexity
export const deriveHdPrivateNodeChild = (crypto, node, index) => {
    const maximumIndex = 0xffffffff;
    if (index > maximumIndex) {
        return HdNodeDerivationError.childIndexExceedsMaximum;
    }
    const hardenedIndexOffset = 0x80000000;
    const useHardenedAlgorithm = index >= hardenedIndexOffset;
    const keyMaterial = useHardenedAlgorithm
        ? node.privateKey
        : crypto.secp256k1.derivePublicKeyCompressed(node.privateKey);
    const serialization = Uint8Array.from([
        ...(useHardenedAlgorithm ? [0x00] : []),
        ...keyMaterial,
        ...numberToBinUint32BE(index),
    ]);
    const derivation = hmacSha512(crypto.sha512, node.chainCode, serialization);
    const tweakValueLength = 32;
    const tweakValue = derivation.slice(0, tweakValueLength);
    const nextChainCode = derivation.slice(tweakValueLength);
    // eslint-disable-next-line functional/no-try-statement
    try {
        const nextPrivateKey = crypto.secp256k1.addTweakPrivateKey(node.privateKey, tweakValue);
        const parentIdentifier = deriveHdPrivateNodeIdentifier(crypto, node);
        const parentFingerprintLength = 4;
        return {
            chainCode: nextChainCode,
            childIndex: index,
            depth: node.depth + 1,
            parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
            parentIdentifier,
            privateKey: nextPrivateKey,
            valid: true,
        };
    }
    catch (error) /* istanbul ignore next - testing requires >2^127 brute force */ {
        if (index === hardenedIndexOffset - 1) {
            return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
        }
        return deriveHdPrivateNodeChild(crypto, node, index + 1);
    }
};
/**
 * Derive a non-hardened child HD public node from an HD public node.
 *
 * Because hardened derivation also requires knowledge of the parent private
 * node, it's not possible to use an HD public node to derive a hardened child
 * HD public node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See `crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode` for
 * details.
 *
 * @privateRemarks
 * The `Secp256k1.addTweakPublicKeyCompressed` method throws if the tweak is out
 * of range or if the resulting public key would be invalid. The procedure to
 * handle this error is standardized by BIP32: return the HD node at the next
 * child index. (Regardless, this scenario is incredibly unlikely without a
 * weakness in HMAC-SHA512.)
 *
 * @param crypto - implementations of sha256, sha512, ripemd160, and secp256k1
 * compressed public key "tweak addition" (application of the EC group
 * operation) – these are available via `instantiateBIP32Crypto`
 * @param node - the HD public node from which to derive the child public node
 * @param index - the index at which to derive the child node
 */
export const deriveHdPublicNodeChild = (crypto, node, index) => {
    const hardenedIndexOffset = 0x80000000;
    if (index >= hardenedIndexOffset) {
        return HdNodeDerivationError.hardenedDerivationRequiresPrivateNode;
    }
    const serialization = Uint8Array.from([
        ...node.publicKey,
        ...numberToBinUint32BE(index),
    ]);
    const derivation = hmacSha512(crypto.sha512, node.chainCode, serialization);
    const tweakValueLength = 32;
    const tweakValue = derivation.slice(0, tweakValueLength);
    const nextChainCode = derivation.slice(tweakValueLength);
    // eslint-disable-next-line functional/no-try-statement
    try {
        const nextPublicKey = crypto.secp256k1.addTweakPublicKeyCompressed(node.publicKey, tweakValue);
        const parentIdentifier = deriveHdPublicNodeIdentifier(crypto, node);
        const parentFingerprintLength = 4;
        return {
            chainCode: nextChainCode,
            childIndex: index,
            depth: node.depth + 1,
            parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
            parentIdentifier,
            publicKey: nextPublicKey,
        };
    }
    catch (error) /* istanbul ignore next - testing requires >2^127 brute force */ {
        if (index === hardenedIndexOffset - 1) {
            return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
        }
        return deriveHdPublicNodeChild(crypto, node, index + 1);
    }
};
/**
 * Derive a child HD node from a parent node given a derivation path. The
 * resulting node is the same type as the parent node (private nodes return
 * private nodes, public nodes return public nodes).
 *
 * @remarks
 * The derivation path uses the notation specified in BIP32:
 *
 * The first character must be either `m` for private derivation or `M` for
 * public derivation, followed by sets of `/` and a number representing the
 * child index used in the derivation at that depth. Hardened derivation is
 * represented by a trailing `'`, and may only appear in private derivation
 * paths (hardened derivation requires knowledge of the private key). Hardened
 * child indexes are represented with the hardened index offset (`2147483648`)
 * subtracted.
 *
 * For example, `m/0/1'/2` uses private derivation (`m`), with child indexes in
 * the following order:
 *
 * `derivePrivate(derivePrivate(derivePrivate(node, 0), 2147483648 + 1), 2)`
 *
 * Likewise, `M/3/4/5` uses public derivation (`M`), with child indexes in the
 * following order:
 *
 * `derivePublic(derivePublic(derivePublic(node, 3), 4), 5)`
 *
 * Because hardened derivation requires a private node, paths which specify
 * public derivation (`M`) using hardened derivation (`'`) will return an error.
 * To derive the public node associated with a child private node which requires
 * hardened derivation, begin with private derivation, then provide the result
 * to `deriveHdPublicNode`.
 *
 * @param crypto - implementations of sha256, sha512, ripemd160, and secp256k1
 * derivation functions – these are available via `instantiateBIP32Crypto`
 * @param node - the HD node from which to begin the derivation (for paths
 * beginning with `m`, an `HdPrivateNodeValid`; for paths beginning with `M`, an
 * `HdPublicNode`)
 * @param path - the BIP32 derivation path, e.g. `m/0/1'/2` or `M/3/4/5`
 */
// eslint-disable-next-line complexity
export const deriveHdPath = (crypto, node, path) => {
    const validDerivationPath = /^[mM](?:\/[0-9]+'?)*$/u;
    if (!validDerivationPath.test(path)) {
        return HdNodeDerivationError.invalidDerivationPath;
    }
    const parsed = path.split('/');
    const isPrivateDerivation = 'privateKey' in node;
    if (isPrivateDerivation && parsed[0] !== 'm') {
        return HdNodeDerivationError.invalidPrivateDerivationPrefix;
    }
    if (!isPrivateDerivation && parsed[0] !== 'M') {
        return HdNodeDerivationError.invalidPublicDerivationPrefix;
    }
    const base = 10;
    const hardenedIndexOffset = 0x80000000;
    const indexes = parsed
        .slice(1)
        .map((index) => index.endsWith("'")
        ? parseInt(index.slice(0, -1), base) + hardenedIndexOffset
        : parseInt(index, base));
    return (isPrivateDerivation
        ? indexes.reduce((result, nextIndex) => typeof result === 'string'
            ? result
            : deriveHdPrivateNodeChild(crypto, result, nextIndex), node)
        : indexes.reduce((result, nextIndex) => typeof result === 'string'
            ? result
            : deriveHdPublicNodeChild(crypto, result, nextIndex), node));
};
export var HdNodeCrackingError;
(function (HdNodeCrackingError) {
    HdNodeCrackingError["cannotCrackHardenedDerivation"] = "HD node cracking error: cannot crack an HD parent node using hardened child node.";
})(HdNodeCrackingError || (HdNodeCrackingError = {}));
/**
 * Derive the HD private node from a HD public node, given any non-hardened
 * child private node.
 *
 * @remarks
 * This exploits the "non-hardened" BIP32 derivation algorithm. Because
 * non-hardened derivation only requires knowledge of the "chain code" (rather
 * than requiring knowledge of the parent private key) it's possible to
 * calculate the value by which the parent private key is "tweaked" to arrive at
 * the child private key. Since we have the child private key, we simply
 * subtract this "tweaked" amount to get back to the parent private key.
 *
 * The BIP32 "hardened" derivation algorithm is designed to address this
 * weakness. Using hardened derivation, child private nodes can be shared
 * without risk of leaking the parent private node, but this comes at the cost
 * of public node derivation. Given only a parent public node, it is not
 * possible to derive hardened child public keys, so applications must choose
 * between support for HD public node derivation or support for sharing child
 * private nodes.
 *
 * @param crypto - an implementation of sha512
 * @param parentPublicNode - the parent HD public node for which to derive a
 * private node
 * @param childPrivateNode - any non-hardened child private node of the parent
 * node
 */
export const crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode = (crypto, parentPublicNode, childPrivateNode) => {
    const hardenedIndexOffset = 0x80000000;
    if (childPrivateNode.childIndex >= hardenedIndexOffset) {
        return HdNodeCrackingError.cannotCrackHardenedDerivation;
    }
    const serialization = Uint8Array.from([
        ...parentPublicNode.publicKey,
        ...numberToBinUint32BE(childPrivateNode.childIndex),
    ]);
    const derivation = hmacSha512(crypto.sha512, parentPublicNode.chainCode, serialization);
    const tweakValueLength = 32;
    const tweakValue = binToBigIntUint256BE(derivation.slice(0, tweakValueLength));
    const childPrivateValue = binToBigIntUint256BE(childPrivateNode.privateKey);
    const secp256k1OrderN = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    const trueMod = (n, m) => ((n % m) + m) % m;
    const parentPrivateValue = trueMod(childPrivateValue - tweakValue, secp256k1OrderN);
    const privateKey = bigIntToBinUint256BEClamped(parentPrivateValue);
    return {
        chainCode: parentPublicNode.chainCode,
        childIndex: parentPublicNode.childIndex,
        depth: parentPublicNode.depth,
        parentFingerprint: parentPublicNode.parentFingerprint,
        ...(parentPublicNode.parentIdentifier === undefined
            ? {}
            : { parentIdentifier: parentPublicNode.parentIdentifier }),
        privateKey,
        valid: true,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGQta2V5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9rZXkvaGQta2V5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsb0JBQW9CLEVBQ3BCLGlCQUFpQixFQUNqQixpQkFBaUIsR0FLbEIsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUMsT0FBTyxFQUNMLFdBQVcsRUFDWCxtQkFBbUIsRUFDbkIsMkJBQTJCLEVBQzNCLFdBQVcsRUFDWCxvQkFBb0IsRUFDcEIsZUFBZSxFQUNmLG1CQUFtQixHQUNwQixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzQyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFrSTFEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLEtBQUssSUFBSSxFQUFFO0lBQy9DLE1BQU0sQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUM7UUFDL0Qsb0JBQW9CLEVBQUU7UUFDdEIsb0JBQW9CLEVBQUU7UUFDdEIsaUJBQWlCLEVBQUU7UUFDbkIsaUJBQWlCLEVBQUU7S0FDcEIsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDO0FBQ2xELENBQUMsQ0FBQztBQUVGLE1BQU0sa0JBQWtCLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3JELE1BQU0sb0JBQW9CLEdBQUcsRUFBRSxDQUFDO0FBQ2hDOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFNLENBQUMsTUFBTSwyQkFBMkIsR0FBRyxDQUd6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
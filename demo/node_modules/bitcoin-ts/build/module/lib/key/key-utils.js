/**
 * Verify that a private key is valid for the Secp256k1 curve. Returns `true`
 * for success, or `false` on failure.
 *
 * Private keys are 256-bit numbers encoded as a 32-byte, big-endian Uint8Array.
 * Nearly every 256-bit number is a valid secp256k1 private key. Specifically,
 * any 256-bit number greater than `0x01` and less than
 * `0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140`
 * is a valid private key. This range is part of the definition of the
 * secp256k1 elliptic curve parameters.
 *
 * This method does not require the `Secp256k1` WASM implementation (available
 * via `instantiateSecp256k1`).
 */
export const validateSecp256k1PrivateKey = (privateKey) => {
    const privateKeyLength = 32;
    if (privateKey.length !== privateKeyLength ||
        privateKey.every((value) => value === 0)) {
        return false;
    }
    /**
     * The largest possible Secp256k1 private key â€“ equal to the order of the
     * Secp256k1 curve minus one.
     */
    // prettier-ignore
    const maximumSecp256k1PrivateKey = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 63]; // eslint-disable-line @typescript-eslint/no-magic-numbers
    const firstDifference = privateKey.findIndex((value, i) => value !== maximumSecp256k1PrivateKey[i]);
    if (firstDifference === -1 ||
        privateKey[firstDifference] < maximumSecp256k1PrivateKey[firstDifference]) {
        return true;
    }
    return false;
};
// privateKey.every((value, i) => value <= maximumSecp256k1PrivateKey[i]);
/**
 * Securely generate a valid Secp256k1 private key given a secure source of
 * randomness.
 *
 * **Node.js Usage**
 * ```ts
 * import { randomBytes } from 'crypto';
 * import { generatePrivateKey } from 'bitcoin-ts';
 *
 * const key = generatePrivateKey(secp256k1, () => randomBytes(32));
 * ```
 *
 * **Browser Usage**
 * ```ts
 * import { generatePrivateKey } from 'bitcoin-ts';
 *
 * const key = generatePrivateKey(secp256k1, () =>
 *   window.crypto.getRandomValues(new Uint8Array(32))
 * );
 * ```
 *
 * @param secp256k1 - an implementation of Secp256k1
 * @param secureRandom - a method which returns a securely-random 32-byte
 * Uint8Array
 */
export const generatePrivateKey = (secureRandom) => {
    // eslint-disable-next-line functional/no-let, init-declarations
    let maybeKey;
    // eslint-disable-next-line functional/no-loop-statement
    do {
        // eslint-disable-next-line functional/no-expression-statement
        maybeKey = secureRandom();
    } while (!validateSecp256k1PrivateKey(maybeKey));
    return maybeKey;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5LXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9rZXkva2V5LXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFNLENBQUMsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLFVBQXNCLEVBQUUsRUFBRTtJQUNwRSxNQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztJQUM1QixJQUNFLFVBQVUsQ0FBQyxNQUFNLEtBQUssZ0JBQWdCO1FBQ3RDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsRUFDeEM7UUFDQSxPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQ7OztPQUdHO0lBQ0gsa0JBQWtCO0lBQ2xCLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQywwREFBMEQ7SUFFelAsTUFBTSxlQUFlLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FDMUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssMEJBQTBCLENBQUMsQ0FBQyxDQUFDLENBQ3RELENBQUM7SUFFRixJQUNFLGVBQWUsS0FBSyxDQUFDLENBQUM7UUFDdEIsVUFBVSxDQUFDLGVBQWUsQ0FBQyxHQUFHLDBCQUEwQixDQUFDLGVBQWUsQ0FBQyxFQUN6RTtRQUNBLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMsQ0FBQztBQUVGLDBFQUEwRTtBQUUxRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxZQUE4QixFQUFFLEVBQUU7SUFDbkUsZ0VBQWdFO0lBQ2hFLElBQUksUUFBb0IsQ0FBQztJQUN6Qix3REFBd0Q7SUFDeEQsR0FBRztRQUNELDhEQUE4RDtRQUM5RCxRQUFRLEdBQUcsWUFBWSxFQUFFLENBQUM7S0FDM0IsUUFBUSxDQUFDLDJCQUEyQixDQUFDLFFBQVEsQ0FBQyxFQUFFO0lBQ2pELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyJ9
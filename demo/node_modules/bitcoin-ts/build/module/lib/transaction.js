import { bigIntToBinUint64LE, bigIntToBitcoinVarInt, binToBigIntUint64LE, binToHex, binToNumberUint32LE, flattenBinArray, numberToBinUint32LE, readBitcoinVarInt, } from './format/format';
/**
 * @param bin - the raw transaction from which to read the input
 * @param offset - the offset at which the input begins
 */
export const readTransactionInput = (bin, offset) => {
    const offsetAfterTxHash = offset + 32 /* sha256Hash */;
    const outpointTransactionHash = bin
        .slice(offset, offsetAfterTxHash)
        .reverse();
    const offsetAfterOutpointIndex = offsetAfterTxHash + 4 /* uint32 */;
    const outpointIndex = binToNumberUint32LE(bin.subarray(offsetAfterTxHash, offsetAfterOutpointIndex));
    const { nextOffset: offsetAfterBytecodeLength, value: bytecodeLength, } = readBitcoinVarInt(bin, offsetAfterOutpointIndex);
    const offsetAfterBytecode = offsetAfterBytecodeLength + Number(bytecodeLength);
    const unlockingBytecode = bin.slice(offsetAfterBytecodeLength, offsetAfterBytecode);
    const nextOffset = offsetAfterBytecode + 4 /* uint32 */;
    const sequenceNumber = binToNumberUint32LE(bin.subarray(offsetAfterBytecode, nextOffset));
    return {
        input: {
            outpointIndex,
            outpointTransactionHash,
            sequenceNumber,
            unlockingBytecode,
        },
        nextOffset,
    };
};
/**
 * Serialize a single input.
 * @param output - the input to serialize
 */
export const serializeInput = (input) => flattenBinArray([
    input.outpointTransactionHash.slice().reverse(),
    numberToBinUint32LE(input.outpointIndex),
    bigIntToBitcoinVarInt(BigInt(input.unlockingBytecode.length)),
    input.unlockingBytecode,
    numberToBinUint32LE(input.sequenceNumber),
]);
/**
 * Serialize a set of inputs for inclusion in a serialized transaction.
 *
 * Format: [BitcoinVarInt: input count] [serialized inputs]
 *
 * @param inputs - the set of inputs to serialize
 */
export const serializeInputs = (inputs) => flattenBinArray([
    bigIntToBitcoinVarInt(BigInt(inputs.length)),
    ...inputs.map(serializeInput),
]);
/**
 * @param bin - the raw transaction from which to read the output
 * @param offset - the offset at which the output begins
 */
export const readTransactionOutput = (bin, offset) => {
    const offsetAfterSatoshis = offset + 8 /* uint64 */;
    const satoshis = Number(binToBigIntUint64LE(bin.subarray(offset, offsetAfterSatoshis)));
    const { nextOffset: offsetAfterScriptLength, value } = readBitcoinVarInt(bin, offsetAfterSatoshis);
    const bytecodeLength = Number(value);
    const nextOffset = offsetAfterScriptLength + bytecodeLength;
    const lockingBytecode = bytecodeLength === 0
        ? new Uint8Array()
        : bin.slice(offsetAfterScriptLength, nextOffset);
    return {
        nextOffset,
        output: {
            lockingBytecode,
            satoshis,
        },
    };
};
/**
 * Serialize a single output.
 * @param output - the output to serialize
 */
export const serializeOutput = (output) => flattenBinArray([
    bigIntToBinUint64LE(BigInt(output.satoshis)),
    bigIntToBitcoinVarInt(BigInt(output.lockingBytecode.length)),
    output.lockingBytecode,
]);
/**
 * Serialize a set of outputs for inclusion in a serialized transaction.
 *
 * Format: [BitcoinVarInt: output count] [serialized outputs]
 *
 * @param outputs - the set of outputs to serialize
 */
export const serializeOutputsForTransaction = (outputs) => flattenBinArray([
    bigIntToBitcoinVarInt(BigInt(outputs.length)),
    ...outputs.map(serializeOutput),
]);
/**
 * TODO: document return type (note outpointTransactionHash is little-endian â€“ most UIs display big-endian transaction hashes)
 *
 * Note: this method throws runtime errors when attempting to decode improperly
 * encoded transactions.
 *
 * @param bin - the raw transaction to decode
 */
export const deserializeTransaction = (bin) => {
    const version = binToNumberUint32LE(bin.subarray(0, 4 /* uint32 */));
    const offsetAfterVersion = 4 /* uint32 */;
    const { nextOffset: offsetAfterInputCount, value: inputCount, } = readBitcoinVarInt(bin, offsetAfterVersion);
    // eslint-disable-next-line functional/no-let
    let cursor = offsetAfterInputCount;
    const inputs = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < Number(inputCount); i++) {
        const { input, nextOffset } = readTransactionInput(bin, cursor);
        // eslint-disable-next-line functional/no-expression-statement
        cursor = nextOffset;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        inputs.push(input);
    }
    const { nextOffset: offsetAfterOutputCount, value: outputCount, } = readBitcoinVarInt(bin, cursor);
    // eslint-disable-next-line functional/no-expression-statement
    cursor = offsetAfterOutputCount;
    const outputs = [];
    // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < Number(outputCount); i++) {
        const { output, nextOffset } = readTransactionOutput(bin, cursor);
        // eslint-disable-next-line functional/no-expression-statement
        cursor = nextOffset;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        outputs.push(output);
    }
    const locktime = binToNumberUint32LE(bin.subarray(cursor, cursor + 4 /* uint32 */));
    return {
        inputs,
        locktime,
        outputs,
        version,
    };
};
/**
 * TODO: doc
 */
export const serializeTransaction = (tx) => flattenBinArray([
    numberToBinUint32LE(tx.version),
    serializeInputs(tx.inputs),
    serializeOutputsForTransaction(tx.outputs),
    numberToBinUint32LE(tx.locktime),
]);
/**
 * Derive a standard identifier from a serialized data structure.
 *
 * @remarks
 * By convention, Bitcoin transaction and block identifiers are derived by
 * double-sha256 hashing their serialized form, and reversing the byte order.
 * (The result of sha256 is defined by its specification as big-endian, and
 * bitcoin displays hashes in little-endian format.)
 *
 * @returns an identifier in little-endian byte order
 *
 * @param data - the serialized raw data being identified
 * @param sha256 - an implementation of sha256
 */
export const getBitcoinIdentifier = (data, sha256) => sha256.hash(sha256.hash(data)).reverse();
/**
 * Derive a standard transaction identifier from a serialized transaction.
 *
 * @returns a Transaction ID in little-endian byte order
 *
 * @param transaction - the serialized transaction
 * @param sha256 - an implementation of sha256
 */
export const getBitcoinTransactionId = (transaction, sha256) => binToHex(getBitcoinIdentifier(transaction, sha256));
/**
 * Get the hash of all outpoints in a series of inputs. (For use in
 * `hashTransactionOutpoints`.)
 *
 * @param inputs - the series of inputs from which to extract the outpoints
 * @param sha256 - an implementation of sha256
 */
export const serializeOutpoints = (inputs) => flattenBinArray(inputs.map((i) => flattenBinArray([
    i.outpointTransactionHash.slice().reverse(),
    numberToBinUint32LE(i.outpointIndex),
])));
/**
 * Get the signing serialization for a series of outputs.
 * @param outputs - the series of outputs to serialize
 */
export const serializeOutputsForSigning = (outputs) => flattenBinArray(outputs.map(serializeOutput));
/**
 * Serialize a series of input sequence numbers.
 *
 * @param inputs - the series of inputs from which to extract the sequence numbers
 */
export const serializeSequenceNumbers = (inputs) => flattenBinArray(inputs.map((i) => numberToBinUint32LE(i.sequenceNumber)));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIscUJBQXFCLEVBQ3JCLG1CQUFtQixFQUNuQixRQUFRLEVBQ1IsbUJBQW1CLEVBQ25CLGVBQWUsRUFDZixtQkFBbUIsRUFDbkIsaUJBQWlCLEdBQ2xCLE1BQU0saUJBQWlCLENBQUM7QUFrSHpCOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHLENBQUMsR0FBZSxFQUFFLE1BQWMsRUFBRSxFQUFFO0lBQ3RFLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxzQkFBd0IsQ0FBQztJQUN6RCxNQUFNLHVCQUF1QixHQUFHLEdBQUc7U0FDaEMsS0FBSyxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQztTQUNoQyxPQUFPLEVBQUUsQ0FBQztJQUNiLE1BQU0sd0JBQXdCLEdBQUcsaUJBQWlCLGlCQUFvQixDQUFDO0lBQ3ZFLE1BQU0sYUFBYSxHQUFHLG1CQUFtQixDQUN2QyxHQUFHLENBQUMsUUFBUSxDQUFDLGlCQUFpQixFQUFFLHdCQUF3QixDQUFDLENBQzFELENBQUM7SUFDRixNQUFNLEVBQ0osVUFBVSxFQUFFLHlCQUF5QixFQUNyQyxLQUFLLEVBQUUsY0FBYyxHQUN0QixHQUFHLGlCQUFpQixDQUFDLEdBQUcsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO0lBQ3JELE1BQU0sbUJBQW1CLEdBQ3ZCLHlCQUF5QixHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNyRCxNQUFNLGlCQUFpQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQ2pDLHlCQUF5QixFQUN6QixtQkFBbUIsQ0FDcEIsQ0FBQztJQUNGLE1BQU0sVUFBVSxHQUFHLG1CQUFtQixpQkFBb0IsQ0FBQztJQUMzRCxNQUFNLGNBQWMsR0FBRyxtQkFBbUIsQ0FDeEMsR0FB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
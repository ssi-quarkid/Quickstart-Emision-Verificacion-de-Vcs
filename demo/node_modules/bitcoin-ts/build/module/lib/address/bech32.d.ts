/**
 * The list of 32 symbols used in Bech32 encoding.
 */
export declare const bech32CharacterSet = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
export declare const bech32CharacterSetIndex: {
    readonly q: 0;
    readonly p: 1;
    readonly z: 2;
    readonly r: 3;
    readonly y: 4;
    readonly 9: 5;
    readonly x: 6;
    readonly 8: 7;
    readonly g: 8;
    readonly f: 9;
    readonly 2: 10;
    readonly t: 11;
    readonly v: 12;
    readonly d: 13;
    readonly w: 14;
    readonly 0: 15;
    readonly s: 16;
    readonly 3: 17;
    readonly j: 18;
    readonly n: 19;
    readonly 5: 20;
    readonly 4: 21;
    readonly k: 22;
    readonly h: 23;
    readonly c: 24;
    readonly e: 25;
    readonly 6: 26;
    readonly m: 27;
    readonly u: 28;
    readonly a: 29;
    readonly 7: 30;
    readonly l: 31;
};
export declare enum BitRegroupingError {
    integerOutOfRange = "An integer provided in the source array is out of the range of the specified source word length.",
    hasDisallowedPadding = "Encountered padding when padding was disallowed.",
    requiresDisallowedPadding = "Encoding requires padding while padding is disallowed."
}
/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 *
 * @privateRemarks
 * Derived from: https://github.com/sipa/bech32
 * Copyright (c) 2017 Pieter Wuille, MIT License
 */
export declare const regroupBits: ({ bin, sourceWordLength, resultWordLength, padding, }: {
    bin: readonly number[] | (Readonly<ArrayLike<number>> & Iterable<number> & {
        readonly [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
            readonly byteLength: number;
            readonly slice: (begin: number, end?: number | undefined) => ArrayBuffer;
        } | {
            readonly byteLength: number;
            readonly length: number;
            readonly slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        readonly copyWithin: (target: number, start: number, end?: number | undefined) => Uint8Array;
        readonly every: (callbackfn: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
        readonly fill: (value: number, start?: number | undefined, end?: number | undefined) => Uint8Array;
        readonly filter: (callbackfn: (value: number, index: number, array: Uint8Array) => any, thisArg?: any) => Uint8Array;
        readonly find: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number | undefined;
        readonly findIndex: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number;
        readonly forEach: (callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any) => void;
        readonly indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
        readonly join: (separator?: string | undefined) => string;
        readonly lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
        readonly length: number;
        readonly map: (callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any) => Uint8Array;
        readonly reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;
        };
        readonly reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Uint8Array) => U_1, initialValue: U_1): U_1;
        };
        readonly reverse: () => Uint8Array;
        readonly set: (array: ArrayLike<number>, offset?: number | undefined) => void;
        readonly slice: (start?: number | undefined, end?: number | undefined) => Uint8Array;
        readonly some: (callbackfn: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
        readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array;
        readonly subarray: (begin?: number | undefined, end?: number | undefined) => Uint8Array;
        readonly toLocaleString: () => string;
        readonly toString: () => string;
        readonly entries: () => IterableIterator<[number, number]>;
        readonly keys: () => IterableIterator<number>;
        readonly values: () => IterableIterator<number>;
        readonly includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
    });
    sourceWordLength: number;
    resultWordLength: number;
    padding?: boolean | undefined;
}) => number[] | BitRegroupingError;
/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`.
 *
 * @param base32IntegerArray - the array of 5-bit integers to encode
 */
export declare const encodeBech32: (base32IntegerArray: readonly number[]) => string;
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with `isBech32` before calling this method.
 *
 * @param validBech32 - the bech32-encoded string to decode
 */
export declare const decodeBech32: (validBech32: string) => (0 | 1 | 2 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 16 | 15 | 18 | 12 | 31 | 20 | 11 | 13 | 14 | 17 | 19 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30)[];
/**
 * Validate that a string is bech32 encoded (without a checksum). The string
 * must use only the bech32 character set, and it must be padded correctly, i.e.
 * it must encode a multiple of 8 bits.
 *
 * @param maybeBech32 - a string to test for valid Bech32 encoding
 */
export declare const isBech32: (maybeBech32: string) => boolean;
export declare enum Bech32DecodingError {
    notBech32Padded = "Bech32 decoding error: input is not in Bech32 padded format."
}
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * This method is the reverse of `binToBech32Padded`.
 *
 * @param bech32Padded - the padded bech32-encoded string to decode
 */
export declare const bech32PaddedToBin: (bech32Padded: string) => Uint8Array | BitRegroupingError | Bech32DecodingError.notBech32Padded;
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * This method is the reverse of `bech32PaddedToBin`.
 *
 * @param bytes - the Uint8Array to bech32 encode
 */
export declare const binToBech32Padded: (bytes: Readonly<ArrayLike<number>> & Iterable<number> & {
    readonly [x: number]: number;
    readonly BYTES_PER_ELEMENT: number;
    readonly buffer: {
        readonly byteLength: number;
        readonly slice: (begin: number, end?: number | undefined) => ArrayBuffer;
    } | {
        readonly byteLength: number;
        readonly length: number;
        readonly slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
    };
    readonly byteLength: number;
    readonly byteOffset: number;
    readonly copyWithin: (target: number, start: number, end?: number | undefined) => Uint8Array;
    readonly every: (callbackfn: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
    readonly fill: (value: number, start?: number | undefined, end?: number | undefined) => Uint8Array;
    readonly filter: (callbackfn: (value: number, index: number, array: Uint8Array) => any, thisArg?: any) => Uint8Array;
    readonly find: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number | undefined;
    readonly findIndex: (predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any) => number;
    readonly forEach: (callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any) => void;
    readonly indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
    readonly join: (separator?: string | undefined) => string;
    readonly lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
    readonly length: number;
    readonly map: (callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any) => Uint8Array;
    readonly reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;
    };
    readonly reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;
        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Uint8Array) => U_1, initialValue: U_1): U_1;
    };
    readonly reverse: () => Uint8Array;
    readonly set: (array: ArrayLike<number>, offset?: number | undefined) => void;
    readonly slice: (start?: number | undefined, end?: number | undefined) => Uint8Array;
    readonly some: (callbackfn: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any) => boolean;
    readonly sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array;
    readonly subarray: (begin?: number | undefined, end?: number | undefined) => Uint8Array;
    readonly toLocaleString: () => string;
    readonly toString: () => string;
    readonly entries: () => IterableIterator<[number, number]>;
    readonly keys: () => IterableIterator<number>;
    readonly values: () => IterableIterator<number>;
    readonly includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
}) => string;
//# sourceMappingURL=bech32.d.ts.map
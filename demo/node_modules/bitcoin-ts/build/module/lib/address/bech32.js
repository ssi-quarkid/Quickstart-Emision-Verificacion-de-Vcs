/**
 * The list of 32 symbols used in Bech32 encoding.
 */
// cspell: disable-next-line
export const bech32CharacterSet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
// prettier-ignore
export const bech32CharacterSetIndex = { q: 0, p: 1, z: 2, r: 3, y: 4, '9': 5, x: 6, '8': 7, g: 8, f: 9, '2': 10, t: 11, v: 12, d: 13, w: 14, '0': 15, s: 16, '3': 17, j: 18, n: 19, '5': 20, '4': 21, k: 22, h: 23, c: 24, e: 25, '6': 26, m: 27, u: 28, a: 29, '7': 30, l: 31 }; // eslint-disable-line sort-keys
export var BitRegroupingError;
(function (BitRegroupingError) {
    BitRegroupingError["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
    BitRegroupingError["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
    BitRegroupingError["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError || (BitRegroupingError = {}));
/* eslint-disable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
// cSpell:ignore Pieter, Wuille
/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 *
 * @privateRemarks
 * Derived from: https://github.com/sipa/bech32
 * Copyright (c) 2017 Pieter Wuille, MIT License
 */
export const regroupBits = ({ bin, sourceWordLength, resultWordLength, padding = true, }) => {
    let accumulator = 0;
    let bits = 0;
    const result = [];
    const maxResultInt = (1 << resultWordLength) - 1;
    // eslint-disable-next-line functional/no-loop-statement, @typescript-eslint/prefer-for-of, no-plusplus
    for (let p = 0; p < bin.length; ++p) {
        const value = bin[p];
        if (value < 0 || value >> sourceWordLength !== 0) {
            return BitRegroupingError.integerOutOfRange;
        }
        accumulator = (accumulator << sourceWordLength) | value;
        bits += sourceWordLength;
        // eslint-disable-next-line functional/no-loop-statement
        while (bits >= resultWordLength) {
            bits -= resultWordLength;
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator >> bits) & maxResultInt);
        }
    }
    if (padding) {
        if (bits > 0) {
            // eslint-disable-next-line functional/immutable-data
            result.push((accumulator << (resultWordLength - bits)) & maxResultInt);
        }
    }
    else if (bits >= sourceWordLength) {
        return BitRegroupingError.hasDisallowedPadding;
    }
    else if (((accumulator << (resultWordLength - bits)) & maxResultInt) >
        0) {
        return BitRegroupingError.requiresDisallowedPadding;
    }
    return result;
};
/* eslint-enable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`.
 *
 * @param base32IntegerArray - the array of 5-bit integers to encode
 */
export const encodeBech32 = (base32IntegerArray) => {
    // eslint-disable-next-line functional/no-let
    let result = '';
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < base32IntegerArray.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement
        result += bech32CharacterSet[base32IntegerArray[i]];
    }
    return result;
};
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with `isBech32` before calling this method.
 *
 * @param validBech32 - the bech32-encoded string to decode
 */
export const decodeBech32 = (validBech32) => {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
    for (let i = 0; i < validBech32.length; i++) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        result.push(bech32CharacterSetIndex[validBech32[i]]);
    }
    return result;
};
const nonBech32Characters = new RegExp(`[^${bech32CharacterSet}]`, 'u');
const base32WordLength = 5;
const base256WordLength = 8;
const zero = 0;
/**
 * Validate that a string is bech32 encoded (without a checksum). The string
 * must use only the bech32 character set, and it must be padded correctly, i.e.
 * it must encode a multiple of 8 bits.
 *
 * @param maybeBech32 - a string to test for valid Bech32 encoding
 */
export const isBech32 = (maybeBech32) => {
    const expectedPadding = (maybeBech32.length * base32WordLength) % base256WordLength;
    const last5Bits = bech32CharacterSetIndex[maybeBech32[maybeBech32.length]];
    const onlyBech32Characters = !nonBech32Characters.test(maybeBech32);
    const noExcessivePadding = expectedPadding < base32WordLength;
    // eslint-disable-next-line no-bitwise
    const mask = (1 << expectedPadding) - 1;
    // eslint-disable-next-line no-bitwise
    const expectedPaddingIsZeroFilled = (Number(last5Bits) & mask) === zero;
    return (onlyBech32Characters && noExcessivePadding && expectedPaddingIsZeroFilled);
};
export var Bech32DecodingError;
(function (Bech32DecodingError) {
    Bech32DecodingError["notBech32Padded"] = "Bech32 decoding error: input is not in Bech32 padded format.";
})(Bech32DecodingError || (Bech32DecodingError = {}));
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * This method is the reverse of `binToBech32Padded`.
 *
 * @param bech32Padded - the padded bech32-encoded string to decode
 */
export const bech32PaddedToBin = (bech32Padded) => {
    const result = isBech32(bech32Padded)
        ? regroupBits({
            bin: decodeBech32(bech32Padded),
            padding: false,
            resultWordLength: base256WordLength,
            sourceWordLength: base32WordLength,
        })
        : Bech32DecodingError.notBech32Padded;
    return typeof result === 'string' ? result : Uint8Array.from(result);
};
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * This method is the reverse of `bech32PaddedToBin`.
 *
 * @param bytes - the Uint8Array to bech32 encode
 */
export const binToBech32Padded = (bytes) => encodeBech32(regroupBits({
    bin: bytes,
    resultWordLength: base32WordLength,
    sourceWordLength: base256WordLength,
}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVjaDMyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9hZGRyZXNzL2JlY2gzMi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQTs7R0FFRztBQUNILDRCQUE0QjtBQUM1QixNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxrQ0FBa0MsQ0FBQztBQUVyRTs7R0FFRztBQUNILGtCQUFrQjtBQUNsQixNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBVyxDQUFDLENB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
import { OpcodesCommon } from '../auth/instruction-sets/common/opcodes';
import { Base58AddressFormatVersion, decodeBase58Address, encodeBase58AddressFormat, } from './base58-address';
import { CashAddressType, decodeCashAddress, encodeCashAddress, } from './cash-address';
/**
 * The most common address types used on bitcoin and bitcoin-like networks. Each
 * address type represents a commonly used locking bytecode pattern.
 *
 * @remarks
 * Addresses are strings which encode information about the network and
 * `lockingBytecode` to which a transaction output can pay.
 *
 * Several address formats exist â€“ `Base58Address` was the format used by the
 * original satoshi client, and is still in use on several active chains (see
 * `encodeBase58Address`). On Bitcoin Cash, the `CashAddress` standard is most
 * common (See `encodeCashAddress`).
 */
export var AddressType;
(function (AddressType) {
    /**
     * Pay to Public Key (P2PK). This address type is uncommon, and primarily
     * occurs in early blocks because the original satoshi implementation mined
     * rewards to P2PK addresses.
     *
     * There are no standardized address formats for representing a P2PK address.
     * Instead, most applications use the `AddressType.p2pkh` format.
     */
    AddressType["p2pk"] = "P2PK";
    /**
     * Pay to Public Key Hash (P2PKH). The most common address type. P2PKH
     * addresses lock funds using a single private key.
     */
    AddressType["p2pkh"] = "P2PKH";
    /**
     * Pay to Script Hash (P2SH). An address type which locks funds to the hash of
     * a script provided in the spending transaction. See BIP13 for details.
     */
    AddressType["p2sh"] = "P2SH";
    /**
     * This `AddressType` represents an address using an unknown or uncommon
     * locking bytecode pattern for which no standardized address formats exist.
     */
    AddressType["unknown"] = "unknown";
})(AddressType || (AddressType = {}));
/**
 * Attempt to match a lockingBytecode to a standard address type for use in
 * address encoding. (See `AddressType` for details.)
 *
 * For a locking bytecode matching the Pay to Public Key Hash (P2PKH) pattern,
 * the returned `type` is `AddressType.p2pkh` and `payload` is the `HASH160` of
 * the public key.
 *
 * For a locking bytecode matching the Pay to Script Hash (P2SH) pattern, the
 * returned `type` is `AddressType.p2sh` and `payload` is the `HASH160` of the
 * redeeming bytecode, A.K.A. "redeem script hash".
 *
 * For a locking bytecode matching the Pay to Public Key (P2PK) pattern, the
 * returned `type` is `AddressType.p2pk` and `payload` is the full public key.
 *
 * Any other locking bytecode will return a `type` of `AddressType.unknown` and
 * a payload of the unmodified `bytecode`.
 *
 * @param bytecode - the locking bytecode to match
 */
// eslint-disable-next-line complexity
export const lockingBytecodeToAddressContents = (bytecode) => {
    const p2pkhLength = 25;
    if (bytecode.length === p2pkhLength &&
        bytecode[0] === OpcodesCommon.OP_DUP &&
        bytecode[1] === OpcodesCommon.OP_HASH160 &&
        bytecode[2] === OpcodesCommon.OP_PUSHBYTES_20 &&
        bytecode[23] === OpcodesCommon.OP_EQUALVERIFY &&
        bytecode[24] === OpcodesCommon.OP_CHECKSIG) {
        const start = 3;
        const end = 23;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pkh };
    }
    const p2shLength = 23;
    if (bytecode.length === p2shLength &&
        bytecode[0] === OpcodesCommon.OP_HASH160 &&
        bytecode[1] === OpcodesCommon.OP_PUSHBYTES_20 &&
        bytecode[22] === OpcodesCommon.OP_EQUAL) {
        const start = 2;
        const end = 22;
        return { payload: bytecode.slice(start, end), type: AddressType.p2sh };
    }
    const p2pkUncompressedLength = 67;
    if (bytecode.length === p2pkUncompressedLength &&
        bytecode[0] === OpcodesCommon.OP_PUSHBYTES_65 &&
        bytecode[66] === OpcodesCommon.OP_CHECKSIG) {
        const start = 1;
        const end = 66;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pk };
    }
    const p2pkCompressedLength = 35;
    if (bytecode.length === p2pkCompressedLength &&
        bytecode[0] === OpcodesCommon.OP_PUSHBYTES_33 &&
        bytecode[34] === OpcodesCommon.OP_CHECKSIG) {
        const start = 1;
        const end = 34;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pk };
    }
    return {
        payload: bytecode.slice(),
        type: AddressType.unknown,
    };
};
/**
 * Get the locking bytecode for a valid `AddressContents` object. See
 * `lockingBytecodeToAddressContents` for details.
 *
 * For `AddressContents` of `type` `AddressType.unknown`, this method returns
 * the `payload` without modification.
 *
 * @param addressContents - the `AddressContents` to encode
 */
export const addressContentsToLockingBytecode = (addressContents) => {
    if (addressContents.type === AddressType.p2pkh) {
        return Uint8Array.from([
            OpcodesCommon.OP_DUP,
            OpcodesCommon.OP_HASH160,
            OpcodesCommon.OP_PUSHBYTES_20,
            ...addressContents.payload,
            OpcodesCommon.OP_EQUALVERIFY,
            OpcodesCommon.OP_CHECKSIG,
        ]);
    }
    if (addressContents.type === AddressType.p2sh) {
        return Uint8Array.from([
            OpcodesCommon.OP_HASH160,
            OpcodesCommon.OP_PUSHBYTES_20,
            ...addressContents.payload,
            OpcodesCommon.OP_EQUAL,
        ]);
    }
    if (addressContents.type === AddressType.p2pk) {
        const compressedPublicKeyLength = 33;
        return addressContents.payload.length === compressedPublicKeyLength
            ? Uint8Array.from([
                OpcodesCommon.OP_PUSHBYTES_33,
                ...addressContents.payload,
                OpcodesCommon.OP_CHECKSIG,
            ])
            : Uint8Array.from([
                OpcodesCommon.OP_PUSHBYTES_65,
                ...addressContents.payload,
                OpcodesCommon.OP_CHECKSIG,
            ]);
    }
    return addressContents.payload;
};
/**
 * Encode a locking bytecode as a CashAddress given a network prefix.
 *
 * If `bytecode` matches either the P2PKH or P2SH pattern, it is encoded using
 * the proper address type and returned as a valid CashAddress (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting `AddressContents` is returned.
 *
 * @param bytecode - the locking bytecode to encode
 * @param prefix - the network prefix to use, e.g. `bitcoincash`, `bchtest`, or
 * `bchreg`
 */
export const lockingBytecodeToCashAddress = (bytecode, prefix) => {
    const contents = lockingBytecodeToAddressContents(bytecode);
    if (contents.type === AddressType.p2pkh) {
        return encodeCashAddress(prefix, CashAddressType.P2PKH, contents.payload);
    }
    if (contents.type === AddressType.p2sh) {
        return encodeCashAddress(prefix, CashAddressType.P2SH, contents.payload);
    }
    return contents;
};
export var LockingBytecodeEncodingError;
(function (LockingBytecodeEncodingError) {
    LockingBytecodeEncodingError["unknownCashAddressType"] = "This CashAddress uses an unknown address type.";
})(LockingBytecodeEncodingError || (LockingBytecodeEncodingError = {}));
/**
 * Convert a CashAddress to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network prefix. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
export const cashAddressToLockingBytecode = (address) => {
    const decoded = decodeCashAddress(address);
    if (typeof decoded === 'string')
        return decoded;
    if (decoded.type === CashAddressType.P2PKH) {
        return {
            bytecode: addressContentsToLockingBytecode({
                payload: decoded.hash,
                type: AddressType.p2pkh,
            }),
            prefix: decoded.prefix,
        };
    }
    if (decoded.type === CashAddressType.P2SH) {
        return {
            bytecode: addressContentsToLockingBytecode({
                payload: decoded.hash,
                type: AddressType.p2sh,
            }),
            prefix: decoded.prefix,
        };
    }
    return LockingBytecodeEncodingError.unknownCashAddressType;
};
/**
 * Encode a locking bytecode as a Base58Address for a given network.
 *
 * If `bytecode` matches either the P2PKH or P2SH pattern, it is encoded using
 * the proper address type and returned as a valid Base58Address (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting `AddressContents` is returned.
 *
 * @param sha256 - an implementation of sha256 (a universal implementation is
 * available via `instantiateSha256`)
 * @param bytecode - the locking bytecode to encode
 * @param network - the network for which to encode the address (`mainnet` or
 * `testnet`)
 */
export const lockingBytecodeToBase58Address = (sha256, bytecode, network) => {
    const contents = lockingBytecodeToAddressContents(bytecode);
    if (contents.type === AddressType.p2pkh) {
        return encodeBase58AddressFormat(sha256, {
            'copay-bch': Base58AddressFormatVersion.p2pkhCopayBCH,
            mainnet: Base58AddressFormatVersion.p2pkh,
            testnet: Base58AddressFormatVersion.p2pkhTestnet,
        }[network], contents.payload);
    }
    if (contents.type === AddressType.p2sh) {
        return encodeBase58AddressFormat(sha256, {
            'copay-bch': Base58AddressFormatVersion.p2shCopayBCH,
            mainnet: Base58AddressFormatVersion.p2sh,
            testnet: Base58AddressFormatVersion.p2shTestnet,
        }[network], contents.payload);
    }
    return contents;
};
/**
 * Convert a Base58Address to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network version. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
export const base58AddressToLockingBytecode = (sha256, address) => {
    const decoded = decodeBase58Address(sha256, address);
    if (typeof decoded === 'string')
        return decoded;
    return {
        bytecode: addressContentsToLockingBytecode({
            payload: decoded.payload,
            type: [
                Base58AddressFormatVersion.p2pkh,
                Base58AddressFormatVersion.p2pkhCopayBCH,
                Base58AddressFormatVersion.p2pkhTestnet,
            ].includes(decoded.version)
                ? AddressType.p2pkh
                : AddressType.p2sh,
        }),
        version: decoded.version,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ja2luZy1ieXRlY29kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvYWRkcmVzcy9sb2NraW5nLWJ5dGVjb2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUd4RSxPQUFPLEVBQ0wsMEJBQTBCLEVBRTFCLG1CQUFtQixFQUNuQix5QkFBeUIsR0FDMUIsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBRUwsZUFBZSxFQUNmLGlCQUFpQixFQUNqQixpQkFBaUIsR0FDbEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4Qjs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFNLENBQU4sSUFBWSxXQXlCWDtBQXpCRCxXQUFZLFdBQVc7SUFDckI7Ozs7Ozs7T0FPRztJQUNILDRCQUFhLENBQUE7SUFDYjs7O09BR0c7SUFDSCw4QkFBZSxDQUFBO0lBQ2Y7OztPQUdHO0lBQ0gsNEJBQWEsQ0FBQTtJQUNiOzs7T0FHRztJQUNILGtDQUFtQixDQUFBO0FBQ3JCLENBQUMsRUF6QlcsV0FBVyxLQUFYLFdBQVcsUUF5QnRCO0FBYUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxzQ0FBc0M7QUFDdEMsTUFBTSxDQUFDLE1BQU0sZ0NBQWdDLEdBQUcsQ0FDOUMsUUFBb0IsRUFDSCxFQUFFO0lBQ25CLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztJQUN2QixJQUNFLFFBQVEsQ0FBQyxNQUFNLEtBQUssV0FBVztRQUMvQixRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssYUFBYSxDQUFDLE1BQU07UUFDcEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLGFBQWEsQ0FBQyxVQUFVO1FBQ3hDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxhQUFhLENBQUMsZUFBZTtRQUM3QyxRQUFRLENBQUMsRUFBRSxDQUFDLEtBQUssYUFBYSxDQUFDLGNBQWM7UUFDN0Ms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
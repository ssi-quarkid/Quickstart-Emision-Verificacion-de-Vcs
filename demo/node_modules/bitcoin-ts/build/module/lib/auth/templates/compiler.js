import { instantiateSecp256k1, instantiateSha256, } from '../../crypto/crypto';
import { bigIntToBinUint64LE, bigIntToBitcoinVarInt, numberToBinUint32LE, } from '../../format/format';
import { generateSigningSerializationBCH, SigningSerializationFlag, } from '../instruction-sets/common/signing-serialization';
import { createAuthenticationProgramExternalStateCommonEmpty, createAuthenticationProgramStateCommon, generateBytecodeMap, instantiateVirtualMachineBCH, instructionSetBCHCurrentStrict, OpcodesBCH, } from '../instruction-sets/instruction-sets';
import { compileScript, } from './language/compile';
import { resolveScriptIdentifier, } from './language/resolve';
/* eslint-disable camelcase */
export var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs"] = "all_outputs";
    /**
     * A.K.A. `SIGHASH_ALL|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["all_outputs_single_input"] = "all_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output"] = "corresponding_output";
    /**
     * A.K.A. `SIGHASH_SINGLE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["corresponding_output_single_input"] = "corresponding_output_single_input";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs"] = "no_outputs";
    /**
     * A.K.A `SIGHASH_NONE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["no_outputs_single_input"] = "no_outputs_single_input";
})(SigningSerializationAlgorithmIdentifier || (SigningSerializationAlgorithmIdentifier = {}));
var ScriptGenerationError;
(function (ScriptGenerationError) {
    ScriptGenerationError["missingVm"] = "An evaluation is required, but no VM was provided.";
    ScriptGenerationError["missingSha256"] = "Sha256 is required, but no implementation was provided.";
    ScriptGenerationError["missingSecp256k1"] = "Secp256k1 is required, but no implementation was provided.";
})(ScriptGenerationError || (ScriptGenerationError = {}));
// eslint-disable-next-line complexity
const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
    switch (algorithmIdentifier) {
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.all_outputs | SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.all_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.all_outputs |
                SigningSerializationFlag.single_input |
                SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.corresponding_output |
                SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.corresponding_output_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.corresponding_output |
                SigningSerializationFlag.single_input |
                SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.no_outputs | SigningSerializationFlag.fork_id);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.no_outputs_single_input}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            SigningSerializationFlag.no_outputs |
                SigningSerializationFlag.single_input |
                SigningSerializationFlag.fork_id);
        default:
            return undefined;
    }
};
var SignatureIdentifierConstants;
(function (SignatureIdentifierConstants) {
    SignatureIdentifierConstants[SignatureIdentifierConstants["variableIdIndex"] = 0] = "variableIdIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["signingTargetIndex"] = 2] = "signingTargetIndex";
    SignatureIdentifierConstants[SignatureIdentifierConstants["expectedSegments"] = 3] = "expectedSegments";
})(SignatureIdentifierConstants || (SignatureIdentifierConstants = {}));
export const compilerOperationBCHGenerateSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid signature identifier. Signatures must be of the form: "[variable_id].${name}.[signing_serialization_type]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const algorithm = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingSerializationType = getSigningSerializationType(algorithm);
    if (signingSerializationType === undefined) {
        return `Unknown signing serialization algorithm, "${algorithm}".`;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { operationData } = data;
        if (operationData === undefined) {
            return `Could not construct the signature "${identifier}", signing serialization data was not provided in the compilation data.`;
        }
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const serialization = generateSigningSerializationBCH({
            correspondingOutput: operationData.correspondingOutput,
            coveredBytecode: operationData.coveredBytecode,
            locktime: operationData.locktime,
            outpointIndex: operationData.outpointIndex,
            outpointTransactionHash: operationData.outpointTransactionHash,
            outputValue: operationData.outputValue,
            sequenceNumber: operationData.sequenceNumber,
            sha256,
            signingSerializationType,
            transactionOutpoints: operationData.transactionOutpoints,
            transactionOutputs: operationData.transactionOutputs,
            transactionSequenceNumbers: operationData.transactionSequenceNumbers,
            version: operationData.version,
        });
        const digest = sha256.hash(sha256.hash(serialization));
        const bitcoinEncodedSignature = Uint8Array.from([
            ...signingAlgorithm(secp256k1)(privateKey, digest),
            ...signingSerializationType,
        ]);
        return bitcoinEncodedSignature;
    }
    return `Identifier "${identifier}" refers to a signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
export const compilerOperationBCHGenerateDataSignature = (name, signingAlgorithm
// eslint-disable-next-line complexity
) => (identifier, data, environment) => {
    const { keys } = data;
    const { signatures, privateKeys } = keys;
    if (signatures !== undefined &&
        signatures[identifier] !== undefined) {
        return signatures[identifier];
    }
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !== SignatureIdentifierConstants.expectedSegments) {
        return `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${name}.[target_script_id]".`;
    }
    const variableId = identifierSegments[SignatureIdentifierConstants.variableIdIndex];
    const scriptId = identifierSegments[SignatureIdentifierConstants.signingTargetIndex];
    const signingTarget = environment.scripts[scriptId];
    const compiledTarget = resolveScriptIdentifier({
        data,
        environment,
        identifier: scriptId,
    });
    if (signingTarget === undefined || compiledTarget === false) {
        return `Data signature tried to sign an unknown target script, "${scriptId}".`;
    }
    if (typeof compiledTarget === 'string') {
        return compiledTarget;
    }
    if (privateKeys !== undefined &&
        privateKeys[variableId] !== undefined) {
        const privateKey = privateKeys[variableId];
        const { secp256k1 } = environment;
        if (secp256k1 === undefined) {
            return ScriptGenerationError.missingSecp256k1;
        }
        const { sha256 } = environment;
        if (sha256 === undefined) {
            return ScriptGenerationError.missingSha256;
        }
        const digest = sha256.hash(compiledTarget.bytecode);
        return signingAlgorithm(secp256k1)(privateKey, digest);
    }
    return `Identifier "${identifier}" refers to a data signature, but no signatures or private keys for "${variableId}" were provided in the compilation data.`;
};
var SigningSerializationIdentifierConstants;
(function (SigningSerializationIdentifierConstants) {
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["operationIndex"] = 1] = "operationIndex";
    SigningSerializationIdentifierConstants[SigningSerializationIdentifierConstants["expectedSegments"] = 2] = "expectedSegments";
})(SigningSerializationIdentifierConstants || (SigningSerializationIdentifierConstants = {}));
// eslint-disable-next-line complexity
export const compilerOperationBCHGenerateSigningSerialization = (identifier, data, environment) => {
    const identifierSegments = identifier.split('.');
    if (identifierSegments.length !==
        SigningSerializationIdentifierConstants.expectedSegments) {
        return `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version" or "signing_serialization.all_outputs".`;
    }
    const algorithmOrComponent = identifierSegments[SigningSerializationIdentifierConstants.operationIndex];
    const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
    const { operationData } = data;
    if (operationData === undefined) {
        return `Could not construct the signing serialization "${identifier}", signing serialization data was not provided in the compilation data.`;
    }
    const { sha256 } = environment;
    if (sha256 === undefined) {
        return ScriptGenerationError.missingSha256;
    }
    // eslint-disable-next-line functional/no-conditional-statement
    if (signingSerializationType === undefined) {
        switch (algorithmOrComponent) {
            case 'corresponding_output':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : operationData.correspondingOutput;
            case 'corresponding_output_hash':
                return operationData.correspondingOutput === undefined
                    ? Uint8Array.of()
                    : sha256.hash(sha256.hash(operationData.correspondingOutput));
            case 'covered_bytecode_length':
                return bigIntToBitcoinVarInt(BigInt(operationData.coveredBytecode.length));
            case 'covered_bytecode':
                return operationData.coveredBytecode;
            case 'locktime':
                return numberToBinUint32LE(operationData.locktime);
            case 'outpoint_index':
                return numberToBinUint32LE(operationData.outpointIndex);
            case 'outpoint_transaction_hash':
                return operationData.outpointTransactionHash;
            case 'output_value':
                return bigIntToBinUint64LE(BigInt(operationData.outputValue));
            case 'sequence_number':
                return numberToBinUint32LE(operationData.sequenceNumber);
            case 'transaction_outpoints':
                return operationData.transactionOutpoints;
            case 'transaction_outpoints_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutpoints));
            case 'transaction_outputs':
                return operationData.transactionOutputs;
            case 'transaction_outputs_hash':
                return sha256.hash(sha256.hash(operationData.transactionOutputs));
            case 'transaction_sequence_numbers':
                return operationData.transactionSequenceNumbers;
            case 'transaction_sequence_numbers_hash':
                return sha256.hash(sha256.hash(operationData.transactionSequenceNumbers));
            case 'version':
                return numberToBinUint32LE(operationData.version);
            default:
                return `Unknown signing serialization algorithm or component, "${algorithmOrComponent}".`;
        }
    }
    return generateSigningSerializationBCH({
        correspondingOutput: operationData.correspondingOutput,
        coveredBytecode: operationData.coveredBytecode,
        locktime: operationData.locktime,
        outpointIndex: operationData.outpointIndex,
        outpointTransactionHash: operationData.outpointTransactionHash,
        outputValue: operationData.outputValue,
        sequenceNumber: operationData.sequenceNumber,
        sha256,
        signingSerializationType,
        transactionOutpoints: operationData.transactionOutpoints,
        transactionOutputs: operationData.transactionOutputs,
        transactionSequenceNumbers: operationData.transactionSequenceNumbers,
        version: operationData.version,
    });
};
/* eslint-disable camelcase */
export const getCompilerOperationsBCH = () => ({
    Key: {
        data_signature: compilerOperationBCHGenerateDataSignature('data_signature', (secp256k1) => secp256k1.signMessageHashDER),
        // eslint-disable-next-line complexity
        public_key: (identifier, data, environment) => {
            const { keys } = data;
            const { publicKeys, privateKeys } = keys;
            const [variableId] = identifier.split('.');
            if (publicKeys !== undefined &&
                publicKeys[variableId] !== undefined) {
                return publicKeys[variableId];
            }
            if (privateKeys !== undefined &&
                privateKeys[variableId] !== undefined) {
                const { secp256k1 } = environment;
                return secp256k1 === undefined
                    ? ScriptGenerationError.missingSecp256k1
                    : secp256k1.derivePublicKeyCompressed(privateKeys[variableId]);
            }
            return `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`;
        },
        schnorr_data_signature: compilerOperationBCHGenerateDataSignature('schnorr_data_signature', (secp256k1) => secp256k1.signMessageHashSchnorr),
        schnorr_signature: compilerOperationBCHGenerateSignature('schnorr_signature', (secp256k1) => secp256k1.signMessageHashSchnorr),
        signature: compilerOperationBCHGenerateSignature('signature', (secp256k1) => secp256k1.signMessageHashDER),
    },
    SigningSerialization: {
        corresponding_output: compilerOperationBCHGenerateSigningSerialization,
        corresponding_output_hash: compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode: compilerOperationBCHGenerateSigningSerialization,
        covered_bytecode_length: compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs: compilerOperationBCHGenerateSigningSerialization,
        full_all_outputs_single_input: compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output: compilerOperationBCHGenerateSigningSerialization,
        full_corresponding_output_single_input: compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs: compilerOperationBCHGenerateSigningSerialization,
        full_no_outputs_single_input: compilerOperationBCHGenerateSigningSerialization,
        locktime: compilerOperationBCHGenerateSigningSerialization,
        outpoint_index: compilerOperationBCHGenerateSigningSerialization,
        outpoint_transaction_hash: compilerOperationBCHGenerateSigningSerialization,
        output_value: compilerOperationBCHGenerateSigningSerialization,
        sequence_number: compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints: compilerOperationBCHGenerateSigningSerialization,
        transaction_outpoints_hash: compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs: compilerOperationBCHGenerateSigningSerialization,
        transaction_outputs_hash: compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers: compilerOperationBCHGenerateSigningSerialization,
        transaction_sequence_numbers_hash: compilerOperationBCHGenerateSigningSerialization,
        version: compilerOperationBCHGenerateSigningSerialization,
    },
});
/**
 * Create a `Compiler` from the provided compilation environment. This method
 * requires a full `CompilationEnvironment` and does not instantiate any new
 * crypto or VM implementations.
 *
 * @param compilationEnvironment - the environment from which to create the
 * compiler
 */
export const createCompiler = (compilationEnvironment) => ({
    generateBytecode: (script, data, 
    // TODO: TS bug?
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    debug = false
    // TODO: is there a way to avoid this `any`?
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) => {
        const result = compileScript(script, data, compilationEnvironment);
        return debug
            ? result
            : result.success
                ? { bytecode: result.bytecode, success: true }
                : { errorType: result.errorType, errors: result.errors, success: false };
    },
});
/**
 * A common `createState` implementation for most compilers.
 *
 * @param instructions - the list of instructions to incorporate in the created
 * state.
 */
export const compilerCreateStateCommon = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
instructions) => createAuthenticationProgramStateCommon(instructions, [], createAuthenticationProgramExternalStateCommonEmpty());
/**
 * Create a compiler using the default BCH environment.
 *
 * Internally instantiates the necessary crypto and VM implementations – use
 * `createCompiler` for more control.
 *
 * @param overrides - a compilation environment from which properties will be used
 * to override properties of the default BCH environment
 */
export const createCompilerBCH = async (overrides) => {
    const [sha256, secp256k1, vm] = await Promise.all([
        instantiateSha256(),
        instantiateSecp256k1(),
        instantiateVirtualMachineBCH(instructionSetBCHCurrentStrict),
    ]);
    return createCompiler({
        ...{
            createState: compilerCreateStateCommon,
            opcodes: generateBytecodeMap(OpcodesBCH),
            operations: getCompilerOperationsBCH(),
            secp256k1,
            sha256,
            vm,
        },
        ...overrides,
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvdGVtcGxhdGVzL2NvbXBpbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsaUJBQWlCLEdBRWxCLE1BQU0scUJBQXFCLENBQUM7QUFDN0IsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixxQkFBcUIsRUFDckIsbUJBQW1CLEdBQ3BCLE1BQU0scUJBQXFCLENBQUM7QUFDN0IsT0FBTyxFQUNMLCtCQUErQixFQUMvQix3QkFBd0IsR0FDekIsTUFBTSxrREFBa0QsQ0FBQztBQUMxRCxPQUFPLEVBRUwsbURBQW1ELEVBQ25ELHNDQUFzQyxFQUN0QyxtQkFBbUIsRUFDbkIsNEJBQTRCLEVBQzVCLDhCQUE4QixFQUM5QixVQUFVLEdBQ1gsTUFBTSxzQ0FBc0MsQ0FBQztBQUk5QyxPQUFPLEVBR0wsYUFBYSxHQUNkLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUdMLHVCQUF1QixHQUN4QixNQUFNLG9CQUFvQixDQUFDO0FBdUI1Qiw4QkFBOEI7QUFDOUIsTUFBTSxDQUFOLElBQVksdUNBeUJYO0FBekJELFdBQVksdUNBQXVDO0lBQ2pEOztPQUVHO0lBQ0gsc0VBQTJCLENBQUE7SUFDM0I7O09BRUc7SUFDSCxnR0FBcUQsQ0FBQTtJQUNyRDs7T0FFRztJQUNILHdGQUE2QyxDQUFBO0lBQzdDOztPQUVHO0lBQ0gsa0hBQXVFLENBQUE7SUFDdkU7O09BRUc7SUFDSCxvRUFBeUIsQ0FBQTtJQUN6Qjs7T0FFRztJQUNILDhGQUFtRCxDQUFBO0FBQ3JELENBQUMsRUF6QlcsdUNBQXVDLEtBQXZDLHVDQUF1QyxRQXlCbEQ7QUFxQ0QsSUFBSyxxQkFJSjtBQUpELFdBQUsscUJBQXFCO0lBQ3hCLHlGQUFnRSxDQUFBO0lBQ2hFLGtHQUF5RSxDQUFBO0lBQ3pFLHdHQUErRSxDQUFBO0FBQ2pGLENBQUMs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
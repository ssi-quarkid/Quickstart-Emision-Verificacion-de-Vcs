import { flattenBinArray, hexToBin, utf8ToBin, } from '../../../../../format/format';
import { bigIntToScriptNumber, encodeDataPush } from '../../../common/common';
import { generateBytecodeMap } from '../../../instruction-sets-utils';
import { OpcodesBCH } from '../../bch-opcodes';
export const bitcoinABCOpcodes = Object.entries(generateBytecodeMap(OpcodesBCH)).reduce((acc, cur) => ({ ...acc, [cur[0].slice('OP_'.length)]: cur[1] }), {
    PUSHDATA1: Uint8Array.of(OpcodesBCH.OP_PUSHDATA_1),
    PUSHDATA2: Uint8Array.of(OpcodesBCH.OP_PUSHDATA_2),
    PUSHDATA4: Uint8Array.of(OpcodesBCH.OP_PUSHDATA_4),
});
/**
 * Convert a string from Bitcoin ABC's `script_tests.json` text-format to
 * bytecode. The string must be valid â€“ this method attempts to convert all
 * unmatched tokens to `BigInt`s.
 *
 * @privateRemarks
 * This method doesn't use {@link compileScript} because of a slight
 * incompatibility in the languages. In BTL, BigIntLiterals are a primitive
 * type, and must be surrounded by a push statement (e.g. `<100>`) to push a
 * number to the stack. In the `script_tests.json` text-format, numbers are
 * assumed to be pushed. We could implement a transformation after the
 * compiler's parse step, but because this format doesn't require any other
 * features of the compiler, we opt to implement this as a simple method.
 * @param abcScript - the script in Bitcoin ABC's `script_tests.json` text
 * format
 */
export const assembleBitcoinABCScript = (abcScript) => flattenBinArray(abcScript
    .split(' ')
    .filter((token) => token !== '')
    .map((token) => token.startsWith('0x')
    ? hexToBin(token.slice('0x'.length))
    : token.startsWith("'")
        ? encodeDataPush(utf8ToBin(token.slice(1, token.length - 1)))
        : bitcoinABCOpcodes[token] === undefined
            ? encodeDataPush(bigIntToScriptNumber(BigInt(token)))
            : bitcoinABCOpcodes[token]));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Y29pbi1hYmMtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvaW5zdHJ1Y3Rpb24tc2V0cy9iY2gvZml4dHVyZXMvYml0Y29pbi1hYmMvYml0Y29pbi1hYmMtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLGVBQWUsRUFDZixRQUFRLEVBQ1IsU0FBUyxHQUNWLE1BQU0sOEJBQThCLENBQUM7QUFDdEMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzlFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3RFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUUvQyxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUM3QyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FDaEMsQ0FBQyxNQUFNLENBRUwsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDbkUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQztJQUNsRCxTQUFTLEVBQUUsVUFBVSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0lBQ2xELFNBQVMsRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7Q0FDbkQsQ0FBQyxDQUFDO0FBRUg7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxTQUFpQixFQUFFLEVBQUUsQ0FDNUQsZUFBZSxDQUNiLFNBQVM7S0FDTixLQUFLLENBQUMsR0FBRyxDQUFDO0tBQ1YsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDO0tBQy9CLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQ2IsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7SUFDcEIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwQyxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7UUFDdkIsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdELENBQUMsQ0FBRSxpQkFBaUIsQ0FBQyxLQUFLLENBQTRCLEtBQUssU0FBUztZQUNwRSxDQUFDLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3JELENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDN0IsQ0FDSixDQUFDIn0=
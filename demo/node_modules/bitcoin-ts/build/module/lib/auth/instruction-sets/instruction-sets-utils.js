import { binToHex, flattenBinArray, numberToBinUint16LE, numberToBinUint32LE, } from '../../format/format';
import { OpcodesBCH } from './bch/bch';
import { OpcodesBTC } from './btc/btc';
export const authenticationInstructionIsMalformed = (instruction) => instruction.malformed;
export const authenticationInstructionsAreMalformed = (instructions) => instructions.length > 0 &&
    authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
export const authenticationInstructionsAreNotMalformed = (instructions) => !authenticationInstructionsAreMalformed(instructions);
var CommonPushOpcodes;
(function (CommonPushOpcodes) {
    CommonPushOpcodes[CommonPushOpcodes["OP_0"] = 0] = "OP_0";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
    CommonPushOpcodes[CommonPushOpcodes["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
})(CommonPushOpcodes || (CommonPushOpcodes = {}));
var Bytes;
(function (Bytes) {
    Bytes[Bytes["Uint8"] = 1] = "Uint8";
    Bytes[Bytes["Uint16"] = 2] = "Uint16";
    Bytes[Bytes["Uint32"] = 4] = "Uint32";
})(Bytes || (Bytes = {}));
const readLittleEndianNumber = (script, index, length) => {
    const view = new DataView(script.buffer, index, length);
    const readAsLittleEndian = true;
    return length === Bytes.Uint8
        ? view.getUint8(0)
        : length === Bytes.Uint16
            ? view.getUint16(0, readAsLittleEndian)
            : view.getUint32(0, readAsLittleEndian);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode - an opcode between 0x00 and 0x4e
 */
export const lengthBytesForPushOpcode = (opcode) => opcode < CommonPushOpcodes.OP_PUSHDATA_1
    ? 0
    : opcode === CommonPushOpcodes.OP_PUSHDATA_1
        ? Bytes.Uint8
        : opcode === CommonPushOpcodes.OP_PUSHDATA_2
            ? Bytes.Uint16
            : Bytes.Uint32;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script - the script from which to read the next instruction
 * @param index - the offset from which to begin reading
 */
// eslint-disable-next-line complexity
export const readAuthenticationInstruction = (script, index) => {
    const opcode = script[index];
    if (opcode > CommonPushOpcodes.OP_PUSHDATA_4) {
        return {
            instruction: {
                opcode: opcode,
            },
            nextIndex: index + 1,
        };
    }
    const lengthBytes = lengthBytesForPushOpcode(opcode);
    const pushBytes = lengthBytes === 0;
    if (!pushBytes && index + lengthBytes >= script.length) {
        const sliceStart = index + 1;
        const sliceEnd = sliceStart + lengthBytes;
        return {
            instruction: {
                expectedLengthBytes: lengthBytes,
                length: script.slice(sliceStart, sliceEnd),
                malformed: true,
                opcode: opcode,
            },
            nextIndex: sliceEnd,
        };
    }
    const dataBytes = pushBytes
        ? opcode
        : readLittleEndianNumber(script, index + 1, lengthBytes);
    const dataStart = index + 1 + lengthBytes;
    const dataEnd = dataStart + dataBytes;
    return {
        instruction: {
            data: script.slice(dataStart, dataEnd),
            ...(dataEnd > script.length
                ? {
                    expectedDataBytes: dataEnd - dataStart,
                    malformed: true,
                }
                : undefined),
            opcode: opcode,
        },
        nextIndex: dataEnd,
    };
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script - the serialized script to parse
 */
export const parseBytecode = (script) => {
    const instructions = [];
    // eslint-disable-next-line functional/no-let
    let i = 0;
    // eslint-disable-next-line functional/no-loop-statement
    while (i < script.length) {
        const { instruction, nextIndex } = readAuthenticationInstruction(script, i);
        // eslint-disable-next-line functional/no-expression-statement
        i = nextIndex;
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        instructions.push(instruction);
    }
    return instructions;
};
const isPush = (instruction) => instruction.data !== undefined;
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */
const isMultiWordPush = (opcode) => opcode !== CommonPushOpcodes.OP_0;
const formatAsmPushHex = (data) => data.length > 0 ? `0x${binToHex(data)}` : '';
const formatMissingBytesAsm = (missing) => `[missing ${missing} byte${missing === 1 ? '' : 's'}]`;
const hasMalformedLength = (instruction) => instruction
    .length !== undefined;
const isPushData = (pushOpcode) => pushOpcode >= CommonPushOpcodes.OP_PUSHDATA_1;
export const disassembleParsedAuthenticationInstructionMalformed = (opcodes, instruction) => `${opcodes[instruction.opcode]} ${hasMalformedLength(instruction)
    ? `${formatAsmPushHex(instruction.length)}${formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)}`
    : `${isPushData(instruction.opcode)
        ? `${instruction.expectedDataBytes} `
        : ''}${formatAsmPushHex(instruction.data)}${formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)}`}`;
export const disassembleAuthenticationInstruction = (opcodes, instruction) => `${opcodes[instruction.opcode]}${isPush(instruction) &&
    isMultiWordPush(instruction.opcode)
    ? ` ${isPushData(instruction.opcode)
        ? `${instruction.data.length} `
        : ''}${formatAsmPushHex(instruction.data)}`
    : ''}`;
export const disassembleParsedAuthenticationInstruction = (opcodes, instruction) => authenticationInstructionIsMalformed(instruction)
    ? disassembleParsedAuthenticationInstructionMalformed(opcodes, instruction)
    : disassembleAuthenticationInstruction(opcodes, instruction);
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script - the array of instructions to disassemble
 */
export const disassembleParsedAuthenticationInstructions = (opcodes, instructions) => instructions
    .map((instruction) => disassembleParsedAuthenticationInstruction(opcodes, instruction))
    .join(' ');
/**
 * Disassemble authentication bytecode into a lossless ASM representation.
 *
 * TODO: a similar method which re-formats ASM strings, converting HexLiterals to Script Numbers or UTF8Literals.
 *
 * @param opcodes - the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode - the authentication bytecode to disassemble
 */
export const disassembleBytecode = (opcodes, bytecode) => disassembleParsedAuthenticationInstructions(opcodes, parseBytecode(bytecode));
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode - the authentication bytecode to disassemble
 */
export const disassembleBytecodeBCH = (bytecode) => disassembleParsedAuthenticationInstructions(OpcodesBCH, parseBytecode(bytecode));
// TODO: assembleBytecodeBCH â€“ instantiate synchronous compiler, throw any errors
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode - the authentication bytecode to disassemble
 */
export const disassembleBytecodeBTC = (bytecode) => disassembleParsedAuthenticationInstructions(OpcodesBTC, parseBytecode(bytecode));
// TODO: assembleBytecodeBTC
const getInstructionLengthBytes = (instruction) => {
    const opcode = instruction.opcode;
    const expectedLength = lengthBytesForPushOpcode(opcode);
    return expectedLength === Bytes.Uint8
        ? Uint8Array.of(instruction.data.length)
        : expectedLength === Bytes.Uint16
            ? numberToBinUint16LE(instruction.data.length)
            : numberToBinUint32LE(instruction.data.length);
};
export const serializeAuthenticationInstruction = (instruction) => Uint8Array.from([
    instruction.opcode,
    ...(isPush(instruction)
        ? [
            ...(isPushData(instruction.opcode)
                ? getInstructionLengthBytes(instruction)
                : []),
            ...instruction.data,
        ]
        : []),
]);
export const serializeParsedAuthenticationInstructionMalformed = (instruction) => {
    const opcode = instruction.opcode;
    if (hasMalformedLength(instruction)) {
        return Uint8Array.from([opcode, ...instruction.length]);
    }
    if (isPushData(opcode)) {
        return Uint8Array.from([
            opcode,
            ...(opcode === CommonPushOpcodes.OP_PUSHDATA_1
                ? Uint8Array.of(instruction.expectedDataBytes)
                : opcode === CommonPushOpcodes.OP_PUSHDATA_2
                    ? numberToBinUint16LE(instruction.expectedDataBytes)
                    : numberToBinUint32LE(instruction.expectedDataBytes)),
            ...instruction.data,
        ]);
    }
    return Uint8Array.from([opcode, ...instruction.data]);
};
export const serializeParsedAuthenticationInstruction = (instruction) => authenticationInstructionIsMalformed(instruction)
    ? serializeParsedAuthenticationInstructionMalformed(instruction)
    : serializeAuthenticationInstruction(instruction);
export const serializeAuthenticationInstructions = (instructions) => flattenBinArray(instructions.map(serializeAuthenticationInstruction));
export const serializeParsedAuthenticationInstructions = (instructions) => flattenBinArray(instructions.map(serializeParsedAuthenticationInstruction));
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes - An opcode enum, e.g. `OpcodesBCH`
 */
export const generateBytecodeMap = (opcodes) => Object.entries(opcodes)
    .filter((entry) => typeof entry[1] === 'number')
    .reduce((identifiers, pair) => ({
    ...identifiers,
    [pair[0]]: Uint8Array.of(pair[1]),
}), {});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdHJ1Y3Rpb24tc2V0cy11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvYXV0aC9pbnN0cnVjdGlvbi1zZXRzL2luc3RydWN0aW9uLXNldHMtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFFBQVEsRUFDUixlQUFlLEVBQ2YsbUJBQW1CLEVBQ25CLG1CQUFtQixHQUNwQixNQUFNLHFCQUFxQixDQUFDO0FBRTdCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDdkMsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQVV2QyxNQUFNLENBQUMsTUFBTSxvQ0FBb0MsR0FBRyxDQUNsRCxXQUFxRCxFQUNhLEVBQUUsQ0FDbkUsV0FBaUUsQ0FBQyxTQUFTLENBQUM7QUFFL0UsTUFBTSxDQUFDLE1BQU0sc0NBQXNDLEdBQUcsQ0FDcEQsWUFBdUQsRUFDYyxFQUFFLENBQ3ZFLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQztJQUN2QixvQ0FBb0MsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRTlFLE1BQU0sQ0FBQyxNQUFNLHlDQUF5QyxHQUFHLENBQ3ZELFlBQXVELEVBQ0QsRUFBRSxDQUN4RCxDQUFDLHNDQUFzQyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBRXhELElBQUssaUJBS0o7QUFMRCxXQUFLLGlCQUFpQjtJQUNwQix5REFBVyxDQUFBO0lBQ1gsNEVBQW9CLENBQUE7SUFDcEIsNEVBQW9CLENBQUE7SUFDcEIsNEVBQW9CLENBQUE7QUFDdEIsQ0FBQyxFQUxJLGlCQUFpQixLQUFqQixpQkFBaUIsUUFLckI7QUFFRCxJQUFLLEtBSUo7QUFKRCxXQUFLLEtBQUs7SUFDUixtQ0FBUyxDQUFBO0lBQ1QscUNBQVUsQ0FBQTtJQUNWLHFDQUFVLENBQUE7QUFDWixDQUFDLEVBSkks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
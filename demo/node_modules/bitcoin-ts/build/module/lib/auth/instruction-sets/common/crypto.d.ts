import { Ripemd160, Secp256k1, Sha1, Sha256 } from '../../../crypto/crypto';
import { AuthenticationProgramStateCommon, ErrorState, MinimumProgramState, StackState } from '../../state';
import { Operation } from '../../virtual-machine';
import { AuthenticationErrorCommon } from './errors';
import { OpcodesCommon } from './opcodes';
export { Ripemd160, Sha1, Sha256, Secp256k1 };
export declare const opRipemd160: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>({ ripemd160, }: {
    ripemd160: {
        hash: (input: Uint8Array) => Uint8Array;
    };
}) => Operation<State>;
export declare const opSha1: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>({ sha1, }: {
    sha1: {
        hash: (input: Uint8Array) => Uint8Array;
    };
}) => Operation<State>;
export declare const opSha256: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>({ sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
}) => Operation<State>;
export declare const opHash160: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>({ ripemd160, sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    ripemd160: {
        hash: (input: Uint8Array) => Uint8Array;
    };
}) => Operation<State>;
export declare const opHash256: <Opcodes, State extends MinimumProgramState<Opcodes> & StackState<Uint8Array> & ErrorState<Errors, AuthenticationErrorCommon>, Errors>({ sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
}) => Operation<State>;
export declare const opCodeSeparator: <Opcodes, State extends MinimumProgramState<Opcodes> & {
    lastCodeSeparator: number;
}>() => Operation<State>;
export declare const opCheckSig: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>({ flags, secp256k1, sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    secp256k1: {
        verifySignatureSchnorr: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
        verifySignatureDERLowS: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
    };
    flags: {
        requireNullSignatureFailures: boolean;
    };
}) => Operation<State>;
export declare const opCheckMultiSig: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>({ flags: { requireMinimalEncoding, requireBugValueZero, requireNullSignatureFailures, }, secp256k1, sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    secp256k1: {
        verifySignatureDERLowS: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
    };
    flags: {
        requireBugValueZero: boolean;
        requireMinimalEncoding: boolean;
        requireNullSignatureFailures: boolean;
    };
}) => (s: State) => State;
export declare const opCheckSigVerify: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>({ flags, secp256k1, sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    secp256k1: {
        verifySignatureSchnorr: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
        verifySignatureDERLowS: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
    };
    flags: {
        requireNullSignatureFailures: boolean;
    };
}) => Operation<State>;
export declare const opCheckMultiSigVerify: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>({ flags, secp256k1, sha256, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    secp256k1: {
        verifySignatureDERLowS: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
    };
    flags: {
        requireBugValueZero: boolean;
        requireMinimalEncoding: boolean;
        requireNullSignatureFailures: boolean;
    };
}) => Operation<State>;
export declare const cryptoOperations: <Opcodes, State extends AuthenticationProgramStateCommon<Opcodes, Errors>, Errors>({ flags, ripemd160, secp256k1, sha1, sha256, }: {
    sha1: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    ripemd160: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    secp256k1: {
        verifySignatureSchnorr: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
        verifySignatureDERLowS: (signature: Uint8Array, publicKey: Uint8Array, messageHash: Uint8Array) => boolean;
    };
    flags: {
        requireBugValueZero: boolean;
        requireMinimalEncoding: boolean;
        requireNullSignatureFailures: boolean;
    };
}) => {
    166: Operation<State>;
    167: Operation<State>;
    168: Operation<State>;
    169: Operation<State>;
    170: Operation<State>;
    171: Operation<State>;
    172: Operation<State>;
    173: Operation<State>;
    174: (s: State) => State;
    175: Operation<State>;
};
//# sourceMappingURL=crypto.d.ts.map
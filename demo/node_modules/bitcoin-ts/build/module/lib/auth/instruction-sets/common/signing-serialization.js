import { bigIntToBinUint64LE, bigIntToBitcoinVarInt, numberToBinUint32LE, } from '../../../format/format';
/* eslint-disable camelcase */
/**
 * A.K.A. `sighash` flags
 */
export var SigningSerializationFlag;
(function (SigningSerializationFlag) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationFlag[SigningSerializationFlag["all_outputs"] = 1] = "all_outputs";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationFlag[SigningSerializationFlag["no_outputs"] = 2] = "no_outputs";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationFlag[SigningSerializationFlag["corresponding_output"] = 3] = "corresponding_output";
    SigningSerializationFlag[SigningSerializationFlag["fork_id"] = 64] = "fork_id";
    /**
     * A.K.A `ANYONE_CAN_PAY`
     */
    SigningSerializationFlag[SigningSerializationFlag["single_input"] = 128] = "single_input";
})(SigningSerializationFlag || (SigningSerializationFlag = {}));
export const isDefinedSigningSerializationType = (byte) => {
    const baseType = 
    // eslint-disable-next-line no-bitwise
    byte &
        // eslint-disable-next-line no-bitwise
        ~(SigningSerializationFlag.fork_id | SigningSerializationFlag.single_input);
    return (baseType >= SigningSerializationFlag.all_outputs &&
        baseType <= SigningSerializationFlag.corresponding_output);
};
const match = (type, flag) => 
// eslint-disable-next-line no-bitwise
(type[0] & flag) !== 0;
const equals = (type, flag
// eslint-disable-next-line no-bitwise
) => (type[0] & 31 /* mask5Bits */) === flag;
const shouldSerializeSingleInput = (type) => match(type, SigningSerializationFlag.single_input);
const shouldSerializeCorrespondingOutput = (type) => equals(type, SigningSerializationFlag.corresponding_output);
const shouldSerializeNoOutputs = (type) => equals(type, SigningSerializationFlag.no_outputs);
const emptyHash = () => new Uint8Array(32 /* sha256HashByteLength */).fill(0);
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionOutpoints - see `generateSigningSerializationBCH`
 */
export const hashPrevouts = ({ sha256, signingSerializationType, transactionOutpoints, }) => shouldSerializeSingleInput(signingSerializationType)
    ? emptyHash()
    : sha256.hash(sha256.hash(transactionOutpoints));
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionSequenceNumbers - see
 * `generateSigningSerializationBCH`
 */
export const hashSequence = ({ sha256, signingSerializationType, transactionSequenceNumbers, }) => !shouldSerializeSingleInput(signingSerializationType) &&
    !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionSequenceNumbers))
    : emptyHash();
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionOutputs - see `generateSigningSerializationBCH`
 * @param correspondingOutput - see `generateSigningSerializationBCH`
 */
export const hashOutputs = ({ correspondingOutput, sha256, signingSerializationType, transactionOutputs, }) => !shouldSerializeCorrespondingOutput(signingSerializationType) &&
    !shouldSerializeNoOutputs(signingSerializationType)
    ? sha256.hash(sha256.hash(transactionOutputs))
    : shouldSerializeCorrespondingOutput(signingSerializationType)
        ? correspondingOutput === undefined
            ? emptyHash()
            : sha256.hash(sha256.hash(correspondingOutput))
        : emptyHash();
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 */
export const generateSigningSerializationBCH = ({ correspondingOutput, coveredBytecode, forkId = new Uint8Array([0, 0, 0]), locktime, outpointIndex, outpointTransactionHash, outputValue, sequenceNumber, sha256, signingSerializationType, transactionOutpoints, transactionOutputs, transactionSequenceNumbers, version, }) => new Uint8Array([
    ...numberToBinUint32LE(version),
    ...hashPrevouts({ sha256, signingSerializationType, transactionOutpoints }),
    ...hashSequence({
        sha256,
        signingSerializationType,
        transactionSequenceNumbers,
    }),
    ...outpointTransactionHash.slice().reverse(),
    ...numberToBinUint32LE(outpointIndex),
    ...Uint8Array.from([
        ...bigIntToBitcoinVarInt(BigInt(coveredBytecode.length)),
        ...coveredBytecode,
    ]),
    ...bigIntToBinUint64LE(BigInt(outputValue)),
    ...numberToBinUint32LE(sequenceNumber),
    ...hashOutputs({
        correspondingOutput,
        sha256,
        signingSerializationType,
        transactionOutputs,
    }),
    ...numberToBinUint32LE(locktime),
    ...signingSerializationType,
    ...forkId,
]);
/**
 * @param signingSerializationType - the 32-bit number indicating the signing
 * serialization algorithm to use
 */
export const isLegacySigningSerialization = (signingSerializationType) => {
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const forkValue = signingSerializationType >> 8;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const newForkValue = (forkValue ^ 0xdead) | 0xff0000;
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const sighashType = (newForkValue << 8) | (signingSerializationType & 0xff);
    // eslint-disable-next-line no-bitwise
    return (sighashType & SigningSerializationFlag.fork_id) === 0;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmluZy1zZXJpYWxpemF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9hdXRoL2luc3RydWN0aW9uLXNldHMvY29tbW9uL3NpZ25pbmctc2VyaWFsaXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLHFCQUFxQixFQUNyQixtQkFBbUIsR0FDcEIsTUFBTSx3QkFBd0IsQ0FBQztBQUVoQyw4QkFBOEI7QUFDOUI7O0dBRUc7QUFDSCxNQUFNLENBQU4sSUFBWSx3QkFrQlg7QUFsQkQsV0FBWSx3QkFBd0I7SUFDbEM7O09BRUc7SUFDSCxxRkFBa0IsQ0FBQTtJQUNsQjs7T0FFRztJQUNILG1GQUFpQixDQUFBO0lBQ2pCOztPQUVHO0lBQ0gsdUdBQTJCLENBQUE7SUFDM0IsOEVBQWMsQ0FBQTtJQUNkOztPQUVHO0lBQ0gseUZBQW1CLENBQUE7QUFDckIsQ0FBQyxFQWxCVyx3QkFBd0IsS0FBeEIsd0JBQXdCLFFBa0JuQztBQVFELE1BQU0sQ0FBQyxNQUFNLGlDQUFpQyxHQUFHLENBQUMsSUFBWSxFQUFFLEVBQUU7SUFDaEUsTUFBTSxRQUFRO0lBQ1osc0NBQXNDO0lBQ3RDLElBQUk7UUFDSixzQ0FBc0M7UUFDdEMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLE9BQU8sR0FBRyx3QkFBd0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM5RSxPQUFPLENBQ0wsUUFBUSxJQUFJLHdCQUF3QixDQUFDLFdBQVc7UUFDaEQsUUFBUSxJQUFJLHdCQUF3QixDQUFDLG9CQUFvQixDQUMxRCxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUYsTUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFnQixFQUFFLElBQThCLEVBQUUsRUFBRTtBQUNqRSxzQ0FBc0M7QUFDdEMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBRXpC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
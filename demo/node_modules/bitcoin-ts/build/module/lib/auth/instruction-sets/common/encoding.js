import { ConsensusBCH } from '../bch/bch';
import { isDefinedSigningSerializationType } from './signing-serialization';
export const isValidUncompressedPublicKeyEncoding = (publicKey) => publicKey.length === 65 /* uncompressedByteLength */ &&
    publicKey[0] === 4 /* uncompressedHeaderByte */;
export const isValidCompressedPublicKeyEncoding = (publicKey) => publicKey.length === 33 /* compressedByteLength */ &&
    (publicKey[0] === 2 /* compressedHeaderByteEven */ ||
        publicKey[0] === 3 /* compressedHeaderByteOdd */);
export const isValidPublicKeyEncoding = (publicKey) => isValidCompressedPublicKeyEncoding(publicKey) ||
    isValidUncompressedPublicKeyEncoding(publicKey);
const isNegative = (value) => 
// eslint-disable-next-line no-bitwise
(value & 128 /* negative */) !== 0;
const hasUnnecessaryPadding = (length, firstByte, secondByte) => length > 1 && firstByte === 0 && !isNegative(secondByte);
const isValidInteger = (signature, tagIndex, length, valueIndex
// eslint-disable-next-line max-params
) => signature[tagIndex] === 2 /* integerTagType */ &&
    length !== 0 &&
    !isNegative(signature[valueIndex]) &&
    !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
/**
 * Validate a DER-encoded signature.
 *
 * @remarks
 * This function is consensus-critical since BIP66, but differs from the BIP66
 * specification in that it does not validate the existence of a signing
 * serialization type byte at the end of the signature (to support
 * OP_CHECKDATASIG). To validate a bitcoin-encoded signature (including null
 * signatures), use `isValidSignatureEncodingBCH`.
 *
 * @privateRemarks
 * From the Bitcoin ABC C++ implementation:
 *
 * Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
 * total-length: 1-byte length descriptor of everything that follows,
 * excluding the sighash byte.
 * R-length: 1-byte length descriptor of the R value that follows.
 * R: arbitrary-length big-endian encoded R value. It must use the
 * shortest possible encoding for a positive integers (which means no null
 * bytes at the start, except a single one when the next byte has its highest
 * bit set).
 * S-length: 1-byte length descriptor of the S value that follows.
 * S: arbitrary-length big-endian encoded S value. The same rules apply.
 */
// eslint-disable-next-line complexity
export const isValidSignatureEncodingDER = (signature) => {
    const correctLengthRange = signature.length > 8 /* minimumLength */ &&
        signature.length < 72 /* maximumLength */;
    const correctSequenceTagType = signature[0 /* sequenceTagIndex */] === 48 /* sequenceTagType */;
    const correctSequenceLength = signature[1 /* sequenceLengthIndex */] ===
        signature.length - 2 /* sequenceMetadataBytes */;
    const rLength = signature[3 /* rLengthIndex */];
    if (rLength === undefined) {
        return false;
    }
    const consistentRLength = rLength <= signature.length - 7 /* minimumNonRValueBytes */;
    const rIsValid = isValidInteger(signature, 2 /* rTagIndex */, rLength, 4 /* rValueIndex */);
    const sTagIndex = 4 /* rValueIndex */ + rLength; // eslint-disable-line @typescript-eslint/restrict-plus-operands
    const sLengthIndex = sTagIndex + 1;
    const sLength = signature[sLengthIndex];
    if (sLength === undefined) {
        return false;
    }
    const sValueIndex = sLengthIndex + 1;
    const consistentSLength = sValueIndex + sLength === signature.length;
    const sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
    return (correctLengthRange &&
        correctSequenceTagType &&
        correctSequenceLength &&
        consistentRLength &&
        rIsValid &&
        consistentSLength &&
        sIsValid);
};
/**
 * Validate the encoding of a transaction signature, including a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param transactionSignature - the full transaction signature
 */
export const isValidSignatureEncodingBCHTransaction = (transactionSignature) => transactionSignature.length === 0 ||
    transactionSignature.length === ConsensusBCH.schnorrSignatureLength + 1 ||
    (isDefinedSigningSerializationType(transactionSignature[transactionSignature.length - 1]) &&
        isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1)));
/**
 * Split a bitcoin-encoded signature into a signature and signing serialization
 * type.
 *
 * While a bitcoin-encoded signature only includes a single byte to encode the
 * signing serialization type, a 3-byte forkId can be appended to the signing
 * serialization to provide replay-protection between different forks. (See
 * Bitcoin Cash's Replay Protected Sighash spec for details.)
 *
 * @param signature - a signature which passes `isValidSignatureEncoding`
 */
export const decodeBitcoinSignature = (encodedSignature) => ({
    signature: encodedSignature.slice(0, encodedSignature.length - 1),
    signingSerializationType: new Uint8Array([
        encodedSignature[encodedSignature.length - 1],
    ]),
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2RpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2F1dGgvaW5zdHJ1Y3Rpb24tc2V0cy9jb21tb24vZW5jb2RpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLFlBQVksQ0FBQztBQUUxQyxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQVU1RSxNQUFNLENBQUMsTUFBTSxvQ0FBb0MsR0FBRyxDQUFDLFNBQXFCLEVBQUUsRUFBRSxDQUM1RSxTQUFTLENBQUMsTUFBTSxvQ0FBcUM7SUFDckQsU0FBUyxDQUFDLENBQUMsQ0FBQyxtQ0FBcUMsQ0FBQztBQUVwRCxNQUFNLENBQUMsTUFBTSxrQ0FBa0MsR0FBRyxDQUFDLFNBQXFCLEVBQUUsRUFBRSxDQUMxRSxTQUFTLENBQUMsTUFBTSxrQ0FBbUM7SUFDbkQsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLHFDQUF1QztRQUNsRCxTQUFTLENBQUMsQ0FBQyxDQUFDLG9DQUFzQyxDQUFDLENBQUM7QUFFeEQsTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxTQUFxQixFQUFFLEVBQUUsQ0FDaEUsa0NBQWtDLENBQUMsU0FBUyxDQUFDO0lBQzdDLG9DQUFvQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBcUNsRCxNQUFNLFVBQVUsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO0FBQ25DLHNDQUFzQztBQUN0QyxDQUFDLEtBQUsscUJBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFaEMsTUFBTSxxQkFBcUIsR0FBRyxDQUM1QixNQUFjLEVBQ2QsU0FBaUIsRUFDakIsVUFBa0IsRUFDbEIsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUU5RCxNQUFNLGNBQWMsR0FBRyxDQUNyQixTQUFxQixFQUNyQixRQUFnQixFQUNoQixNQUFjLEVBQ2QsVUFBa0I7QUFDbEIsc0NBQXNDO0VBQ3RDLEVBQUUsQ0FDRixTQUFTLENBQUMsUUFBUSxDQUFDLDJCQUF3QjtJQUMzQyxNQUFNLEtBQUssQ0FBQztJQUNaLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNsQyxDQUFDLHFCQUFxQixDQUNwQixNQUFNLEVBQ04sU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUNyQixTQUFTLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUMxQixDQUFDO0FBRUo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJHO0FBQ0gsc0NBQXNDO0FBQ3RDLE1BQU0sQ0FBQyxNQUFNLDJCQUEyQixHQUFHLENBQUMsU0FBcUIsRUFBRSxFQUFFO0lBQ25FLE1BQU0sa0JBQWtCLEdBQ3RCLFNBQVMsQ0FBQyxNQUFNLHdCQUFvQjtRQUNwQyxTQUFTLENBQUMsTUFBTSx5QkFBb0IsQ0FBQztJQUN2QyxNQUFNLHNCQUFzQixHQUMxQixTQUFTLDBCQUFzQiw2QkFBeUIsQ0FBQztJQUMzRCxNQUFNLHFCQUFxQixHQUN6QixTQUFTLDZCQUF5QjtRQUNsQyxTQUFTLENBQUMsTUFBTSxnQ0FBNEIsQ0FBQztJQUMvQyxNQUFNLE9BQU8sR0FBRyxTQUFTLHNCQUF3QyxDQUFDO0lBQ2xFLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtRQUN6QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsTUFBTSxpQkFBaUIsR0FDckIsT0FBTyxJQUFJLFNBQVMsQ0FBQyxNQUFNLGdDQUE0QixDQUFDO0lBQzFELE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FDN0IsU0FBUyxxQkFFVCxPQUFPLHNCQUVSLENBQUM7SUFDRixNQUFNLFNBQVMsR0FBRyxzQkFBa0IsT0FBTyxDQUFDLENBQUMsZ0VBQWdFO0lBQzdHLE1BQU0sWUFBWSxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDbkMsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBdUIsQ0FBQztJQUM5RCxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7UUFDekIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELE1BQU0sV0FBVyxHQUFHLFlBQVksR0FBRyxDQUFDLENBQUM7SUFDckMsTUFBTSxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsT0FBTyxLQUFLLFNBQVMsQ0FBQyxNQUFNLENBQUM7SUFDckUsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzVFLE9BQU8sQ0FDTCxrQkFBa0I7UUFDbEIsc0JBQXNCO1FBQ3RCLHFCQUFxQjtRQUNyQixpQkFBaUI7UUFDakIsUUFBUTtRQUNSLGlCQUFpQjtRQUNqQixRQUFRLENBQ1QsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGOzs7OztHQUtHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sc0NBQXNDLEdBQUcsQ0FDcEQsb0JBQWdDLEVBQ2hDLEVBQUUsQ0FDRixvQkFBb0IsQ0FBQyxNQUFNLEtBQUssQ0FBQztJQUNqQyxvQkFBb0IsQ0FBQyxNQUFNLEtBQUssWUFBWSxDQUFDLHNCQUFzQixHQUFHLENBQUM7SUFDdkUsQ0FBQyxpQ0FBaUMsQ0FDaEMsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUN0RDtRQUNDLDJCQUEyQixDQUN6QixvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLG9CQUFvQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FDL0QsQ0FBQyxDQUFDO0FBRVA7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLENBQUMsZ0JBQTRCLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDdkUsU0FBUyxFQUFFLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNqRSx3QkFBd0IsRUFBRSxJQUFJLFVBQVUsQ0FBQztRQUN2QyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQzlDLENBQUM7Q0FDSCxDQUFDLENBQUMifQ==
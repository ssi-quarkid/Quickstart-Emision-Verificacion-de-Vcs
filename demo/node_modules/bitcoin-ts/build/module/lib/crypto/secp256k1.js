/* eslint-disable functional/no-conditional-statement, functional/no-expression-statement, functional/no-throw-statement */
import { CompressionFlag, ContextFlag, instantiateSecp256k1Wasm, instantiateSecp256k1WasmBytes, } from '../bin/bin';
/**
 * @param secp256k1Wasm - a Secp256k1Wasm object
 * @param randomSeed - a 32-byte random seed used to randomize the context after
 * creation
 */
const wrapSecp256k1Wasm = (secp256k1Wasm, randomSeed) => {
    /**
     * Currently, this wrapper creates a context with both SIGN and VERIFY
     * capabilities. For better initialization performance, consumers could
     * re-implement a wrapper with only the capabilities they require.
     */
    const contextPtr = secp256k1Wasm.contextCreate(ContextFlag.BOTH);
    /**
     * Since all of these methods are single-threaded and synchronous, we can
     * reuse allocated WebAssembly memory for each method without worrying about
     * calls interfering with each other. Likewise, these spaces never need to be
     * `free`d, since we will continue using them until this entire object (and
     * with it, the entire WebAssembly instance) is garbage collected.
     *
     * If malicious javascript gained access to this object, it should be
     * considered a critical vulnerability in the consumer. However, as a best
     * practice, we zero out private keys below when we're finished with them.
     */
    const sigScratch = secp256k1Wasm.malloc(72 /* maxECDSASig */);
    const publicKeyScratch = secp256k1Wasm.malloc(65 /* maxPublicKey */);
    const messageHashScratch = secp256k1Wasm.malloc(32 /* messageHash */);
    const internalPublicKeyPtr = secp256k1Wasm.malloc(64 /* internalPublicKey */);
    const internalSigPtr = secp256k1Wasm.malloc(64 /* internalSig */);
    const schnorrSigPtr = secp256k1Wasm.malloc(64 /* schnorrSig */);
    const privateKeyPtr = secp256k1Wasm.malloc(32 /* privateKey */);
    const internalRSigPtr = secp256k1Wasm.malloc(65 /* recoverableSig */);
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    const recoveryNumPtr = secp256k1Wasm.malloc(4);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const recoveryNumPtrView32 = recoveryNumPtr >> 2;
    const getRecoveryNumPtr = () => secp256k1Wasm.heapU32[recoveryNumPtrView32];
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    const lengthPtr = secp256k1Wasm.malloc(4);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    const lengthPtrView32 = lengthPtr >> 2;
    const parsePublicKey = (publicKey) => {
        secp256k1Wasm.heapU8.set(publicKey, publicKeyScratch);
        return (secp256k1Wasm.pubkeyParse(contextPtr, internalPublicKeyPtr, publicKeyScratch, 
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        publicKey.length) === 1);
    };
    const setLengthPtr = (value) => {
        secp256k1Wasm.heapU32.set([value], lengthPtrView32);
    };
    const getLengthPtr = () => secp256k1Wasm.heapU32[lengthPtrView32];
    const serializePublicKey = (length, flag) => {
        setLengthPtr(length);
        secp256k1Wasm.pubkeySerialize(contextPtr, publicKeyScratch, lengthPtr, internalPublicKeyPtr, flag);
        return secp256k1Wasm.readHeapU8(publicKeyScratch, getLengthPtr()).slice();
    };
    const getSerializedPublicKey = (compressed) => compressed
        ? serializePublicKey(33 /* compressedPublicKey */, CompressionFlag.COMPRESSED)
        : serializePublicKey(65 /* uncompressedPublicKey */, CompressionFlag.UNCOMPRESSED);
    const convertPublicKey = (compressed) => (publicKey) => {
        if (!parsePublicKey(publicKey)) {
            throw new Error('Failed to parse public key.');
        }
        return getSerializedPublicKey(compressed);
    };
    const parseSignature = (signature, DER) => {
        secp256k1Wasm.heapU8.set(signature, sigScratch);
        return DER
            ? secp256k1Wasm.signatureParseDER(contextPtr, internalSigPtr, sigScratch, signature.length) === 1
            : secp256k1Wasm.signatureParseCompact(contextPtr, internalSigPtr, sigScratch) === 1;
    };
    const parseOrThrow = (signature, DER) => {
        if (!parseSignature(signature, DER)) {
            throw new Error('Failed to parse signature.');
        }
    };
    const getCompactSig = () => {
        secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, 64 /* compactSig */).slice();
    };
    const getDERSig = () => {
        setLengthPtr(72 /* maxECDSASig */);
        secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
    };
    const convertSignature = (wasDER) => (signature) => {
        parseOrThrow(signature, wasDER);
        return wasDER ? getCompactSig() : getDERSig();
    };
    const fillPrivateKeyPtr = (privateKey) => {
        secp256k1Wasm.heapU8.set(privateKey, privateKeyPtr);
    };
    const zeroOutPtr = (pointer, bytes) => {
        secp256k1Wasm.heapU8.fill(0, pointer, pointer + bytes);
    };
    const zeroOutPrivateKeyPtr = () => {
        zeroOutPtr(privateKeyPtr, 32 /* privateKey */);
    };
    const withPrivateKey = (privateKey, instructions) => {
        fillPrivateKeyPtr(privateKey);
        const ret = instructions();
        zeroOutPrivateKeyPtr();
        return ret;
    };
    const derivePublicKey = (compressed) => (privateKey) => {
        const invalid = withPrivateKey(privateKey, () => secp256k1Wasm.pubkeyCreate(contextPtr, internalPublicKeyPtr, privateKeyPtr) !== 1);
        if (invalid) {
            throw new Error('Cannot derive public key from invalid private key.');
        }
        return getSerializedPublicKey(compressed);
    };
    const fillMessageHashScratch = (messageHash) => {
        secp256k1Wasm.heapU8.set(messageHash, messageHashScratch);
    };
    const normalizeSignature = () => {
        secp256k1Wasm.signatureNormalize(contextPtr, internalSigPtr, internalSigPtr);
    };
    const modifySignature = (DER, normalize) => (signature) => {
        parseOrThrow(signature, DER);
        if (normalize) {
            normalizeSignature();
        }
        else {
            secp256k1Wasm.signatureMalleate(contextPtr, internalSigPtr, internalSigPtr);
        }
        return DER ? getDERSig() : getCompactSig();
    };
    const parseAndNormalizeSignature = (signature, DER, normalize) => {
        const ret = parseSignature(signature, DER);
        if (normalize) {
            normalizeSignature();
        }
        return ret;
    };
    const signMessageHash = (DER) => (privateKey, messageHash) => {
        fillMessageHashScratch(messageHash);
        return withPrivateKey(privateKey, () => {
            const failed = secp256k1Wasm.sign(contextPtr, internalSigPtr, messageHashScratch, privateKeyPtr) !== 1;
            if (failed) {
                throw new Error('Failed to sign message hash. The private key is not valid.');
            }
            if (DER) {
                setLengthPtr(72 /* maxECDSASig */);
                secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
                return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
            }
            secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
            return secp256k1Wasm
                .readHeapU8(sigScratch, 64 /* compactSig */)
                .slice();
        });
    };
    const signMessageHashSchnorr = () => (privateKey, messageHash) => {
        fillMessageHashScratch(messageHash);
        return withPrivateKey(privateKey, () => {
            const failed = secp256k1Wasm.schnorrSign(contextPtr, schnorrSigPtr, messageHashScratch, privateKeyPtr) !== 1;
            if (failed) {
                throw new Error('Failed to sign message hash. The private key is not valid.');
            }
            return secp256k1Wasm
                .readHeapU8(schnorrSigPtr, 64 /* schnorrSig */)
                .slice();
        });
    };
    const verifyMessage = (messageHash) => {
        fillMessageHashScratch(messageHash);
        return (secp256k1Wasm.verify(contextPtr, internalSigPtr, messageHashScratch, internalPublicKeyPtr) === 1);
    };
    const verifySignature = (DER, normalize) => (signature, publicKey, messageHash) => parsePublicKey(publicKey) &&
        parseAndNormalizeSignature(signature, DER, normalize) &&
        verifyMessage(messageHash);
    const verifyMessageSchnorr = (messageHash, signature) => {
        fillMessageHashScratch(messageHash);
        secp256k1Wasm.heapU8.set(signature, schnorrSigPtr);
        return (secp256k1Wasm.schnorrVerify(contextPtr, schnorrSigPtr, messageHashScratch, internalPublicKeyPtr) === 1);
    };
    const verifySignatureSchnorr = () => (signature, publicKey, messageHash) => parsePublicKey(publicKey)
        ? verifyMessageSchnorr(messageHash, signature)
        : false;
    const signMessageHashRecoverable = (privateKey, messageHash) => {
        fillMessageHashScratch(messageHash);
        return withPrivateKey(privateKey, () => {
            if (secp256k1Wasm.signRecoverable(contextPtr, internalRSigPtr, messageHashScratch, privateKeyPtr) !== 1) {
                throw new Error('Failed to sign message hash. The private key is not valid.');
            }
            secp256k1Wasm.recoverableSignatureSerialize(contextPtr, sigScratch, recoveryNumPtr, internalRSigPtr);
            return {
                recoveryId: getRecoveryNumPtr(),
                signature: secp256k1Wasm
                    .readHeapU8(sigScratch, 64 /* compactSig */)
                    .slice(),
            };
        });
    };
    const recoverPublicKey = (compressed) => (signature, recoveryId, messageHash) => {
        fillMessageHashScratch(messageHash);
        secp256k1Wasm.heapU8.set(signature, sigScratch);
        if (secp256k1Wasm.recoverableSignatureParse(contextPtr, internalRSigPtr, sigScratch, recoveryId) !== 1) {
            throw new Error('Failed to recover public key. Could not parse signature.');
        }
        if (secp256k1Wasm.recover(contextPtr, internalPublicKeyPtr, internalRSigPtr, messageHashScratch) !== 1) {
            throw new Error('Failed to recover public key. The compact signature, recovery, or message hash is invalid.');
        }
        return getSerializedPublicKey(compressed);
    };
    const addTweakPrivateKey = (privateKey, tweakValue) => {
        fillMessageHashScratch(tweakValue);
        return withPrivateKey(privateKey, () => {
            if (secp256k1Wasm.privkeyTweakAdd(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
                throw new Error('Private key is invalid or adding failed.');
            }
            return secp256k1Wasm
                .readHeapU8(privateKeyPtr, 32 /* privateKey */)
                .slice();
        });
    };
    const mulTweakPrivateKey = (privateKey, tweakValue) => {
        fillMessageHashScratch(tweakValue);
        return withPrivateKey(privateKey, () => {
            if (secp256k1Wasm.privkeyTweakMul(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
                throw new Error('Private key is invalid or multiplying failed.');
            }
            return secp256k1Wasm
                .readHeapU8(privateKeyPtr, 32 /* privateKey */)
                .slice();
        });
    };
    const addTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
        if (!parsePublicKey(publicKey)) {
            throw new Error('Failed to parse public key.');
        }
        fillMessageHashScratch(tweakValue);
        if (secp256k1Wasm.pubkeyTweakAdd(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
            throw new Error('Adding failed');
        }
        return getSerializedPublicKey(compressed);
    };
    const mulTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
        if (!parsePublicKey(publicKey)) {
            throw new Error('Failed to parse public key.');
        }
        fillMessageHashScratch(tweakValue);
        if (secp256k1Wasm.pubkeyTweakMul(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
            throw new Error('Multiplying failed');
        }
        return getSerializedPublicKey(compressed);
    };
    /**
     * The value of this precaution is debatable, especially in the context of
     * javascript and WebAssembly.
     *
     * In the secp256k1 C library, context randomization is an additional layer of
     * security from side-channel attacks which attempt to extract private key
     * information by analyzing things like a CPU's emitted radio frequencies or
     * power usage.
     *
     * In this library, these attacks seem even less likely, since the "platform"
     * on which this code will be executed (e.g. V8) is likely to obscure any
     * such signals.
     *
     * Still, out of an abundance of caution (and because no one has produced a
     * definitive proof indicating that this is not helpful), this library exposes
     * the ability to randomize the context like the C library. Depending on the
     * intended application, consumers can decide whether or not to randomize.
     */
    if (randomSeed !== undefined) {
        const randomSeedPtr = messageHashScratch;
        secp256k1Wasm.heapU8.set(randomSeed, randomSeedPtr);
        secp256k1Wasm.contextRandomize(contextPtr, randomSeedPtr);
        zeroOutPtr(randomSeedPtr, 32 /* randomSeed */);
    }
    return {
        addTweakPrivateKey,
        addTweakPublicKeyCompressed: addTweakPublicKey(true),
        addTweakPublicKeyUncompressed: addTweakPublicKey(false),
        compressPublicKey: convertPublicKey(true),
        derivePublicKeyCompressed: derivePublicKey(true),
        derivePublicKeyUncompressed: derivePublicKey(false),
        malleateSignatureCompact: modifySignature(false, false),
        malleateSignatureDER: modifySignature(true, false),
        mulTweakPrivateKey,
        mulTweakPublicKeyCompressed: mulTweakPublicKey(true),
        mulTweakPublicKeyUncompressed: mulTweakPublicKey(false),
        normalizeSignatureCompact: modifySignature(false, true),
        normalizeSignatureDER: modifySignature(true, true),
        recoverPublicKeyCompressed: recoverPublicKey(true),
        recoverPublicKeyUncompressed: recoverPublicKey(false),
        signMessageHashCompact: signMessageHash(false),
        signMessageHashDER: signMessageHash(true),
        signMessageHashRecoverableCompact: signMessageHashRecoverable,
        signMessageHashSchnorr: signMessageHashSchnorr(),
        signatureCompactToDER: convertSignature(false),
        signatureDERToCompact: convertSignature(true),
        uncompressPublicKey: convertPublicKey(false),
        validatePrivateKey: (privateKey) => withPrivateKey(privateKey, () => secp256k1Wasm.seckeyVerify(contextPtr, privateKeyPtr) === 1),
        verifySignatureCompact: verifySignature(false, true),
        verifySignatureCompactLowS: verifySignature(false, false),
        verifySignatureDER: verifySignature(true, true),
        verifySignatureDERLowS: verifySignature(true, false),
        verifySignatureSchnorr: verifySignatureSchnorr(),
    };
};
/**
 * This method is like `instantiateSecp256k1`, but requires the consumer to
 * `Window.fetch` or `fs.readFile` the `secp256k1.wasm` binary and provide it to
 * this method as `webassemblyBytes`. This skips a base64 decoding of an
 * embedded binary.
 *
 * ### Randomizing the Context with `randomSeed`
 * This method also accepts an optional, 32-byte `randomSeed`, which is passed
 * to the `contextRandomize` method in the underlying WebAssembly.
 *
 * The value of this precaution is debatable, especially in the context of
 * javascript and WebAssembly.
 *
 * In the secp256k1 C library, context randomization is an additional layer of
 * security from side-channel attacks which attempt to extract private key
 * information by analyzing things like a CPU's emitted radio frequencies or
 * power usage.
 *
 * In this library, these attacks seem even less likely, since the "platform"
 * on which this code will be executed (e.g. V8) is likely to obscure any
 * such signals.
 *
 * Still, out of an abundance of caution (and because no one has produced a
 * definitive proof indicating that this is not helpful), this library exposes
 * the ability to randomize the context like the C library. Depending on the
 * intended application, consumers can decide whether or not to randomize.
 *
 * @param webassemblyBytes - an ArrayBuffer containing the bytes from bitcoin-ts'
 * `secp256k1.wasm` binary. Providing this buffer manually may be faster than
 * the internal base64 decode which happens in `instantiateSecp256k1`.
 * @param randomSeed - a 32-byte random seed used to randomize the secp256k1
 * context after creation. See above for details.
 */
export const instantiateSecp256k1Bytes = async (webassemblyBytes, randomSeed) => wrapSecp256k1Wasm(await instantiateSecp256k1WasmBytes(webassemblyBytes), randomSeed);
/**
 * Create and wrap a Secp256k1 WebAssembly instance to expose a set of
 * purely-functional Secp256k1 methods. For slightly faster initialization, use
 * `instantiateSecp256k1Bytes`.
 *
 * TODO: cache resulting instance to return in all future calls
 *
 * @param randomSeed - a 32-byte random seed used to randomize the secp256k1
 * context after creation. See the description in `instantiateSecp256k1Bytes`
 * for details.
 */
export const instantiateSecp256k1 = async (randomSeed) => wrapSecp256k1Wasm(await instantiateSecp256k1Wasm(), randomSeed);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jcnlwdG8vc2VjcDI1NmsxLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJIQUEySDtBQUMzSCxPQUFPLEVBQ0wsZUFBZSxFQUNmLFdBQVcsRUFDWCx3QkFBd0IsRUFDeEIsNkJBQTZCLEdBRTlCLE1BQU0sWUFBWSxDQUFDO0FBcUJwQjs7OztHQUlHO0FBQ0gsTUFBTSxpQkFBaUIsR0FBRyxDQUN4QixhQUE0QixFQUM1QixVQUF1QixFQUNaLEVBQUU7SUFDYjs7OztPQUlHO0lBQ0gsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFakU7Ozs7Ozs7Ozs7T0FVRztJQUNILE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxNQUFNLHNCQUF3QixDQUFDO0lBQ2hFLE1BQU0sZ0JBQWdCLEdBQUcsYUFBYSxDQUFDLE1BQU0sdUJBQXlCLENBQUM7SUFDdkUsTUFBTSxrQkFBa0IsR0FBRyxhQUFhLENBQUMsTUFBTSxzQkFBd0IsQ0FBQztJQUN4RSxNQUFNLG9CQUFvQixHQUFHLGFBQWEsQ0FBQyxNQUFNLDRCQUVoRCxDQUFDO0lBQ0YsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDLE1BQU0sc0JBQXdCLENBQUM7SUFDcEUsTUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLE1BQU0scUJBQXVCLENBQUM7SUFDbEUsTUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLE1BQU0scUJBQXVCLENBQUM7SUFFbEUsTUFBTSxlQUFlLEdBQUcsYUFBYSxDQUFDLE1BQU0seUJBQTJCLENBQUM7SUFDeEUsK0RBQStEO0lBQy9ELE1BQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0MsMkVBQTJFO0lBQzNFLE1BQU0sb0JBQW9CLEdBQUcsY0FBYyxJQUFJLENBQUMsQ0FBQztJ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
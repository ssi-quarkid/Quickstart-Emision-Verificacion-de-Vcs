export var BaseConversionError;
(function (BaseConversionError) {
    BaseConversionError["tooLong"] = "An alphabet may be no longer than 254 characters.";
    BaseConversionError["ambiguousCharacter"] = "A character code may only appear once in a single alphabet.";
    BaseConversionError["unknownCharacter"] = "Encountered an unknown character for this alphabet.";
})(BaseConversionError || (BaseConversionError = {}));
/**
 * Create a `BaseConverter`, which exposes methods for encoding and decoding
 * `Uint8Array`s using bitcoin-style padding: each leading zero in the input is
 * replaced with the zero-index character of the `alphabet`, then the remainder
 * of the input is encoded as a large number in the specified alphabet.
 *
 * For example, using the alphabet `01`, the input `[0, 15]` is encoded `01111`
 * â€“ a single `0` represents the leading padding, followed by the base2 encoded
 * `0x1111` (15). With the same alphabet, the input `[0, 0, 255]` is encoded
 * `0011111111` - only two `0` characters are required to represent both
 * leading zeros, followed by the base2 encoded `0x11111111` (255).
 *
 * **This is not compatible with `RFC 3548`'s `Base16`, `Base32`, or `Base64`.**
 *
 * If the alphabet is malformed, this method returns the error as a `string`.
 *
 * @param alphabet - an ordered string which maps each index to a character,
 * e.g. `0123456789`.
 * @privateRemarks
 * Algorithm from the `base-x` implementation (which is derived from the
 * original Satoshi implementation): https://github.com/cryptocoinjs/base-x
 */
export const createBaseConverter = (alphabet) => {
    const undefinedValue = 255;
    const Uint8ArrayBase = 256;
    if (alphabet.length >= undefinedValue)
        return BaseConversionError.tooLong;
    const alphabetMap = new Uint8Array(Uint8ArrayBase).fill(undefinedValue);
    // eslint-disable-next-line functional/no-loop-statement, functional/no-let, no-plusplus
    for (let index = 0; index < alphabet.length; index++) {
        const characterCode = alphabet.charCodeAt(index);
        if (alphabetMap[characterCode] !== undefinedValue) {
            return BaseConversionError.ambiguousCharacter;
        }
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        alphabetMap[characterCode] = index;
    }
    const base = alphabet.length;
    const paddingCharacter = alphabet.charAt(0);
    const factor = Math.log(base) / Math.log(Uint8ArrayBase);
    const inverseFactor = Math.log(Uint8ArrayBase) / Math.log(base);
    return {
        // eslint-disable-next-line complexity
        decode: (input) => {
            if (input.length === 0)
                return Uint8Array.of();
            const firstNonZeroIndex = input
                .split('')
                .findIndex((character) => character !== paddingCharacter);
            if (firstNonZeroIndex === -1) {
                return new Uint8Array(input.length);
            }
            const requiredLength = Math.floor((input.length - firstNonZeroIndex) * factor + 1);
            const decoded = new Uint8Array(requiredLength);
            /* eslint-disable functional/no-let, functional/no-expression-statement */
            let nextByte = firstNonZeroIndex;
            let remainingBytes = 0;
            // eslint-disable-next-line functional/no-loop-statement
            while (input[nextByte] !== undefined) {
                let carry = alphabetMap[input.charCodeAt(nextByte)];
                if (carry === undefinedValue)
                    return BaseConversionError.unknownCharacter;
                let digit = 0;
                // eslint-disable-next-line functional/no-loop-statement
                for (let steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1; 
                // eslint-disable-next-line no-plusplus
                steps--, digit++) {
                    carry += Math.floor(base * decoded[steps]);
                    // eslint-disable-next-line functional/immutable-data
                    decoded[steps] = Math.floor(carry % Uint8ArrayBase);
                    carry = Math.floor(carry / Uint8ArrayBase);
                }
                remainingBytes = digit;
                // eslint-disable-next-line no-plusplus
                nextByte++;
            }
            /* eslint-enable functional/no-let, functional/no-expression-statement */
            const firstNonZeroResultDigit = decoded.findIndex((value) => value !== 0);
            const bin = new Uint8Array(firstNonZeroIndex + (requiredLength - firstNonZeroResultDigit));
            // eslint-disable-next-line functional/no-expression-statement
            bin.set(decoded.slice(firstNonZeroResultDigit), firstNonZeroIndex);
            return bin;
        },
        // eslint-disable-next-line complexity
        encode: (input) => {
            if (input.length === 0)
                return '';
            const firstNonZeroIndex = input.findIndex((byte) => byte !== 0);
            if (firstNonZeroIndex === -1) {
                return paddingCharacter.repeat(input.length);
            }
            const requiredLength = Math.floor((input.length - firstNonZeroIndex) * inverseFactor + 1);
            const encoded = new Uint8Array(requiredLength);
            /* eslint-disable functional/no-let, functional/no-expression-statement */
            let nextByte = firstNonZeroIndex;
            let remainingBytes = 0;
            // eslint-disable-next-line functional/no-loop-statement
            while (nextByte !== input.length) {
                let carry = input[nextByte];
                let digit = 0;
                // eslint-disable-next-line functional/no-loop-statement
                for (let steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1; 
                // eslint-disable-next-line no-plusplus
                steps--, digit++) {
                    carry += Math.floor(Uint8ArrayBase * encoded[steps]);
                    // eslint-disable-next-line functional/immutable-data
                    encoded[steps] = Math.floor(carry % base);
                    carry = Math.floor(carry / base);
                }
                remainingBytes = digit;
                // eslint-disable-next-line no-plusplus
                nextByte++;
            }
            /* eslint-enable functional/no-let, functional/no-expression-statement */
            const firstNonZeroResultDigit = encoded.findIndex((value) => value !== 0);
            const padding = paddingCharacter.repeat(firstNonZeroIndex);
            return encoded
                .slice(firstNonZeroResultDigit)
                .reduce((all, digit) => all + alphabet.charAt(digit), padding);
        },
    };
};
export const bitcoinBase58Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const base58 = createBaseConverter(bitcoinBase58Alphabet);
/**
 * Convert a bitcoin-style base58-encoded string to a Uint8Array.
 *
 * See `createBaseConverter` for format details.
 * @param input - a valid base58-encoded string to decode
 */
export const base58ToBin = base58.decode;
/**
 * Convert a Uint8Array to a bitcoin-style base58-encoded string.
 *
 * See `createBaseConverter` for format details.
 * @param input - the Uint8Array to base58 encode
 */
export const binToBase58 = base58.encode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1jb252ZXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9mb3JtYXQvYmFzZS1jb252ZXJ0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBTixJQUFZLG1CQUlYO0FBSkQsV0FBWSxtQkFBbUI7SUFDN0Isb0ZBQTZELENBQUE7SUFDN0QseUdBQWtGLENBQUE7SUFDbEYsK0ZBQXdFLENBQUE7QUFDMUUsQ0FBQyxFQUpXLG1CQUFtQixLQUFuQixtQkFBbUIsUUFJOUI7QUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUJHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUcsQ0FDakMsUUFBZ0IsRUFDcUIsRUFBRTtJQUN2QyxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUM7SUFDM0IsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0lBRTNCLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxjQUFjO1FBQUUsT0FBTyxtQkFBbUIsQ0FBQyxPQUFPLENBQUM7SUFFMUUsTUFBTSxXQUFXLEdBQUcsSUFBSSxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBRXhFLHdGQUF3RjtJQUN4RixLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUNwRCxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pELElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxLQUFLLGNBQWMsRUFBRTtZQUNqRCxPQUFPLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDO1NBQy9DO1FBQ0QseUZBQXlGO1FBQ3pGLFdBQVcsQ0FBQyxhQUFhLENBQUMsR0FBRyxLQUFLLENBQUM7S0FDcEM7SUFFRCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFD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
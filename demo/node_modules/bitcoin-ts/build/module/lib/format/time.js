import { binToNumberUint32LE, numberToBinUint32LE } from './numbers';
var Constants;
(function (Constants) {
    Constants[Constants["msPerLocktimeSecond"] = 1000] = "msPerLocktimeSecond";
    Constants[Constants["minimumTimestamp"] = 500000000] = "minimumTimestamp";
    Constants[Constants["maximumLocktime"] = 4294967295] = "maximumLocktime";
    Constants[Constants["byteLength"] = 4] = "byteLength";
})(Constants || (Constants = {}));
/**
 * The minimum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
export const minimumLocktimeDate = new Date(Constants.minimumTimestamp * Constants.msPerLocktimeSecond);
/**
 * The maximum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
export const maximumLocktimeDate = new Date(Constants.maximumLocktime * Constants.msPerLocktimeSecond);
export var LocktimeError;
(function (LocktimeError) {
    LocktimeError["outOfRange"] = "The provided Date is outside of the range which can be encoded in locktime.";
    LocktimeError["incorrectLength"] = "The provided locktime is not the correct length (4 bytes).";
})(LocktimeError || (LocktimeError = {}));
/**
 * Convert a Javascript `Date` object to its equivalent transaction `locktime`
 * representation. The `date` is rounded to the nearest second (the precision of
 * `locktime` Dates).
 *
 * Note: a block-based locktime can simply be encoded with `numberToBinUint32LE`
 * (provided it is no larger than the maximum, `499999999`).
 *
 * @param date - the Date to convert to a locktime Uint8Array
 */
export const dateToLocktime = (date) => date < minimumLocktimeDate || date > maximumLocktimeDate
    ? LocktimeError.outOfRange
    : numberToBinUint32LE(Math.round(date.getTime() / Constants.msPerLocktimeSecond));
/**
 * Parse a locktime, returning a `number` for block heights, a `Date` for block
 * times, or a string for parsing errors.
 *
 * @param bin - the 4-byte Uint8Array locktime to parse
 */
export const parseLocktime = (bin) => {
    if (bin.length !== Constants.byteLength)
        return LocktimeError.incorrectLength;
    const parsed = binToNumberUint32LE(bin);
    return parsed >= Constants.minimumTimestamp
        ? new Date(parsed * Constants.msPerLocktimeSecond)
        : parsed;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvZm9ybWF0L3RpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXJFLElBQUssU0FLSjtBQUxELFdBQUssU0FBUztJQUNaLDBFQUEwQixDQUFBO0lBQzFCLHlFQUE0QixDQUFBO0lBQzVCLHdFQUE0QixDQUFBO0lBQzVCLHFEQUFjLENBQUE7QUFDaEIsQ0FBQyxFQUxJLFNBQVMsS0FBVCxTQUFTLFFBS2I7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLElBQUksQ0FDekMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxtQkFBbUIsQ0FDM0QsQ0FBQztBQUVGOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLElBQUksSUFBSSxDQUN6QyxTQUFTLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQyxtQkFBbUIsQ0FDMUQsQ0FBQztBQUVGLE1BQU0sQ0FBTixJQUFZLGFBR1g7QUFIRCxXQUFZLGFBQWE7SUFDdkIsMkdBQTBGLENBQUE7SUFDMUYsK0ZBQThFLENBQUE7QUFDaEYsQ0FBQyxFQUhXLGFBQWEsS0FBYixhQUFhLFFBR3hCO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQUMsSUFBVSxFQUFFLEVBQUUsQ0FDM0MsSUFBSSxHQUFHLG1CQUFtQixJQUFJLElBQUksR0FBRyxtQkFBbUI7SUFDdEQsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxVQUFVO0lBQzFCLENBQUMsQ0FBQyxtQkFBbUIsQ0FDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQzNELENBQUM7QUFFUjs7Ozs7R0FLRztBQUNILE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUFDLEdBQWUsRUFBRSxFQUFFO0lBQy9DLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxTQUFTLENBQUMsVUFBVTtRQUFFLE9BQU8sYUFBYSxDQUFDLGVBQWUsQ0FBQztJQUM5RSxNQUFNLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QyxPQUFPLE1BQU0sSUFBSSxTQUFTLENBQUMsZ0JBQWdCO1FBQ3pDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLG1CQUFtQixDQUFDO1FBQ2xELENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDYixDQUFDLENBQUMifQ==